//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAddressesClient {
    getAllAddresses(): Observable<AddressDto[]>;
    getAddressesByCustomerId(customerId: string): Observable<AddressDto[]>;
    getAddressById(id: number): Observable<AddressDto>;
    update(id: number, command: UpdateAddressCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateAddressCommand): Observable<number>;
    deleteRangeAddress(ids: number[]): Observable<FileResponse>;
    isUniqueAddressTitle(customerId: string | undefined, addressId: number | undefined, title: string | undefined): Observable<boolean>;
    isUniqueAddressPostcode(customerId: string | undefined, addressId: number | undefined, postcode: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class AddressesClient implements IAddressesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllAddresses(): Observable<AddressDto[]> {
        let url_ = this.baseUrl + "/api/Addresses/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAddresses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto[]>;
        }));
    }

    protected processGetAllAddresses(response: HttpResponseBase): Observable<AddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAddressesByCustomerId(customerId: string): Observable<AddressDto[]> {
        let url_ = this.baseUrl + "/api/Addresses/customer{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressesByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressesByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto[]>;
        }));
    }

    protected processGetAddressesByCustomerId(response: HttpResponseBase): Observable<AddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAddressById(id: number): Observable<AddressDto> {
        let url_ = this.baseUrl + "/api/Addresses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto>;
        }));
    }

    protected processGetAddressById(response: HttpResponseBase): Observable<AddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateAddressCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Addresses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Addresses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Addresses/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateAddressCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Addresses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeAddress(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Addresses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeAddress(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueAddressTitle(customerId: string | undefined, addressId: number | undefined, title: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Addresses/isUniqueTitle?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (addressId === null)
            throw new Error("The parameter 'addressId' cannot be null.");
        else if (addressId !== undefined)
            url_ += "AddressId=" + encodeURIComponent("" + addressId) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueAddressTitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueAddressTitle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueAddressTitle(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueAddressPostcode(customerId: string | undefined, addressId: number | undefined, postcode: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Addresses/isUniquePostcode?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (addressId === null)
            throw new Error("The parameter 'addressId' cannot be null.");
        else if (addressId !== undefined)
            url_ += "AddressId=" + encodeURIComponent("" + addressId) + "&";
        if (postcode === null)
            throw new Error("The parameter 'postcode' cannot be null.");
        else if (postcode !== undefined)
            url_ += "Postcode=" + encodeURIComponent("" + postcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueAddressPostcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueAddressPostcode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueAddressPostcode(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICreditsClient {
    getCreditsByCustomerIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, searchTerm: string | null | undefined, customerId: string | undefined): Observable<FilteredCreditDto>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    getMaxCreditsByCustomerIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, searchTerm: string | null | undefined, customerId: string | undefined): Observable<FilteredMaxCreditDto>;
    exportMaxExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CreditsClient implements ICreditsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCreditsByCustomerIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, searchTerm: string | null | undefined, customerId: string | undefined): Observable<FilteredCreditDto> {
        let url_ = this.baseUrl + "/api/Credits?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreditsByCustomerIdWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreditsByCustomerIdWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredCreditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredCreditDto>;
        }));
    }

    protected processGetCreditsByCustomerIdWithPagination(response: HttpResponseBase): Observable<FilteredCreditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredCreditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Credits/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMaxCreditsByCustomerIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, searchTerm: string | null | undefined, customerId: string | undefined): Observable<FilteredMaxCreditDto> {
        let url_ = this.baseUrl + "/api/Credits/max?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaxCreditsByCustomerIdWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxCreditsByCustomerIdWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredMaxCreditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredMaxCreditDto>;
        }));
    }

    protected processGetMaxCreditsByCustomerIdWithPagination(response: HttpResponseBase): Observable<FilteredMaxCreditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredMaxCreditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportMaxExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Credits/exportExcelMax?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportMaxExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportMaxExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportMaxExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICustomersClient {
    getAllCustomers(): Observable<CustomerDto[]>;
    getCustomersByIds(ids: string[] | undefined): Observable<CustomerDto[]>;
    getCustomerById(id: string): Observable<CustomerDto>;
    create(command: CreateCustomerCommand): Observable<string>;
    update(urlId: string, command: UpdateCustomerCommand): Observable<FileResponse>;
    setCustomerCredit(command: SetCustomerCreditCommand): Observable<FileResponse>;
    setMaxCustomerCredit(command: SetCustomerMaxCreditCommand): Observable<FileResponse>;
    addVehicleToCustomer(command: AddVehicleToCustomerCommand): Observable<FileResponse>;
    removeVehicleFromCustomer(vehicleId: number | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomersClient implements ICustomersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllCustomers(): Observable<CustomerDto[]> {
        let url_ = this.baseUrl + "/api/Customers/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto[]>;
        }));
    }

    protected processGetAllCustomers(response: HttpResponseBase): Observable<CustomerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomersByIds(ids: string[] | undefined): Observable<CustomerDto[]> {
        let url_ = this.baseUrl + "/api/Customers/byIds?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomersByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomersByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto[]>;
        }));
    }

    protected processGetCustomersByIds(response: HttpResponseBase): Observable<CustomerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomerById(id: string): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto>;
        }));
    }

    protected processGetCustomerById(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCustomerCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: string, command: UpdateCustomerCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setCustomerCredit(command: SetCustomerCreditCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/setCredit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCustomerCredit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCustomerCredit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSetCustomerCredit(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setMaxCustomerCredit(command: SetCustomerMaxCreditCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/setMaxCredit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetMaxCustomerCredit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetMaxCustomerCredit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSetMaxCustomerCredit(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addVehicleToCustomer(command: AddVehicleToCustomerCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/addVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVehicleToCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVehicleToCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAddVehicleToCustomer(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeVehicleFromCustomer(vehicleId: number | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/removeVehicle?";
        if (vehicleId === null)
            throw new Error("The parameter 'vehicleId' cannot be null.");
        else if (vehicleId !== undefined)
            url_ += "vehicleId=" + encodeURIComponent("" + vehicleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveVehicleFromCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveVehicleFromCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveVehicleFromCustomer(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICustomerTypesClient {
    getAllCustomerTypes(): Observable<CustomerTypeDto[]>;
    getCustomerTypeById(id: number): Observable<CustomerTypeDto>;
    update(id: number, command: UpdateCustomerTypeCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateCustomerTypeCommand): Observable<number>;
    deleteRangeCustomerType(ids: number[]): Observable<FileResponse>;
    isUniqueCustomerType(customerTypeId: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomerTypesClient implements ICustomerTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllCustomerTypes(): Observable<CustomerTypeDto[]> {
        let url_ = this.baseUrl + "/api/CustomerTypes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTypeDto[]>;
        }));
    }

    protected processGetAllCustomerTypes(response: HttpResponseBase): Observable<CustomerTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomerTypeById(id: number): Observable<CustomerTypeDto> {
        let url_ = this.baseUrl + "/api/CustomerTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTypeDto>;
        }));
    }

    protected processGetCustomerTypeById(response: HttpResponseBase): Observable<CustomerTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCustomerTypeCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CustomerTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CustomerTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CustomerTypes/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCustomerTypeCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CustomerTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeCustomerType(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CustomerTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeCustomerType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeCustomerType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeCustomerType(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueCustomerType(customerTypeId: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/CustomerTypes/isUniqueCustomerType?";
        if (customerTypeId === null)
            throw new Error("The parameter 'customerTypeId' cannot be null.");
        else if (customerTypeId !== undefined)
            url_ += "CustomerTypeId=" + encodeURIComponent("" + customerTypeId) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueCustomerType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueCustomerType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueCustomerType(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUsersClient {
    getAllUsers(): Observable<UserDto[]>;
    getUserById(id: string): Observable<UserDto>;
    delete(id: string): Observable<FileResponse>;
    create(command: CreateUserCommand): Observable<string>;
    update(urlId: string, command: UpdateUserCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllUsers(): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/Users/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserById(id: string): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateUserCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: string, command: UpdateUserCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISevenSyncDataClient {
    updateSevenPrices(command: UpdateSevenPricesCommand): Observable<FileResponse>;
    updateSevenCountsAndPrices(command: UpdateSevenCountsAndPricesCommand): Observable<FileResponse>;
    updateSevenCounts(command: UpdateSevenCountsCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class SevenSyncDataClient implements ISevenSyncDataClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    updateSevenPrices(command: UpdateSevenPricesCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SevenSyncData/prices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSevenPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSevenPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateSevenPrices(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateSevenCountsAndPrices(command: UpdateSevenCountsAndPricesCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SevenSyncData/countsAndPrices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSevenCountsAndPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSevenCountsAndPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateSevenCountsAndPrices(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateSevenCounts(command: UpdateSevenCountsCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SevenSyncData/counts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSevenCounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSevenCounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateSevenCounts(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReturnOrderItemDocumentsClient {
    getReturnOrderItemDocumentsByReturnOrderItemId(returnOrderItemId: number | undefined): Observable<ReturnOrderItemDocumentDto[]>;
    create(command: CreateReturnOrderItemDocumentCommand): Observable<number>;
    deleteRange(command: DeleteRangeReturnOrderItemDocumentCommand): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    update(id: number, command: UpdateReturnOrderItemDocumentCommand): Observable<FileResponse>;
    delete(id: number, command: DeleteReturnOrderItemDocumentCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReturnOrderItemDocumentsClient implements IReturnOrderItemDocumentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getReturnOrderItemDocumentsByReturnOrderItemId(returnOrderItemId: number | undefined): Observable<ReturnOrderItemDocumentDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrderItemDocuments?";
        if (returnOrderItemId === null)
            throw new Error("The parameter 'returnOrderItemId' cannot be null.");
        else if (returnOrderItemId !== undefined)
            url_ += "ReturnOrderItemId=" + encodeURIComponent("" + returnOrderItemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderItemDocumentsByReturnOrderItemId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderItemDocumentsByReturnOrderItemId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderItemDocumentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderItemDocumentDto[]>;
        }));
    }

    protected processGetReturnOrderItemDocumentsByReturnOrderItemId(response: HttpResponseBase): Observable<ReturnOrderItemDocumentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderItemDocumentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateReturnOrderItemDocumentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ReturnOrderItemDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(command: DeleteRangeReturnOrderItemDocumentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderItemDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderItemDocuments/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateReturnOrderItemDocumentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderItemDocuments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number, command: DeleteReturnOrderItemDocumentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderItemDocuments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReturnOrderItemGroupProductAttributeOptionValuesClient {
    getOptionValuesByReturnOrderItemGroupId(returnOrderItemGroupId: number | undefined): Observable<ReturnOrderItemGroupProductAttributeOptionValueDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReturnOrderItemGroupProductAttributeOptionValuesClient implements IReturnOrderItemGroupProductAttributeOptionValuesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getOptionValuesByReturnOrderItemGroupId(returnOrderItemGroupId: number | undefined): Observable<ReturnOrderItemGroupProductAttributeOptionValueDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrderItemGroupProductAttributeOptionValues?";
        if (returnOrderItemGroupId === null)
            throw new Error("The parameter 'returnOrderItemGroupId' cannot be null.");
        else if (returnOrderItemGroupId !== undefined)
            url_ += "ReturnOrderItemGroupId=" + encodeURIComponent("" + returnOrderItemGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOptionValuesByReturnOrderItemGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptionValuesByReturnOrderItemGroupId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderItemGroupProductAttributeOptionValueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderItemGroupProductAttributeOptionValueDto[]>;
        }));
    }

    protected processGetOptionValuesByReturnOrderItemGroupId(response: HttpResponseBase): Observable<ReturnOrderItemGroupProductAttributeOptionValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderItemGroupProductAttributeOptionValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderItemGroupProductAttributeOptionValues/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReturnOrderItemGroupsClient {
    getReturnOrderItemGroupsByReturnOrderId(returnOrderId: number | undefined): Observable<ReturnOrderItemGroupDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReturnOrderItemGroupsClient implements IReturnOrderItemGroupsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getReturnOrderItemGroupsByReturnOrderId(returnOrderId: number | undefined): Observable<ReturnOrderItemGroupDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrderItemGroups?";
        if (returnOrderId === null)
            throw new Error("The parameter 'returnOrderId' cannot be null.");
        else if (returnOrderId !== undefined)
            url_ += "ReturnOrderId=" + encodeURIComponent("" + returnOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderItemGroupsByReturnOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderItemGroupsByReturnOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderItemGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderItemGroupDto[]>;
        }));
    }

    protected processGetReturnOrderItemGroupsByReturnOrderId(response: HttpResponseBase): Observable<ReturnOrderItemGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderItemGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderItemGroups/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReturnOrderItemsClient {
    getReturnOrderItemsByReturnOrderItemGroupId(returnOrderItemGroupId: number | undefined): Observable<ReturnOrderItemDto[]>;
    create(command: CreateReturnOrderItemCommand): Observable<number>;
    deleteRange(command: DeleteRangeReturnOrderItemCommand): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    update(id: number, command: UpdateReturnOrderItemCommand): Observable<FileResponse>;
    delete(id: number, command: DeleteReturnOrderItemCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReturnOrderItemsClient implements IReturnOrderItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getReturnOrderItemsByReturnOrderItemGroupId(returnOrderItemGroupId: number | undefined): Observable<ReturnOrderItemDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrderItems?";
        if (returnOrderItemGroupId === null)
            throw new Error("The parameter 'returnOrderItemGroupId' cannot be null.");
        else if (returnOrderItemGroupId !== undefined)
            url_ += "ReturnOrderItemGroupId=" + encodeURIComponent("" + returnOrderItemGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderItemsByReturnOrderItemGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderItemsByReturnOrderItemGroupId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderItemDto[]>;
        }));
    }

    protected processGetReturnOrderItemsByReturnOrderItemGroupId(response: HttpResponseBase): Observable<ReturnOrderItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateReturnOrderItemCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ReturnOrderItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(command: DeleteRangeReturnOrderItemCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderItems/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateReturnOrderItemCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number, command: DeleteReturnOrderItemCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReturnOrdersClient {
    getAllReturnOrders(): Observable<ReturnOrderDto[]>;
    getReturnOrdersCount(): Observable<number>;
    getReturnOrdersWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto>;
    create(command: CreateReturnOrderCommand): Observable<number>;
    getAcceptedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto>;
    getAllConfirmedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto>;
    getCanceledReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto>;
    getCompletedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto>;
    getCostRefundedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto>;
    getReceivedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto>;
    getRegisteredReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto>;
    getRejectedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto>;
    getSentReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto>;
    getSomeConfirmedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto>;
    getReturnOrdersByCustomerId(customerId: string): Observable<ReturnOrderDto[]>;
    getReturnOrdersByProductId(productId: number): Observable<ReturnOrderDto[]>;
    getReturnOrderInfo(id: number): Observable<ReturnOrderInfoDto>;
    getReturnOrderItemsByReturnOrderItemGroupId(returnOrderGroupId: number): Observable<ReturnOrderItemDto[]>;
    getReturnOrderTotalsByReturnOrderId(returnOrderId: number): Observable<ReturnOrderTotalDto[]>;
    getSendReturnOrderTotalByReturnOrderId(returnOrderId: number): Observable<SendReturnOrderTotalDto>;
    getReturnOrderItemGroupsByReturnOrderId(returnOrderId: number): Observable<ReturnOrderItemGroupDto[]>;
    getOptionValuesByReturnOrderItemGroupId(returnOrderItemGroupId: number): Observable<ReturnOrderItemGroupProductAttributeOptionValueDto[]>;
    getReturnOrderItemDocumentsByReturnOrderItemId(returnOrderItemId: number): Observable<ReturnOrderItemDocumentDto[]>;
    getReturnOrderStatesByReturnOrderId(returnOrderId: number): Observable<ReturnOrderStateBaseDto[]>;
    getReturnOrderById(id: number): Observable<ReturnOrderDto>;
    getCurrentReturnOrderStateByReturnOrderId(returnOrderId: number): Observable<ReturnOrderStateBaseDto>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelAcceptedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelAllConfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelCanceledQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelCompletedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelCostRefundedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelReceivedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelRegisteredQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelRejectedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelSentQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelSomeConfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    accept(id: number, command: AcceptReturnOrderCommand): Observable<FileResponse>;
    cancel(id: number, command: CancelReturnOrderCommand): Observable<FileResponse>;
    complete(id: number, command: CompleteReturnOrderCommand): Observable<FileResponse>;
    confirmAll(id: number, command: ConfirmAllReturnOrderCommand): Observable<FileResponse>;
    confirmSome(id: number, command: ConfirmSomeReturnOrderCommand): Observable<FileResponse>;
    receive(id: number, command: ReceiveReturnOrderCommand): Observable<FileResponse>;
    refundCost(id: number, command: RefundReturnOrderCostCommand): Observable<FileResponse>;
    reject(id: number, command: RejectReturnOrderCommand): Observable<FileResponse>;
    send(id: number, command: SendReturnOrderCommand): Observable<FileResponse>;
    update(id: number, command: UpdateReturnOrderCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReturnOrdersClient implements IReturnOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllReturnOrders(): Observable<ReturnOrderDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrders/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderDto[]>;
        }));
    }

    protected processGetAllReturnOrders(response: HttpResponseBase): Observable<ReturnOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrdersCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/ReturnOrders/count";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrdersCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrdersCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetReturnOrdersCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrdersWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrdersWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrdersWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReturnOrderDto>;
        }));
    }

    protected processGetReturnOrdersWithPagination(response: HttpResponseBase): Observable<FilteredReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateReturnOrderCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ReturnOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAcceptedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/accepted?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAcceptedReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAcceptedReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReturnOrderDto>;
        }));
    }

    protected processGetAcceptedReturnOrders(response: HttpResponseBase): Observable<FilteredReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllConfirmedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/allConfirmed?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllConfirmedReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllConfirmedReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReturnOrderDto>;
        }));
    }

    protected processGetAllConfirmedReturnOrders(response: HttpResponseBase): Observable<FilteredReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCanceledReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/canceled?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCanceledReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCanceledReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReturnOrderDto>;
        }));
    }

    protected processGetCanceledReturnOrders(response: HttpResponseBase): Observable<FilteredReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCompletedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/completed?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompletedReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompletedReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReturnOrderDto>;
        }));
    }

    protected processGetCompletedReturnOrders(response: HttpResponseBase): Observable<FilteredReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCostRefundedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/costRefunded?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCostRefundedReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCostRefundedReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReturnOrderDto>;
        }));
    }

    protected processGetCostRefundedReturnOrders(response: HttpResponseBase): Observable<FilteredReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReceivedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/received?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceivedReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceivedReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReturnOrderDto>;
        }));
    }

    protected processGetReceivedReturnOrders(response: HttpResponseBase): Observable<FilteredReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRegisteredReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/registered?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegisteredReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegisteredReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReturnOrderDto>;
        }));
    }

    protected processGetRegisteredReturnOrders(response: HttpResponseBase): Observable<FilteredReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRejectedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/rejected?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRejectedReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRejectedReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReturnOrderDto>;
        }));
    }

    protected processGetRejectedReturnOrders(response: HttpResponseBase): Observable<FilteredReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSentReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/sent?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSentReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSentReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReturnOrderDto>;
        }));
    }

    protected processGetSentReturnOrders(response: HttpResponseBase): Observable<FilteredReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSomeConfirmedReturnOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/someConfirmed?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSomeConfirmedReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSomeConfirmedReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReturnOrderDto>;
        }));
    }

    protected processGetSomeConfirmedReturnOrders(response: HttpResponseBase): Observable<FilteredReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrdersByCustomerId(customerId: string): Observable<ReturnOrderDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrders/customer/{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrdersByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrdersByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderDto[]>;
        }));
    }

    protected processGetReturnOrdersByCustomerId(response: HttpResponseBase): Observable<ReturnOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrdersByProductId(productId: number): Observable<ReturnOrderDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrders/product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrdersByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrdersByProductId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderDto[]>;
        }));
    }

    protected processGetReturnOrdersByProductId(response: HttpResponseBase): Observable<ReturnOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrderInfo(id: number): Observable<ReturnOrderInfoDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/info/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderInfoDto>;
        }));
    }

    protected processGetReturnOrderInfo(response: HttpResponseBase): Observable<ReturnOrderInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReturnOrderInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrderItemsByReturnOrderItemGroupId(returnOrderGroupId: number): Observable<ReturnOrderItemDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrders/returnOrderItem/{returnOrderGroupId}";
        if (returnOrderGroupId === undefined || returnOrderGroupId === null)
            throw new Error("The parameter 'returnOrderGroupId' must be defined.");
        url_ = url_.replace("{returnOrderGroupId}", encodeURIComponent("" + returnOrderGroupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderItemsByReturnOrderItemGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderItemsByReturnOrderItemGroupId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderItemDto[]>;
        }));
    }

    protected processGetReturnOrderItemsByReturnOrderItemGroupId(response: HttpResponseBase): Observable<ReturnOrderItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrderTotalsByReturnOrderId(returnOrderId: number): Observable<ReturnOrderTotalDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrders/returnOrderTotal/{returnOrderId}";
        if (returnOrderId === undefined || returnOrderId === null)
            throw new Error("The parameter 'returnOrderId' must be defined.");
        url_ = url_.replace("{returnOrderId}", encodeURIComponent("" + returnOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderTotalsByReturnOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderTotalsByReturnOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderTotalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderTotalDto[]>;
        }));
    }

    protected processGetReturnOrderTotalsByReturnOrderId(response: HttpResponseBase): Observable<ReturnOrderTotalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderTotalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSendReturnOrderTotalByReturnOrderId(returnOrderId: number): Observable<SendReturnOrderTotalDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/sendReturnOrderTotal/{returnOrderId}";
        if (returnOrderId === undefined || returnOrderId === null)
            throw new Error("The parameter 'returnOrderId' must be defined.");
        url_ = url_.replace("{returnOrderId}", encodeURIComponent("" + returnOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSendReturnOrderTotalByReturnOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSendReturnOrderTotalByReturnOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SendReturnOrderTotalDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SendReturnOrderTotalDto>;
        }));
    }

    protected processGetSendReturnOrderTotalByReturnOrderId(response: HttpResponseBase): Observable<SendReturnOrderTotalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SendReturnOrderTotalDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrderItemGroupsByReturnOrderId(returnOrderId: number): Observable<ReturnOrderItemGroupDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrders/returnOrderItemGroup/{returnOrderId}";
        if (returnOrderId === undefined || returnOrderId === null)
            throw new Error("The parameter 'returnOrderId' must be defined.");
        url_ = url_.replace("{returnOrderId}", encodeURIComponent("" + returnOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderItemGroupsByReturnOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderItemGroupsByReturnOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderItemGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderItemGroupDto[]>;
        }));
    }

    protected processGetReturnOrderItemGroupsByReturnOrderId(response: HttpResponseBase): Observable<ReturnOrderItemGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderItemGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOptionValuesByReturnOrderItemGroupId(returnOrderItemGroupId: number): Observable<ReturnOrderItemGroupProductAttributeOptionValueDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrders/returnOrderItemGroupOption/{returnOrderItemGroupId}";
        if (returnOrderItemGroupId === undefined || returnOrderItemGroupId === null)
            throw new Error("The parameter 'returnOrderItemGroupId' must be defined.");
        url_ = url_.replace("{returnOrderItemGroupId}", encodeURIComponent("" + returnOrderItemGroupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOptionValuesByReturnOrderItemGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptionValuesByReturnOrderItemGroupId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderItemGroupProductAttributeOptionValueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderItemGroupProductAttributeOptionValueDto[]>;
        }));
    }

    protected processGetOptionValuesByReturnOrderItemGroupId(response: HttpResponseBase): Observable<ReturnOrderItemGroupProductAttributeOptionValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderItemGroupProductAttributeOptionValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrderItemDocumentsByReturnOrderItemId(returnOrderItemId: number): Observable<ReturnOrderItemDocumentDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrders/returnOrderItemDocument/{returnOrderItemId}";
        if (returnOrderItemId === undefined || returnOrderItemId === null)
            throw new Error("The parameter 'returnOrderItemId' must be defined.");
        url_ = url_.replace("{returnOrderItemId}", encodeURIComponent("" + returnOrderItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderItemDocumentsByReturnOrderItemId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderItemDocumentsByReturnOrderItemId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderItemDocumentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderItemDocumentDto[]>;
        }));
    }

    protected processGetReturnOrderItemDocumentsByReturnOrderItemId(response: HttpResponseBase): Observable<ReturnOrderItemDocumentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderItemDocumentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrderStatesByReturnOrderId(returnOrderId: number): Observable<ReturnOrderStateBaseDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrders/returnOrderState/{returnOrderId}";
        if (returnOrderId === undefined || returnOrderId === null)
            throw new Error("The parameter 'returnOrderId' must be defined.");
        url_ = url_.replace("{returnOrderId}", encodeURIComponent("" + returnOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderStatesByReturnOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderStatesByReturnOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderStateBaseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderStateBaseDto[]>;
        }));
    }

    protected processGetReturnOrderStatesByReturnOrderId(response: HttpResponseBase): Observable<ReturnOrderStateBaseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderStateBaseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrderById(id: number): Observable<ReturnOrderDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderDto>;
        }));
    }

    protected processGetReturnOrderById(response: HttpResponseBase): Observable<ReturnOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReturnOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCurrentReturnOrderStateByReturnOrderId(returnOrderId: number): Observable<ReturnOrderStateBaseDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/currentReturnOrderState/{returnOrderId}";
        if (returnOrderId === undefined || returnOrderId === null)
            throw new Error("The parameter 'returnOrderId' must be defined.");
        url_ = url_.replace("{returnOrderId}", encodeURIComponent("" + returnOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentReturnOrderStateByReturnOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentReturnOrderStateByReturnOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderStateBaseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderStateBaseDto>;
        }));
    }

    protected processGetCurrentReturnOrderStateByReturnOrderId(response: HttpResponseBase): Observable<ReturnOrderStateBaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReturnOrderStateBaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelAcceptedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/exportExcelAccepted?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelAcceptedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelAcceptedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelAcceptedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelAllConfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/exportExcelAllConfirmed?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelAllConfirmedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelAllConfirmedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelAllConfirmedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelCanceledQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/exportExcelCanceled?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelCanceledQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelCanceledQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelCanceledQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelCompletedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/exportExcelCompleted?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelCompletedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelCompletedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelCompletedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelCostRefundedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/exportExcelCostRefunded?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelCostRefundedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelCostRefundedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelCostRefundedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelReceivedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/exportExcelReceived?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelReceivedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelReceivedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelReceivedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelRegisteredQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/exportExcelRegistered?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelRegisteredQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelRegisteredQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelRegisteredQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelRejectedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/exportExcelRejected?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelRejectedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelRejectedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelRejectedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelSentQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/exportExcelSent?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelSentQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelSentQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelSentQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelSomeConfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/exportExcelSomeConfirmed?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelSomeConfirmedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelSomeConfirmedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelSomeConfirmedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accept(id: number, command: AcceptReturnOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/accept/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccept(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccept(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAccept(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    cancel(id: number, command: CancelReturnOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/cancel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    complete(id: number, command: CompleteReturnOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/complete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processComplete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    confirmAll(id: number, command: ConfirmAllReturnOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/confirmAll/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processConfirmAll(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    confirmSome(id: number, command: ConfirmSomeReturnOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/confirmSome/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmSome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmSome(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processConfirmSome(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    receive(id: number, command: ReceiveReturnOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/receive/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReceive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReceive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processReceive(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refundCost(id: number, command: RefundReturnOrderCostCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/refundCost/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundCost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundCost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRefundCost(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reject(id: number, command: RejectReturnOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/reject/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processReject(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    send(id: number, command: SendReturnOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/send/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateReturnOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReturnOrderTotalDocumentsClient {
    getReturnOrderTotalDocumentsByReturnOrderTotalId(returnOrderTotalId: number | undefined): Observable<ReturnOrderTotalDocumentDto[]>;
    create(command: CreateReturnOrderTotalDocumentCommand): Observable<number>;
    deleteRange(command: DeleteRangeReturnOrderTotalDocumentCommand): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    update(id: number, command: UpdateReturnOrderTotalDocumentCommand): Observable<FileResponse>;
    delete(id: number, command: DeleteReturnOrderTotalDocumentCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReturnOrderTotalDocumentsClient implements IReturnOrderTotalDocumentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getReturnOrderTotalDocumentsByReturnOrderTotalId(returnOrderTotalId: number | undefined): Observable<ReturnOrderTotalDocumentDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotalDocuments?";
        if (returnOrderTotalId === null)
            throw new Error("The parameter 'returnOrderTotalId' cannot be null.");
        else if (returnOrderTotalId !== undefined)
            url_ += "ReturnOrderTotalId=" + encodeURIComponent("" + returnOrderTotalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderTotalDocumentsByReturnOrderTotalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderTotalDocumentsByReturnOrderTotalId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderTotalDocumentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderTotalDocumentDto[]>;
        }));
    }

    protected processGetReturnOrderTotalDocumentsByReturnOrderTotalId(response: HttpResponseBase): Observable<ReturnOrderTotalDocumentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderTotalDocumentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateReturnOrderTotalDocumentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotalDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(command: DeleteRangeReturnOrderTotalDocumentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotalDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotalDocuments/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateReturnOrderTotalDocumentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotalDocuments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number, command: DeleteReturnOrderTotalDocumentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotalDocuments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReturnOrderTotalsClient {
    getReturnOrderTotalsByReturnOrderId(returnOrderId: number | undefined): Observable<ReturnOrderTotalDto[]>;
    create(command: CreateReturnOrderTotalCommand): Observable<number>;
    deleteRange(command: DeleteRangeReturnOrderTotalCommand): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    update(id: number, command: UpdateReturnOrderTotalCommand): Observable<FileResponse>;
    delete(id: number, command: DeleteReturnOrderTotalCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReturnOrderTotalsClient implements IReturnOrderTotalsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getReturnOrderTotalsByReturnOrderId(returnOrderId: number | undefined): Observable<ReturnOrderTotalDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotals?";
        if (returnOrderId === null)
            throw new Error("The parameter 'returnOrderId' cannot be null.");
        else if (returnOrderId !== undefined)
            url_ += "ReturnOrderId=" + encodeURIComponent("" + returnOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderTotalsByReturnOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderTotalsByReturnOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderTotalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderTotalDto[]>;
        }));
    }

    protected processGetReturnOrderTotalsByReturnOrderId(response: HttpResponseBase): Observable<ReturnOrderTotalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderTotalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateReturnOrderTotalCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(command: DeleteRangeReturnOrderTotalCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotals/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateReturnOrderTotalCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number, command: DeleteReturnOrderTotalCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrderTotals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRequestLogsClient {
    getRequestLogsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredRequestLogDto>;
    deleteRangeRequestLog(ids: number[]): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    resendAllCancelOrderRequests(): Observable<boolean>;
    resendCancelOrderRequests(resendCancelOrderRequestsCommand: ResendCancelOrderRequestsCommand): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class RequestLogsClient implements IRequestLogsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getRequestLogsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredRequestLogDto> {
        let url_ = this.baseUrl + "/api/RequestLogs?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestLogsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestLogsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredRequestLogDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredRequestLogDto>;
        }));
    }

    protected processGetRequestLogsWithPagination(response: HttpResponseBase): Observable<FilteredRequestLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredRequestLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeRequestLog(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RequestLogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeRequestLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeRequestLog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeRequestLog(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RequestLogs/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resendAllCancelOrderRequests(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RequestLogs/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResendAllCancelOrderRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendAllCancelOrderRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResendAllCancelOrderRequests(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resendCancelOrderRequests(resendCancelOrderRequestsCommand: ResendCancelOrderRequestsCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RequestLogs/some";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resendCancelOrderRequestsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResendCancelOrderRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendCancelOrderRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResendCancelOrderRequests(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IBadgesClient {
    getAllBadges(): Observable<BadgeDto[]>;
    getBadgeById(id: number): Observable<BadgeDto>;
    update(id: number, command: UpdateBadgeCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getAllBadgesByOptionId(optionId: number): Observable<BadgeDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateBadgeCommand): Observable<number>;
    deleteRangeBadge(ids: number[]): Observable<FileResponse>;
    addRange(command: AddRangeProductAttributeOptionBadgesCommand): Observable<FileResponse>;
    deleteRangeBadgeFromAttributeOption(id: number, ids: number[]): Observable<FileResponse>;
    isUniqueBadgeValue(badgeId: number | undefined, value: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class BadgesClient implements IBadgesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllBadges(): Observable<BadgeDto[]> {
        let url_ = this.baseUrl + "/api/Badges/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBadges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBadges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BadgeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BadgeDto[]>;
        }));
    }

    protected processGetAllBadges(response: HttpResponseBase): Observable<BadgeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BadgeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBadgeById(id: number): Observable<BadgeDto> {
        let url_ = this.baseUrl + "/api/Badges/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBadgeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBadgeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BadgeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BadgeDto>;
        }));
    }

    protected processGetBadgeById(response: HttpResponseBase): Observable<BadgeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BadgeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateBadgeCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Badges/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Badges/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllBadgesByOptionId(optionId: number): Observable<BadgeDto[]> {
        let url_ = this.baseUrl + "/api/Badges/option{optionId}";
        if (optionId === undefined || optionId === null)
            throw new Error("The parameter 'optionId' must be defined.");
        url_ = url_.replace("{optionId}", encodeURIComponent("" + optionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBadgesByOptionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBadgesByOptionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BadgeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BadgeDto[]>;
        }));
    }

    protected processGetAllBadgesByOptionId(response: HttpResponseBase): Observable<BadgeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BadgeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Badges/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateBadgeCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Badges";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeBadge(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Badges";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeBadge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeBadge(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeBadge(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addRange(command: AddRangeProductAttributeOptionBadgesCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Badges/addRange";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAddRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeBadgeFromAttributeOption(id: number, ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Badges/rangeFromOption{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeBadgeFromAttributeOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeBadgeFromAttributeOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeBadgeFromAttributeOption(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueBadgeValue(badgeId: number | undefined, value: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Badges/isUniqueBadgeValue?";
        if (badgeId === null)
            throw new Error("The parameter 'badgeId' cannot be null.");
        else if (badgeId !== undefined)
            url_ += "BadgeId=" + encodeURIComponent("" + badgeId) + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "Value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueBadgeValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueBadgeValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueBadgeValue(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICountingUnitsClient {
    getCountingUnitsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountingUnitDto>;
    create(command: CreateCountingUnitCommand): Observable<number>;
    deleteRangeCountingUnit(ids: number[]): Observable<FileResponse>;
    getAllCountingUnits(): Observable<CountingUnitDto[]>;
    getAllCountingUnitsDropDown(): Observable<AllCountingUnitDropDownDto[]>;
    getCountingUnitById(id: number): Observable<CountingUnitDto>;
    update(id: number, command: UpdateCountingUnitCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueCountingUnitLocalizedName(countingUnitId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueCountingUnitName(countingUnitId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class CountingUnitsClient implements ICountingUnitsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCountingUnitsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountingUnitDto> {
        let url_ = this.baseUrl + "/api/CountingUnits?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountingUnitsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountingUnitsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCountingUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCountingUnitDto>;
        }));
    }

    protected processGetCountingUnitsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCountingUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCountingUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCountingUnitCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CountingUnits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeCountingUnit(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CountingUnits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeCountingUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeCountingUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeCountingUnit(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCountingUnits(): Observable<CountingUnitDto[]> {
        let url_ = this.baseUrl + "/api/CountingUnits/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountingUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountingUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountingUnitDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountingUnitDto[]>;
        }));
    }

    protected processGetAllCountingUnits(response: HttpResponseBase): Observable<CountingUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountingUnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCountingUnitsDropDown(): Observable<AllCountingUnitDropDownDto[]> {
        let url_ = this.baseUrl + "/api/CountingUnits/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountingUnitsDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountingUnitsDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllCountingUnitDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllCountingUnitDropDownDto[]>;
        }));
    }

    protected processGetAllCountingUnitsDropDown(response: HttpResponseBase): Observable<AllCountingUnitDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllCountingUnitDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCountingUnitById(id: number): Observable<CountingUnitDto> {
        let url_ = this.baseUrl + "/api/CountingUnits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountingUnitById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountingUnitById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountingUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountingUnitDto>;
        }));
    }

    protected processGetCountingUnitById(response: HttpResponseBase): Observable<CountingUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountingUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCountingUnitCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CountingUnits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CountingUnits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CountingUnits/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueCountingUnitLocalizedName(countingUnitId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/CountingUnits/isUniqueLocalizedName?";
        if (countingUnitId === null)
            throw new Error("The parameter 'countingUnitId' cannot be null.");
        else if (countingUnitId !== undefined)
            url_ += "CountingUnitId=" + encodeURIComponent("" + countingUnitId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueCountingUnitLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueCountingUnitLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueCountingUnitLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueCountingUnitName(countingUnitId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/CountingUnits/isUniqueName?";
        if (countingUnitId === null)
            throw new Error("The parameter 'countingUnitId' cannot be null.");
        else if (countingUnitId !== undefined)
            url_ += "CountingUnitId=" + encodeURIComponent("" + countingUnitId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueCountingUnitName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueCountingUnitName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueCountingUnitName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICountingUnitTypesClient {
    getCountingUnitTypesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountingUnitTypeDto>;
    create(command: CreateCountingUnitTypeCommand): Observable<number>;
    deleteRangeCountingUnitType(ids: number[]): Observable<FileResponse>;
    getAllCountingUnitTypes(): Observable<CountingUnitTypeDto[]>;
    getCountingUnitTypeById(id: number): Observable<CountingUnitTypeDto>;
    update(id: number, command: UpdateCountingUnitTypeCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueCountingUnitTypeLocalizedName(countingUnitTypeId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueCountingUnitTypeName(countingUnitTypeId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class CountingUnitTypesClient implements ICountingUnitTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCountingUnitTypesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountingUnitTypeDto> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountingUnitTypesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountingUnitTypesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCountingUnitTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCountingUnitTypeDto>;
        }));
    }

    protected processGetCountingUnitTypesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCountingUnitTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCountingUnitTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCountingUnitTypeCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeCountingUnitType(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeCountingUnitType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeCountingUnitType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeCountingUnitType(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCountingUnitTypes(): Observable<CountingUnitTypeDto[]> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountingUnitTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountingUnitTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountingUnitTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountingUnitTypeDto[]>;
        }));
    }

    protected processGetAllCountingUnitTypes(response: HttpResponseBase): Observable<CountingUnitTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountingUnitTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCountingUnitTypeById(id: number): Observable<CountingUnitTypeDto> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountingUnitTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountingUnitTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountingUnitTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountingUnitTypeDto>;
        }));
    }

    protected processGetCountingUnitTypeById(response: HttpResponseBase): Observable<CountingUnitTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountingUnitTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCountingUnitTypeCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueCountingUnitTypeLocalizedName(countingUnitTypeId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes/isUniqueLocalizedName?";
        if (countingUnitTypeId === null)
            throw new Error("The parameter 'countingUnitTypeId' cannot be null.");
        else if (countingUnitTypeId !== undefined)
            url_ += "CountingUnitTypeId=" + encodeURIComponent("" + countingUnitTypeId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueCountingUnitTypeLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueCountingUnitTypeLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueCountingUnitTypeLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueCountingUnitTypeName(countingUnitTypeId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes/isUniqueName?";
        if (countingUnitTypeId === null)
            throw new Error("The parameter 'countingUnitTypeId' cannot be null.");
        else if (countingUnitTypeId !== undefined)
            url_ += "CountingUnitTypeId=" + encodeURIComponent("" + countingUnitTypeId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueCountingUnitTypeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueCountingUnitTypeName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueCountingUnitTypeName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPricesClient {
    create(command: CreatePriceCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
    update(id: number, command: UpdatePriceCommand): Observable<FileResponse>;
    getAllProductPricesByOptionId(optionId: number): Observable<PriceDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class PricesClient implements IPricesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(command: CreatePriceCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Prices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Prices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdatePriceCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Prices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductPricesByOptionId(optionId: number): Observable<PriceDto[]> {
        let url_ = this.baseUrl + "/api/Prices/option{optionId}";
        if (optionId === undefined || optionId === null)
            throw new Error("The parameter 'optionId' must be defined.");
        url_ = url_.replace("{optionId}", encodeURIComponent("" + optionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductPricesByOptionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductPricesByOptionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceDto[]>;
        }));
    }

    protected processGetAllProductPricesByOptionId(response: HttpResponseBase): Observable<PriceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PriceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Prices/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductDisplayVariantsClient {
    getAllProductDisplayVariants(): Observable<ProductDisplayVariantDto[]>;
    getProductDisplayVariantById(id: number): Observable<ProductDisplayVariantDto>;
    update(id: number, command: UpdateVariantCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getAllProductDisplayVariantsByProductId(productId: number): Observable<ProductDisplayVariantDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateVariantCommand): Observable<number>;
    deleteRangeProductDisplayVariant(ids: number[]): Observable<FileResponse>;
    isUniqueProductDisplayVariantName(variantId: number | undefined, productId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductDisplayVariantsClient implements IProductDisplayVariantsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductDisplayVariants(): Observable<ProductDisplayVariantDto[]> {
        let url_ = this.baseUrl + "/api/ProductDisplayVariants/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductDisplayVariants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductDisplayVariants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDisplayVariantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDisplayVariantDto[]>;
        }));
    }

    protected processGetAllProductDisplayVariants(response: HttpResponseBase): Observable<ProductDisplayVariantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDisplayVariantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductDisplayVariantById(id: number): Observable<ProductDisplayVariantDto> {
        let url_ = this.baseUrl + "/api/ProductDisplayVariants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductDisplayVariantById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductDisplayVariantById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDisplayVariantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDisplayVariantDto>;
        }));
    }

    protected processGetProductDisplayVariantById(response: HttpResponseBase): Observable<ProductDisplayVariantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDisplayVariantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateVariantCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductDisplayVariants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductDisplayVariants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductDisplayVariantsByProductId(productId: number): Observable<ProductDisplayVariantDto[]> {
        let url_ = this.baseUrl + "/api/ProductDisplayVariants/product{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductDisplayVariantsByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductDisplayVariantsByProductId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDisplayVariantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDisplayVariantDto[]>;
        }));
    }

    protected processGetAllProductDisplayVariantsByProductId(response: HttpResponseBase): Observable<ProductDisplayVariantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDisplayVariantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductDisplayVariants/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateVariantCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductDisplayVariants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeProductDisplayVariant(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductDisplayVariants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeProductDisplayVariant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeProductDisplayVariant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeProductDisplayVariant(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductDisplayVariantName(variantId: number | undefined, productId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProductDisplayVariants/isUniqueProductDisplayVariantName?";
        if (variantId === null)
            throw new Error("The parameter 'variantId' cannot be null.");
        else if (variantId !== undefined)
            url_ += "VariantId=" + encodeURIComponent("" + variantId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductDisplayVariantName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductDisplayVariantName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductDisplayVariantName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductImagesClient {
    getAllProductImages(): Observable<ProductImagesDto[]>;
    create(command: CreateProductImageCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
    update(urlId: number, command: UpdateProductImageCommand): Observable<FileResponse>;
    getProductImagesByProductId(productId: number): Observable<ProductImagesDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductImagesClient implements IProductImagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductImages(): Observable<ProductImagesDto[]> {
        let url_ = this.baseUrl + "/api/ProductImages/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductImagesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductImagesDto[]>;
        }));
    }

    protected processGetAllProductImages(response: HttpResponseBase): Observable<ProductImagesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductImagesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductImageCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductImages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductImages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateProductImageCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductImages/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductImagesByProductId(productId: number): Observable<ProductImagesDto[]> {
        let url_ = this.baseUrl + "/api/ProductImages/product{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductImagesByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductImagesByProductId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductImagesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductImagesDto[]>;
        }));
    }

    protected processGetProductImagesByProductId(response: HttpResponseBase): Observable<ProductImagesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductImagesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductKindsClient {
    create(command: CreateProductKindsCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
    getAllProductKindsByProductId(productId: number): Observable<AllProductKindByProductIdDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    addRange(command: AddRangeProductKindsCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductKindsClient implements IProductKindsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(command: CreateProductKindsCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductKinds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductKinds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductKindsByProductId(productId: number): Observable<AllProductKindByProductIdDto[]> {
        let url_ = this.baseUrl + "/api/ProductKinds/product{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductKindsByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductKindsByProductId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductKindByProductIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductKindByProductIdDto[]>;
        }));
    }

    protected processGetAllProductKindsByProductId(response: HttpResponseBase): Observable<AllProductKindByProductIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductKindByProductIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductKinds/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addRange(command: AddRangeProductKindsCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductKinds/addRange";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAddRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductsClient {
    getProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfBackOfficeProductDto>;
    create(command: CreateProductCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
    getAllProducts(command: GetAllProductsQuery): Observable<ProductDto[]>;
    getAllBackOfficeProducts(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredProductDto>;
    getProductsByKindId(command: GetProductsByKindIdQuery): Observable<ProductDto[]>;
    getProductsByBrandId(command: GetProductsByBrandIdQuery): Observable<ProductDto[]>;
    getProductById(command: GetProductByIdQuery): Observable<ProductDto>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    update(id: number, command: UpdateProductCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    isUniqueProductLocalizedName(productId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueProductName(productId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductsClient implements IProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfBackOfficeProductDto> {
        let url_ = this.baseUrl + "/api/Products?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfBackOfficeProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfBackOfficeProductDto>;
        }));
    }

    protected processGetProductsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfBackOfficeProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfBackOfficeProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProducts(command: GetAllProductsQuery): Observable<ProductDto[]> {
        let url_ = this.baseUrl + "/api/Products/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto[]>;
        }));
    }

    protected processGetAllProducts(response: HttpResponseBase): Observable<ProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllBackOfficeProducts(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredProductDto> {
        let url_ = this.baseUrl + "/api/Products/allProduct?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBackOfficeProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBackOfficeProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredProductDto>;
        }));
    }

    protected processGetAllBackOfficeProducts(response: HttpResponseBase): Observable<FilteredProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsByKindId(command: GetProductsByKindIdQuery): Observable<ProductDto[]> {
        let url_ = this.baseUrl + "/api/Products/kind";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByKindId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByKindId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto[]>;
        }));
    }

    protected processGetProductsByKindId(response: HttpResponseBase): Observable<ProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsByBrandId(command: GetProductsByBrandIdQuery): Observable<ProductDto[]> {
        let url_ = this.baseUrl + "/api/Products/brand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByBrandId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByBrandId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto[]>;
        }));
    }

    protected processGetProductsByBrandId(response: HttpResponseBase): Observable<ProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductById(command: GetProductByIdQuery): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/Products/byId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processGetProductById(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductLocalizedName(productId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Products/isUniqueLocalizedName?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductName(productId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Products/isUniqueName?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductStatusesClient {
    getProductStatusesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductStatusDto>;
    create(command: CreateProductStatusCommand): Observable<number>;
    deleteRangeProductStatus(ids: number[]): Observable<FileResponse>;
    getAllProductStatuses(): Observable<ProductStatusDto[]>;
    getAllProductStatusesDropDown(): Observable<AllProductStatusDropDownDto[]>;
    getProductStatusById(id: number): Observable<ProductStatusDto>;
    update(id: number, command: UpdateProductStatusCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueProductStatusLocalizedName(productStatusId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueProductStatusName(productStatusId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductStatusesClient implements IProductStatusesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getProductStatusesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductStatusDto> {
        let url_ = this.baseUrl + "/api/ProductStatuses?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductStatusesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductStatusesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductStatusDto>;
        }));
    }

    protected processGetProductStatusesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProductStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductStatusCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductStatuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeProductStatus(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductStatuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeProductStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeProductStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeProductStatus(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductStatuses(): Observable<ProductStatusDto[]> {
        let url_ = this.baseUrl + "/api/ProductStatuses/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductStatusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductStatusDto[]>;
        }));
    }

    protected processGetAllProductStatuses(response: HttpResponseBase): Observable<ProductStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductStatusesDropDown(): Observable<AllProductStatusDropDownDto[]> {
        let url_ = this.baseUrl + "/api/ProductStatuses/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductStatusesDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductStatusesDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductStatusDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductStatusDropDownDto[]>;
        }));
    }

    protected processGetAllProductStatusesDropDown(response: HttpResponseBase): Observable<AllProductStatusDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductStatusDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductStatusById(id: number): Observable<ProductStatusDto> {
        let url_ = this.baseUrl + "/api/ProductStatuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductStatusById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductStatusById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductStatusDto>;
        }));
    }

    protected processGetProductStatusById(response: HttpResponseBase): Observable<ProductStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductStatusCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductStatuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductStatuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductStatuses/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductStatusLocalizedName(productStatusId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProductStatuses/isUniqueLocalizedName?";
        if (productStatusId === null)
            throw new Error("The parameter 'productStatusId' cannot be null.");
        else if (productStatusId !== undefined)
            url_ += "ProductStatusId=" + encodeURIComponent("" + productStatusId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductStatusLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductStatusLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductStatusLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductStatusName(productStatusId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProductStatuses/isUniqueName?";
        if (productStatusId === null)
            throw new Error("The parameter 'productStatusId' cannot be null.");
        else if (productStatusId !== undefined)
            url_ += "ProductStatusId=" + encodeURIComponent("" + productStatusId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductStatusName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductStatusName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductStatusName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductTypesClient {
    getProductTypesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductTypeDto>;
    create(command: CreateProductTypeCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
    getAllProductTypes(): Observable<ProductTypeDto[]>;
    getAllProductTypesDropDown(): Observable<AllProductTypeDropDownDto[]>;
    getProductTypeById(id: number): Observable<ProductTypeDto>;
    update(id: number, command: UpdateProductTypeCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueProductTypeLocalizedName(productTypeId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueProductTypeName(productTypeId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductTypesClient implements IProductTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getProductTypesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductTypeDto> {
        let url_ = this.baseUrl + "/api/ProductTypes?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTypesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTypesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductTypeDto>;
        }));
    }

    protected processGetProductTypesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProductTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductTypeCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductTypes(): Observable<ProductTypeDto[]> {
        let url_ = this.baseUrl + "/api/ProductTypes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTypeDto[]>;
        }));
    }

    protected processGetAllProductTypes(response: HttpResponseBase): Observable<ProductTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductTypesDropDown(): Observable<AllProductTypeDropDownDto[]> {
        let url_ = this.baseUrl + "/api/ProductTypes/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductTypesDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductTypesDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductTypeDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductTypeDropDownDto[]>;
        }));
    }

    protected processGetAllProductTypesDropDown(response: HttpResponseBase): Observable<AllProductTypeDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductTypeDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductTypeById(id: number): Observable<ProductTypeDto> {
        let url_ = this.baseUrl + "/api/ProductTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTypeDto>;
        }));
    }

    protected processGetProductTypeById(response: HttpResponseBase): Observable<ProductTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductTypeCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypes/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductTypeLocalizedName(productTypeId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProductTypes/isUniqueLocalizedName?";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductTypeLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductTypeLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductTypeLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductTypeName(productTypeId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProductTypes/isUniqueName?";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductTypeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductTypeName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductTypeName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProvidersClient {
    getProvidersWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredProviderDto>;
    create(command: CreateProviderCommand): Observable<number>;
    deleteRangeProvider(ids: number[]): Observable<FileResponse>;
    getAllProvidersDropDown(): Observable<AllProviderDropDownDto[]>;
    getAllProviders(): Observable<ProviderDto[]>;
    getProviderById(id: number): Observable<ProviderDto>;
    update(id: number, command: UpdateProviderCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueProviderLocalizedName(providerId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueProviderName(providerId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ProvidersClient implements IProvidersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getProvidersWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredProviderDto> {
        let url_ = this.baseUrl + "/api/Providers?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProvidersWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProvidersWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredProviderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredProviderDto>;
        }));
    }

    protected processGetProvidersWithPagination(response: HttpResponseBase): Observable<FilteredProviderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredProviderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProviderCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Providers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeProvider(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Providers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeProvider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeProvider(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeProvider(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProvidersDropDown(): Observable<AllProviderDropDownDto[]> {
        let url_ = this.baseUrl + "/api/Providers/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProvidersDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProvidersDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProviderDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProviderDropDownDto[]>;
        }));
    }

    protected processGetAllProvidersDropDown(response: HttpResponseBase): Observable<AllProviderDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProviderDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProviders(): Observable<ProviderDto[]> {
        let url_ = this.baseUrl + "/api/Providers/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProviderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProviderDto[]>;
        }));
    }

    protected processGetAllProviders(response: HttpResponseBase): Observable<ProviderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProviderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProviderById(id: number): Observable<ProviderDto> {
        let url_ = this.baseUrl + "/api/Providers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProviderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProviderById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProviderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProviderDto>;
        }));
    }

    protected processGetProviderById(response: HttpResponseBase): Observable<ProviderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProviderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProviderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Providers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Providers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Providers/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProviderLocalizedName(providerId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Providers/isUniqueLocalizedName?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "ProviderId=" + encodeURIComponent("" + providerId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProviderLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProviderLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProviderLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProviderName(providerId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Providers/isUniqueName?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "ProviderId=" + encodeURIComponent("" + providerId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProviderName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProviderName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProviderName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReviewsClient {
    getAllReviews(): Observable<ReviewDto[]>;
    getReviewsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReviewDto>;
    deleteRangeReview(ids: number[]): Observable<FileResponse>;
    getReviewsByCustomerId(customerId: string): Observable<ReviewDto[]>;
    getReviewById(id: number): Observable<ReviewDto>;
    update(id: number, command: UpdateReviewCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReviewsClient implements IReviewsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllReviews(): Observable<ReviewDto[]> {
        let url_ = this.baseUrl + "/api/Reviews/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReviews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReviews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDto[]>;
        }));
    }

    protected processGetAllReviews(response: HttpResponseBase): Observable<ReviewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReviewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReviewsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredReviewDto> {
        let url_ = this.baseUrl + "/api/Reviews?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviewsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviewsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredReviewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredReviewDto>;
        }));
    }

    protected processGetReviewsWithPagination(response: HttpResponseBase): Observable<FilteredReviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredReviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeReview(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Reviews";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeReview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeReview(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReviewsByCustomerId(customerId: string): Observable<ReviewDto[]> {
        let url_ = this.baseUrl + "/api/Reviews/customer{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviewsByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviewsByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDto[]>;
        }));
    }

    protected processGetReviewsByCustomerId(response: HttpResponseBase): Observable<ReviewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReviewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReviewById(id: number): Observable<ReviewDto> {
        let url_ = this.baseUrl + "/api/Reviews/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviewById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviewById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDto>;
        }));
    }

    protected processGetReviewById(response: HttpResponseBase): Observable<ReviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateReviewCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Reviews/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Reviews/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Reviews/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISyncDataClient {
    syncPrices(): Observable<boolean>;
    syncCountsAndPrices(): Observable<boolean>;
    syncCounts(): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class SyncDataClient implements ISyncDataClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    syncPrices(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SyncData/prices";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSyncPrices(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    syncCountsAndPrices(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SyncData/countsAndPrices";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncCountsAndPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncCountsAndPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSyncCountsAndPrices(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    syncCounts(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SyncData/counts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncCounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncCounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSyncCounts(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITagsClient {
    getAllTags(): Observable<TagDto[]>;
    getTagsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredTagDto>;
    create(command: CreateTagCommand): Observable<number>;
    deleteRangeTag(ids: number[]): Observable<FileResponse>;
    getTagById(id: number): Observable<TagDto>;
    update(id: number, command: UpdateTagCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueTagEnTitleValidator(tagId: number | undefined, enTitle: string | undefined): Observable<boolean>;
    isUniqueTagFaTitleValidator(tagId: number | undefined, faTitle: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class TagsClient implements ITagsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllTags(): Observable<TagDto[]> {
        let url_ = this.baseUrl + "/api/Tags/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDto[]>;
        }));
    }

    protected processGetAllTags(response: HttpResponseBase): Observable<TagDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TagDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTagsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredTagDto> {
        let url_ = this.baseUrl + "/api/Tags?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredTagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredTagDto>;
        }));
    }

    protected processGetTagsWithPagination(response: HttpResponseBase): Observable<FilteredTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTagCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeTag(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeTag(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTagById(id: number): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/Tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDto>;
        }));
    }

    protected processGetTagById(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateTagCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Tags/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueTagEnTitleValidator(tagId: number | undefined, enTitle: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tags/isUniqueTagEnTitle?";
        if (tagId === null)
            throw new Error("The parameter 'tagId' cannot be null.");
        else if (tagId !== undefined)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        if (enTitle === null)
            throw new Error("The parameter 'enTitle' cannot be null.");
        else if (enTitle !== undefined)
            url_ += "EnTitle=" + encodeURIComponent("" + enTitle) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueTagEnTitleValidator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueTagEnTitleValidator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueTagEnTitleValidator(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueTagFaTitleValidator(tagId: number | undefined, faTitle: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tags/isUniqueTagFaTitle?";
        if (tagId === null)
            throw new Error("The parameter 'tagId' cannot be null.");
        else if (tagId !== undefined)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        if (faTitle === null)
            throw new Error("The parameter 'faTitle' cannot be null.");
        else if (faTitle !== undefined)
            url_ += "FaTitle=" + encodeURIComponent("" + faTitle) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueTagFaTitleValidator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueTagFaTitleValidator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueTagFaTitleValidator(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductAttributeOptionRolesClient {
    getProductAttributeOptionRolesWithPagination(productAttributeOptionId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductAttributeOptionRoleDto>;
    create(command: CreateProductAttributeOptionRoleCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
    getAllProductAttributeOptionRoles(): Observable<ProductAttributeOptionRoleDto[]>;
    getAllProductAttributeOptionRoleByOptionId(optionId: number): Observable<ProductAttributeOptionRoleDto[]>;
    getProductAttributeOptionRoleById(id: number): Observable<ProductAttributeOptionRoleDto>;
    update(id: number, command: UpdateProductAttributeOptionRoleCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductAttributeOptionRolesClient implements IProductAttributeOptionRolesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getProductAttributeOptionRolesWithPagination(productAttributeOptionId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductAttributeOptionRoleDto> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionRoles?";
        if (productAttributeOptionId === null)
            throw new Error("The parameter 'productAttributeOptionId' cannot be null.");
        else if (productAttributeOptionId !== undefined)
            url_ += "ProductAttributeOptionId=" + encodeURIComponent("" + productAttributeOptionId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductAttributeOptionRolesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductAttributeOptionRolesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductAttributeOptionRoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductAttributeOptionRoleDto>;
        }));
    }

    protected processGetProductAttributeOptionRolesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProductAttributeOptionRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductAttributeOptionRoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductAttributeOptionRoleCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductAttributeOptionRoles(): Observable<ProductAttributeOptionRoleDto[]> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionRoles/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductAttributeOptionRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductAttributeOptionRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeOptionRoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeOptionRoleDto[]>;
        }));
    }

    protected processGetAllProductAttributeOptionRoles(response: HttpResponseBase): Observable<ProductAttributeOptionRoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductAttributeOptionRoleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductAttributeOptionRoleByOptionId(optionId: number): Observable<ProductAttributeOptionRoleDto[]> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionRoles/option{optionId}";
        if (optionId === undefined || optionId === null)
            throw new Error("The parameter 'optionId' must be defined.");
        url_ = url_.replace("{optionId}", encodeURIComponent("" + optionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductAttributeOptionRoleByOptionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductAttributeOptionRoleByOptionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeOptionRoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeOptionRoleDto[]>;
        }));
    }

    protected processGetAllProductAttributeOptionRoleByOptionId(response: HttpResponseBase): Observable<ProductAttributeOptionRoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductAttributeOptionRoleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductAttributeOptionRoleById(id: number): Observable<ProductAttributeOptionRoleDto> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductAttributeOptionRoleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductAttributeOptionRoleById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeOptionRoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeOptionRoleDto>;
        }));
    }

    protected processGetProductAttributeOptionRoleById(response: HttpResponseBase): Observable<ProductAttributeOptionRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductAttributeOptionRoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductAttributeOptionRoleCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionRoles/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductAttributeOptionsClient {
    create(command: CreateProductAttributeOptionCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
    update(id: number, command: UpdateProductAttributeOptionCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getAllProductAttributeOptionByProductId(productId: number): Observable<ProductAttributeOptionDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductAttributeOptionsClient implements IProductAttributeOptionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(command: CreateProductAttributeOptionCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductAttributeOptionCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductAttributeOptionByProductId(productId: number): Observable<ProductAttributeOptionDto[]> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptions/product{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductAttributeOptionByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductAttributeOptionByProductId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeOptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeOptionDto[]>;
        }));
    }

    protected processGetAllProductAttributeOptionByProductId(response: HttpResponseBase): Observable<ProductAttributeOptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductAttributeOptionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptions/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductAttributeOptionValuesClient {
    getAllProductAttributeOptionValueByOptionId(optionId: number): Observable<ProductAttributeOptionValueDto2[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateProductAttributeOptionValueCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
    update(id: number, command: UpdateProductAttributeOptionValueCommand2): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductAttributeOptionValuesClient implements IProductAttributeOptionValuesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductAttributeOptionValueByOptionId(optionId: number): Observable<ProductAttributeOptionValueDto2[]> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionValues/option{optionId}";
        if (optionId === undefined || optionId === null)
            throw new Error("The parameter 'optionId' must be defined.");
        url_ = url_.replace("{optionId}", encodeURIComponent("" + optionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductAttributeOptionValueByOptionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductAttributeOptionValueByOptionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeOptionValueDto2[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeOptionValueDto2[]>;
        }));
    }

    protected processGetAllProductAttributeOptionValueByOptionId(response: HttpResponseBase): Observable<ProductAttributeOptionValueDto2[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductAttributeOptionValueDto2.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionValues/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductAttributeOptionValueCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductAttributeOptionValueCommand2): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionValues/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeOptionValues/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductOptionColorsClient {
    getAllProductOptionColors(): Observable<ProductOptionColorDto[]>;
    getAllProductOptionColorsDropDown(): Observable<AllProductOptionColorDropDownDto[]>;
    getProductOptionColorById(id: number): Observable<ProductOptionColorDto>;
    update(id: number, command: UpdateProductOptionColorCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateProductOptionColorCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductOptionColorsClient implements IProductOptionColorsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductOptionColors(): Observable<ProductOptionColorDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionColors/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionColors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionColors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductOptionColorDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductOptionColorDto[]>;
        }));
    }

    protected processGetAllProductOptionColors(response: HttpResponseBase): Observable<ProductOptionColorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductOptionColorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductOptionColorsDropDown(): Observable<AllProductOptionColorDropDownDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionColors/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionColorsDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionColorsDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductOptionColorDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductOptionColorDropDownDto[]>;
        }));
    }

    protected processGetAllProductOptionColorsDropDown(response: HttpResponseBase): Observable<AllProductOptionColorDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductOptionColorDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductOptionColorById(id: number): Observable<ProductOptionColorDto> {
        let url_ = this.baseUrl + "/api/ProductOptionColors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductOptionColorById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductOptionColorById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductOptionColorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductOptionColorDto>;
        }));
    }

    protected processGetProductOptionColorById(response: HttpResponseBase): Observable<ProductOptionColorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductOptionColorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductOptionColorCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionColors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionColors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionColors/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductOptionColorCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductOptionColors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionColors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductOptionMaterialsClient {
    getAllProductOptionMaterials(): Observable<ProductOptionMaterialDto[]>;
    getAllProductOptionMaterialsDropDown(): Observable<AllProductOptionMaterialDropDownDto[]>;
    getProductOptionMaterialById(id: number): Observable<ProductOptionMaterialDto>;
    update(id: number, command: UpdateProductOptionMaterialCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateProductOptionMaterialCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductOptionMaterialsClient implements IProductOptionMaterialsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductOptionMaterials(): Observable<ProductOptionMaterialDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionMaterials/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionMaterials(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductOptionMaterialDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductOptionMaterialDto[]>;
        }));
    }

    protected processGetAllProductOptionMaterials(response: HttpResponseBase): Observable<ProductOptionMaterialDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductOptionMaterialDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductOptionMaterialsDropDown(): Observable<AllProductOptionMaterialDropDownDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionMaterials/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionMaterialsDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionMaterialsDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductOptionMaterialDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductOptionMaterialDropDownDto[]>;
        }));
    }

    protected processGetAllProductOptionMaterialsDropDown(response: HttpResponseBase): Observable<AllProductOptionMaterialDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductOptionMaterialDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductOptionMaterialById(id: number): Observable<ProductOptionMaterialDto> {
        let url_ = this.baseUrl + "/api/ProductOptionMaterials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductOptionMaterialById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductOptionMaterialById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductOptionMaterialDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductOptionMaterialDto>;
        }));
    }

    protected processGetProductOptionMaterialById(response: HttpResponseBase): Observable<ProductOptionMaterialDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductOptionMaterialDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductOptionMaterialCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionMaterials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionMaterials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionMaterials/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductOptionMaterialCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductOptionMaterials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionMaterials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductOptionValueColorsClient {
    getAllProductOptionValueColors(): Observable<ProductOptionValueColorDto[]>;
    getAllProductOptionValueByColorId(colorId: number): Observable<ProductOptionValueColorDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateProductOptionValueColorCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
    update(id: number, command: UpdateProductOptionValueColorCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductOptionValueColorsClient implements IProductOptionValueColorsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductOptionValueColors(): Observable<ProductOptionValueColorDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionValueColors/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionValueColors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionValueColors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductOptionValueColorDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductOptionValueColorDto[]>;
        }));
    }

    protected processGetAllProductOptionValueColors(response: HttpResponseBase): Observable<ProductOptionValueColorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductOptionValueColorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductOptionValueByColorId(colorId: number): Observable<ProductOptionValueColorDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionValueColors/optionColors{colorId}";
        if (colorId === undefined || colorId === null)
            throw new Error("The parameter 'colorId' must be defined.");
        url_ = url_.replace("{colorId}", encodeURIComponent("" + colorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionValueByColorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionValueByColorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductOptionValueColorDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductOptionValueColorDto[]>;
        }));
    }

    protected processGetAllProductOptionValueByColorId(response: HttpResponseBase): Observable<ProductOptionValueColorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductOptionValueColorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionValueColors/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductOptionValueColorCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductOptionValueColors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionValueColors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductOptionValueColorCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionValueColors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionValueColors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductOptionValueMaterialsClient {
    getAllProductOptionValueMaterials(): Observable<ProductOptionValueMaterialDto[]>;
    getAllProductOptionValueByMaterialId(materialId: number): Observable<ProductOptionValueMaterialDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    update(id: number, command: UpdateProductOptionValueMaterialCommand): Observable<FileResponse>;
    create(command: CreateProductOptionValueMaterialCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductOptionValueMaterialsClient implements IProductOptionValueMaterialsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductOptionValueMaterials(): Observable<ProductOptionValueMaterialDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionValueMaterials/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionValueMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionValueMaterials(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductOptionValueMaterialDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductOptionValueMaterialDto[]>;
        }));
    }

    protected processGetAllProductOptionValueMaterials(response: HttpResponseBase): Observable<ProductOptionValueMaterialDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductOptionValueMaterialDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductOptionValueByMaterialId(materialId: number): Observable<ProductOptionValueMaterialDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionValueMaterials/optionMaterials{materialId}";
        if (materialId === undefined || materialId === null)
            throw new Error("The parameter 'materialId' must be defined.");
        url_ = url_.replace("{materialId}", encodeURIComponent("" + materialId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionValueByMaterialId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionValueByMaterialId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductOptionValueMaterialDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductOptionValueMaterialDto[]>;
        }));
    }

    protected processGetAllProductOptionValueByMaterialId(response: HttpResponseBase): Observable<ProductOptionValueMaterialDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductOptionValueMaterialDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionValueMaterials/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductOptionValueMaterialCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionValueMaterials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductOptionValueMaterialCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductOptionValueMaterials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductOptionValueMaterials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductAttributesClient {
    getAllProductAttributes(): Observable<ProductAttributeDto[]>;
    getProductAttributeById(id: number): Observable<ProductAttributeDto>;
    update(id: number, command: UpdateProductAttributeCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getAllProductAttributesByProductId(productId: number): Observable<ProductAttributeDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateProductAttributeCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductAttributesClient implements IProductAttributesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductAttributes(): Observable<ProductAttributeDto[]> {
        let url_ = this.baseUrl + "/api/ProductAttributes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductAttributes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductAttributes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeDto[]>;
        }));
    }

    protected processGetAllProductAttributes(response: HttpResponseBase): Observable<ProductAttributeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductAttributeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductAttributeById(id: number): Observable<ProductAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductAttributes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductAttributeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductAttributeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeDto>;
        }));
    }

    protected processGetProductAttributeById(response: HttpResponseBase): Observable<ProductAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductAttributeCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductAttributesByProductId(productId: number): Observable<ProductAttributeDto[]> {
        let url_ = this.baseUrl + "/api/ProductAttributes/product{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductAttributesByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductAttributesByProductId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeDto[]>;
        }));
    }

    protected processGetAllProductAttributesByProductId(response: HttpResponseBase): Observable<ProductAttributeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductAttributeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributes/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductAttributeCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductAttributes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductAttributeTypesClient {
    getAllProductAttributeTypes(): Observable<ProductAttributeTypeDto[]>;
    getAllProductAttributeTypesDropDown(): Observable<AllProductAttributeTypeDropDownDto[]>;
    getAllProductAttributeTypesGroup(): Observable<ProductTypeAttributeGroupDto[]>;
    getAllProductTypeAttributeGroupAttributeByGroupId(groupId: number): Observable<ProductTypeAttributeGroupAttributeDto[]>;
    getProductAttributeTypeById(id: number): Observable<ProductAttributeTypeDto>;
    update(id: number, command: UpdateProductAttributeTypeCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateProductAttributeTypeCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
    addProductAttributeGroups(id: number, command: AddProductAttributeGroupsCommand): Observable<FileResponse>;
    removeProductAttributeGroups(id: number, command: RemoveProductAttributeGroupsCommand): Observable<FileResponse>;
    isUniqueProductAttributeTypeName(productAttributeTypeId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductAttributeTypesClient implements IProductAttributeTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductAttributeTypes(): Observable<ProductAttributeTypeDto[]> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductAttributeTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductAttributeTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeTypeDto[]>;
        }));
    }

    protected processGetAllProductAttributeTypes(response: HttpResponseBase): Observable<ProductAttributeTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductAttributeTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductAttributeTypesDropDown(): Observable<AllProductAttributeTypeDropDownDto[]> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductAttributeTypesDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductAttributeTypesDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductAttributeTypeDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductAttributeTypeDropDownDto[]>;
        }));
    }

    protected processGetAllProductAttributeTypesDropDown(response: HttpResponseBase): Observable<AllProductAttributeTypeDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductAttributeTypeDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductAttributeTypesGroup(): Observable<ProductTypeAttributeGroupDto[]> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/allGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductAttributeTypesGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductAttributeTypesGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTypeAttributeGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTypeAttributeGroupDto[]>;
        }));
    }

    protected processGetAllProductAttributeTypesGroup(response: HttpResponseBase): Observable<ProductTypeAttributeGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductTypeAttributeGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductTypeAttributeGroupAttributeByGroupId(groupId: number): Observable<ProductTypeAttributeGroupAttributeDto[]> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/group{groupId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductTypeAttributeGroupAttributeByGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductTypeAttributeGroupAttributeByGroupId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTypeAttributeGroupAttributeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTypeAttributeGroupAttributeDto[]>;
        }));
    }

    protected processGetAllProductTypeAttributeGroupAttributeByGroupId(response: HttpResponseBase): Observable<ProductTypeAttributeGroupAttributeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductTypeAttributeGroupAttributeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductAttributeTypeById(id: number): Observable<ProductAttributeTypeDto> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductAttributeTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductAttributeTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeTypeDto>;
        }));
    }

    protected processGetProductAttributeTypeById(response: HttpResponseBase): Observable<ProductAttributeTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductAttributeTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductAttributeTypeCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductAttributeTypeCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addProductAttributeGroups(id: number, command: AddProductAttributeGroupsCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/addProductAttributeGroups{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddProductAttributeGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddProductAttributeGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAddProductAttributeGroups(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeProductAttributeGroups(id: number, command: RemoveProductAttributeGroupsCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/removeProductAttributeGroups{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProductAttributeGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProductAttributeGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveProductAttributeGroups(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductAttributeTypeName(productAttributeTypeId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/isUniqueName?";
        if (productAttributeTypeId === null)
            throw new Error("The parameter 'productAttributeTypeId' cannot be null.");
        else if (productAttributeTypeId !== undefined)
            url_ += "ProductAttributeTypeId=" + encodeURIComponent("" + productAttributeTypeId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductAttributeTypeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductAttributeTypeName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductAttributeTypeName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductTypeAttributeGroupAttributesClient {
    getAllProductTypeAttributeGroupAttributes(): Observable<AllProductTypeAttributeGroupAttributeDto[]>;
    getProductTypeAttributeGroupAttributeById(id: number): Observable<ProductTypeAttributeGroupAttributeDto>;
    update(id: number, command: UpdateProductTypeAttributeGroupAttributeCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateProductTypeAttributeGroupAttributeCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductTypeAttributeGroupAttributesClient implements IProductTypeAttributeGroupAttributesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductTypeAttributeGroupAttributes(): Observable<AllProductTypeAttributeGroupAttributeDto[]> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroupAttributes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductTypeAttributeGroupAttributes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductTypeAttributeGroupAttributes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductTypeAttributeGroupAttributeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductTypeAttributeGroupAttributeDto[]>;
        }));
    }

    protected processGetAllProductTypeAttributeGroupAttributes(response: HttpResponseBase): Observable<AllProductTypeAttributeGroupAttributeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductTypeAttributeGroupAttributeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductTypeAttributeGroupAttributeById(id: number): Observable<ProductTypeAttributeGroupAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroupAttributes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTypeAttributeGroupAttributeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTypeAttributeGroupAttributeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTypeAttributeGroupAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTypeAttributeGroupAttributeDto>;
        }));
    }

    protected processGetProductTypeAttributeGroupAttributeById(response: HttpResponseBase): Observable<ProductTypeAttributeGroupAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductTypeAttributeGroupAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductTypeAttributeGroupAttributeCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroupAttributes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroupAttributes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroupAttributes/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductTypeAttributeGroupAttributeCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroupAttributes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroupAttributes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductTypeAttributeGroupsClient {
    getAllProductTypeAttributeGroups(): Observable<ProductTypeAttributeGroupDto[]>;
    getAllProductTypeAttributeGroupsDropDown(): Observable<AllProductTypeAttributeGroupDropDownDto[]>;
    getProductTypeAttributeGroupById(id: number): Observable<ProductTypeAttributeGroupDto>;
    update(id: number, command: UpdateProductTypeAttributeGroupCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getProductTypeAttributeGroupsByProductAttributeTypeId(id: number): Observable<ProductTypeAttributeGroupByProductAttributeTypeIdDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateProductTypeAttributeGroupCommand): Observable<number>;
    deleteRange(ids: number[]): Observable<FileResponse>;
    isUniqueProductTypeAttributeGroupName(productTypeAttributeGroupId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductTypeAttributeGroupsClient implements IProductTypeAttributeGroupsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductTypeAttributeGroups(): Observable<ProductTypeAttributeGroupDto[]> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroups/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductTypeAttributeGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductTypeAttributeGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTypeAttributeGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTypeAttributeGroupDto[]>;
        }));
    }

    protected processGetAllProductTypeAttributeGroups(response: HttpResponseBase): Observable<ProductTypeAttributeGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductTypeAttributeGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductTypeAttributeGroupsDropDown(): Observable<AllProductTypeAttributeGroupDropDownDto[]> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroups/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductTypeAttributeGroupsDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductTypeAttributeGroupsDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductTypeAttributeGroupDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductTypeAttributeGroupDropDownDto[]>;
        }));
    }

    protected processGetAllProductTypeAttributeGroupsDropDown(response: HttpResponseBase): Observable<AllProductTypeAttributeGroupDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductTypeAttributeGroupDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductTypeAttributeGroupById(id: number): Observable<ProductTypeAttributeGroupDto> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTypeAttributeGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTypeAttributeGroupById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTypeAttributeGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTypeAttributeGroupDto>;
        }));
    }

    protected processGetProductTypeAttributeGroupById(response: HttpResponseBase): Observable<ProductTypeAttributeGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductTypeAttributeGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProductTypeAttributeGroupCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductTypeAttributeGroupsByProductAttributeTypeId(id: number): Observable<ProductTypeAttributeGroupByProductAttributeTypeIdDto[]> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroups/ProductAttributeType{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTypeAttributeGroupsByProductAttributeTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTypeAttributeGroupsByProductAttributeTypeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTypeAttributeGroupByProductAttributeTypeIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTypeAttributeGroupByProductAttributeTypeIdDto[]>;
        }));
    }

    protected processGetProductTypeAttributeGroupsByProductAttributeTypeId(response: HttpResponseBase): Observable<ProductTypeAttributeGroupByProductAttributeTypeIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductTypeAttributeGroupByProductAttributeTypeIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroups/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductTypeAttributeGroupCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRange(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRange(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductTypeAttributeGroupName(productTypeAttributeGroupId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProductTypeAttributeGroups/isUniqueName?";
        if (productTypeAttributeGroupId === null)
            throw new Error("The parameter 'productTypeAttributeGroupId' cannot be null.");
        else if (productTypeAttributeGroupId !== undefined)
            url_ += "ProductTypeAttributeGroupId=" + encodeURIComponent("" + productTypeAttributeGroupId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductTypeAttributeGroupName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductTypeAttributeGroupName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductTypeAttributeGroupName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOrdersClient {
    getAllOrders(): Observable<OrderDto[]>;
    getOrdersCount(): Observable<number>;
    getOrdersWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto>;
    getRegisteredOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto>;
    getConfirmedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto>;
    getPaymentConfirmedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto>;
    getPreparedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto>;
    getShippedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto>;
    getUnconfirmedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto>;
    getPaymentUnconfirmedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto>;
    getCanceledOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto>;
    getCostRefundedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto>;
    getCompletedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto>;
    getOrdersByCustomerId(customerId: string): Observable<OrderDto[]>;
    getOrdersByProductId(productId: number): Observable<OrderDto[]>;
    getOrderInfo(id: number): Observable<OrderInfoDto>;
    getOrderItemsByOrderId(orderId: number): Observable<OrderItemDto[]>;
    getOrderTotalsByOrderId(orderId: number): Observable<OrderTotalDto[]>;
    getOrderPaymentsByOrderId(orderId: number): Observable<OrderPaymentDto[]>;
    getOrderItemOptionsByOrderItemId(orderItemId: number): Observable<OrderItemOptionDto[]>;
    getOrderStatesByOrderId(orderId: number): Observable<OrderStateBaseDto[]>;
    getOrderById(id: number): Observable<OrderDto>;
    update(id: number, command: UpdateOrderCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getCurrentOrderStateByOrderId(orderId: number): Observable<OrderStateBaseDto>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelCanceledQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelCompletedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelConfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelCostRefundedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelPaymentConfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelPaymentUnconfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelPreparedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelRegisteredQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelShippedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    exportExcelUnconfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    cancel(id: number, command: CancelOrderCommand): Observable<FileResponse>;
    confirm(id: number, command: ConfirmOrderCommand): Observable<FileResponse>;
    confirmPayment(id: number, command: ConfirmOrderPaymentCommand): Observable<FileResponse>;
    prepare(id: number, command: PrepareOrderCommand): Observable<FileResponse>;
    ship(id: number, command: ShipOrderCommand): Observable<FileResponse>;
    unConfirm(id: number, command: UnConfirmOrderCommand): Observable<FileResponse>;
    unConfirmPayment(id: number, command: UnConfirmOrderPaymentCommand): Observable<FileResponse>;
    refundCost(id: number, command: RefundOrderCostCommand): Observable<FileResponse>;
    complete(id: number, command: CompleteOrderCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class OrdersClient implements IOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllOrders(): Observable<OrderDto[]> {
        let url_ = this.baseUrl + "/api/Orders/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDto[]>;
        }));
    }

    protected processGetAllOrders(response: HttpResponseBase): Observable<OrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrdersCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/Orders/count";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetOrdersCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrdersWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto> {
        let url_ = this.baseUrl + "/api/Orders?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredOrderDto>;
        }));
    }

    protected processGetOrdersWithPagination(response: HttpResponseBase): Observable<FilteredOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRegisteredOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto> {
        let url_ = this.baseUrl + "/api/Orders/registered?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegisteredOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegisteredOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredOrderDto>;
        }));
    }

    protected processGetRegisteredOrders(response: HttpResponseBase): Observable<FilteredOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getConfirmedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto> {
        let url_ = this.baseUrl + "/api/Orders/confirmed?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfirmedOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfirmedOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredOrderDto>;
        }));
    }

    protected processGetConfirmedOrders(response: HttpResponseBase): Observable<FilteredOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPaymentConfirmedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto> {
        let url_ = this.baseUrl + "/api/Orders/paymentConfirmed?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentConfirmedOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentConfirmedOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredOrderDto>;
        }));
    }

    protected processGetPaymentConfirmedOrders(response: HttpResponseBase): Observable<FilteredOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPreparedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto> {
        let url_ = this.baseUrl + "/api/Orders/prepared?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPreparedOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPreparedOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredOrderDto>;
        }));
    }

    protected processGetPreparedOrders(response: HttpResponseBase): Observable<FilteredOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getShippedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto> {
        let url_ = this.baseUrl + "/api/Orders/shipped?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShippedOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShippedOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredOrderDto>;
        }));
    }

    protected processGetShippedOrders(response: HttpResponseBase): Observable<FilteredOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUnconfirmedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto> {
        let url_ = this.baseUrl + "/api/Orders/unconfirmed?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnconfirmedOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnconfirmedOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredOrderDto>;
        }));
    }

    protected processGetUnconfirmedOrders(response: HttpResponseBase): Observable<FilteredOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPaymentUnconfirmedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto> {
        let url_ = this.baseUrl + "/api/Orders/paymentUnconfirmed?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentUnconfirmedOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentUnconfirmedOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredOrderDto>;
        }));
    }

    protected processGetPaymentUnconfirmedOrders(response: HttpResponseBase): Observable<FilteredOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCanceledOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto> {
        let url_ = this.baseUrl + "/api/Orders/canceled?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCanceledOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCanceledOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredOrderDto>;
        }));
    }

    protected processGetCanceledOrders(response: HttpResponseBase): Observable<FilteredOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCostRefundedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto> {
        let url_ = this.baseUrl + "/api/Orders/costRefunded?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCostRefundedOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCostRefundedOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredOrderDto>;
        }));
    }

    protected processGetCostRefundedOrders(response: HttpResponseBase): Observable<FilteredOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCompletedOrders(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredOrderDto> {
        let url_ = this.baseUrl + "/api/Orders/completed?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompletedOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompletedOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredOrderDto>;
        }));
    }

    protected processGetCompletedOrders(response: HttpResponseBase): Observable<FilteredOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrdersByCustomerId(customerId: string): Observable<OrderDto[]> {
        let url_ = this.baseUrl + "/api/Orders/customer/{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDto[]>;
        }));
    }

    protected processGetOrdersByCustomerId(response: HttpResponseBase): Observable<OrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrdersByProductId(productId: number): Observable<OrderDto[]> {
        let url_ = this.baseUrl + "/api/Orders/product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersByProductId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDto[]>;
        }));
    }

    protected processGetOrdersByProductId(response: HttpResponseBase): Observable<OrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderInfo(id: number): Observable<OrderInfoDto> {
        let url_ = this.baseUrl + "/api/Orders/info/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderInfoDto>;
        }));
    }

    protected processGetOrderInfo(response: HttpResponseBase): Observable<OrderInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderItemsByOrderId(orderId: number): Observable<OrderItemDto[]> {
        let url_ = this.baseUrl + "/api/Orders/orderItem/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderItemsByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderItemsByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderItemDto[]>;
        }));
    }

    protected processGetOrderItemsByOrderId(response: HttpResponseBase): Observable<OrderItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderTotalsByOrderId(orderId: number): Observable<OrderTotalDto[]> {
        let url_ = this.baseUrl + "/api/Orders/orderTotal/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderTotalsByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderTotalsByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderTotalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderTotalDto[]>;
        }));
    }

    protected processGetOrderTotalsByOrderId(response: HttpResponseBase): Observable<OrderTotalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderTotalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderPaymentsByOrderId(orderId: number): Observable<OrderPaymentDto[]> {
        let url_ = this.baseUrl + "/api/Orders/orderPayment/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderPaymentsByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderPaymentsByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderPaymentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderPaymentDto[]>;
        }));
    }

    protected processGetOrderPaymentsByOrderId(response: HttpResponseBase): Observable<OrderPaymentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderPaymentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderItemOptionsByOrderItemId(orderItemId: number): Observable<OrderItemOptionDto[]> {
        let url_ = this.baseUrl + "/api/Orders/orderItemOption/{orderItemId}";
        if (orderItemId === undefined || orderItemId === null)
            throw new Error("The parameter 'orderItemId' must be defined.");
        url_ = url_.replace("{orderItemId}", encodeURIComponent("" + orderItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderItemOptionsByOrderItemId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderItemOptionsByOrderItemId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderItemOptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderItemOptionDto[]>;
        }));
    }

    protected processGetOrderItemOptionsByOrderItemId(response: HttpResponseBase): Observable<OrderItemOptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderItemOptionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderStatesByOrderId(orderId: number): Observable<OrderStateBaseDto[]> {
        let url_ = this.baseUrl + "/api/Orders/orderState/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderStatesByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderStatesByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderStateBaseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderStateBaseDto[]>;
        }));
    }

    protected processGetOrderStatesByOrderId(response: HttpResponseBase): Observable<OrderStateBaseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderStateBaseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderById(id: number): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDto>;
        }));
    }

    protected processGetOrderById(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCurrentOrderStateByOrderId(orderId: number): Observable<OrderStateBaseDto> {
        let url_ = this.baseUrl + "/api/Orders/currentOrderState/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentOrderStateByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentOrderStateByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderStateBaseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderStateBaseDto>;
        }));
    }

    protected processGetCurrentOrderStateByOrderId(response: HttpResponseBase): Observable<OrderStateBaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderStateBaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelCanceledQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/exportExcelCanceled?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelCanceledQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelCanceledQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelCanceledQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelCompletedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/exportExcelCompleted?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelCompletedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelCompletedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelCompletedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelConfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/exportExcelConfirmed?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelConfirmedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelConfirmedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelConfirmedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelCostRefundedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/exportExcelCostRefunded?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelCostRefundedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelCostRefundedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelCostRefundedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelPaymentConfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/exportExcelPaymentConfirmed?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelPaymentConfirmedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelPaymentConfirmedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelPaymentConfirmedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelPaymentUnconfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/exportExcelPaymentUnconfirmed?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelPaymentUnconfirmedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelPaymentUnconfirmedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelPaymentUnconfirmedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelPreparedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/exportExcelPrepared?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelPreparedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelPreparedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelPreparedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelRegisteredQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/exportExcelRegistered?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelRegisteredQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelRegisteredQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelRegisteredQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelShippedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/exportExcelShipped?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelShippedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelShippedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelShippedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelUnconfirmedQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/exportExcelUnconfirmed?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelUnconfirmedQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelUnconfirmedQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelUnconfirmedQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    cancel(id: number, command: CancelOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/cancel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    confirm(id: number, command: ConfirmOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/confirm/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processConfirm(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    confirmPayment(id: number, command: ConfirmOrderPaymentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/confirmPayment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    prepare(id: number, command: PrepareOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/prepare/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPrepare(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    ship(id: number, command: ShipOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/ship/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShip(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processShip(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unConfirm(id: number, command: UnConfirmOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/unConfirm/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnConfirm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUnConfirm(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unConfirmPayment(id: number, command: UnConfirmOrderPaymentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/unConfirmPayment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnConfirmPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUnConfirmPayment(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refundCost(id: number, command: RefundOrderCostCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/refundCost/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundCost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundCost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRefundCost(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    complete(id: number, command: CompleteOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/complete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processComplete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IBlockBannersClient {
    getBlockBannersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfBlockBannerDto>;
    create(command: CreateBlockBannerCommand): Observable<number>;
    deleteRangeBlockBanner(ids: number[]): Observable<FileResponse>;
    getAllBlockBanners(): Observable<BlockBannerDto[]>;
    getBlockBannerById(id: number): Observable<BlockBannerDto>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    update(urlId: number, command: UpdateBlockBannerCommand): Observable<FileResponse>;
    isUniqueBlockBannerPosition(blockBannerPosition: BlockBannerPosition | undefined, blockBannerId: number | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class BlockBannersClient implements IBlockBannersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getBlockBannersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfBlockBannerDto> {
        let url_ = this.baseUrl + "/api/BlockBanners?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlockBannersWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlockBannersWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfBlockBannerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfBlockBannerDto>;
        }));
    }

    protected processGetBlockBannersWithPagination(response: HttpResponseBase): Observable<PaginatedListOfBlockBannerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfBlockBannerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateBlockBannerCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/BlockBanners";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeBlockBanner(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/BlockBanners";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeBlockBanner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeBlockBanner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeBlockBanner(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllBlockBanners(): Observable<BlockBannerDto[]> {
        let url_ = this.baseUrl + "/api/BlockBanners/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBlockBanners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBlockBanners(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlockBannerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlockBannerDto[]>;
        }));
    }

    protected processGetAllBlockBanners(response: HttpResponseBase): Observable<BlockBannerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlockBannerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBlockBannerById(id: number): Observable<BlockBannerDto> {
        let url_ = this.baseUrl + "/api/BlockBanners/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlockBannerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlockBannerById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlockBannerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlockBannerDto>;
        }));
    }

    protected processGetBlockBannerById(response: HttpResponseBase): Observable<BlockBannerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlockBannerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/BlockBanners/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/BlockBanners/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateBlockBannerCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/BlockBanners/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueBlockBannerPosition(blockBannerPosition: BlockBannerPosition | undefined, blockBannerId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/BlockBanners/isUniquePosition?";
        if (blockBannerPosition === null)
            throw new Error("The parameter 'blockBannerPosition' cannot be null.");
        else if (blockBannerPosition !== undefined)
            url_ += "BlockBannerPosition=" + encodeURIComponent("" + blockBannerPosition) + "&";
        if (blockBannerId === null)
            throw new Error("The parameter 'blockBannerId' cannot be null.");
        else if (blockBannerId !== undefined)
            url_ += "BlockBannerId=" + encodeURIComponent("" + blockBannerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueBlockBannerPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueBlockBannerPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueBlockBannerPosition(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICarouselsClient {
    getCarouselsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCarouselDto>;
    create(command: CreateCarouselCommand): Observable<number>;
    deleteRangeCarousel(ids: number[]): Observable<FileResponse>;
    getAllCarousels(): Observable<CarouselDto[]>;
    getCarouselById(id: number): Observable<CarouselDto>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    update(urlId: number, command: UpdateCarouselCommand): Observable<FileResponse>;
    isUniqueCarouselTitle(carouselId: number | undefined, carouselTitle: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class CarouselsClient implements ICarouselsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCarouselsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCarouselDto> {
        let url_ = this.baseUrl + "/api/Carousels?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCarouselsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCarouselsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCarouselDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCarouselDto>;
        }));
    }

    protected processGetCarouselsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCarouselDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCarouselDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCarouselCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Carousels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeCarousel(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Carousels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeCarousel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeCarousel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeCarousel(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCarousels(): Observable<CarouselDto[]> {
        let url_ = this.baseUrl + "/api/Carousels/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCarousels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCarousels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarouselDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarouselDto[]>;
        }));
    }

    protected processGetAllCarousels(response: HttpResponseBase): Observable<CarouselDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CarouselDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCarouselById(id: number): Observable<CarouselDto> {
        let url_ = this.baseUrl + "/api/Carousels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCarouselById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCarouselById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarouselDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarouselDto>;
        }));
    }

    protected processGetCarouselById(response: HttpResponseBase): Observable<CarouselDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarouselDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Carousels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Carousels/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateCarouselCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Carousels/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueCarouselTitle(carouselId: number | undefined, carouselTitle: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Carousels/isUniqueTitle?";
        if (carouselId === null)
            throw new Error("The parameter 'carouselId' cannot be null.");
        else if (carouselId !== undefined)
            url_ += "CarouselId=" + encodeURIComponent("" + carouselId) + "&";
        if (carouselTitle === null)
            throw new Error("The parameter 'carouselTitle' cannot be null.");
        else if (carouselTitle !== undefined)
            url_ += "CarouselTitle=" + encodeURIComponent("" + carouselTitle) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueCarouselTitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueCarouselTitle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueCarouselTitle(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFooterLinkContainersClient {
    getFooterLinkContainersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFooterLinkContainerDto>;
    create(command: CreateFooterLinkContainerCommand): Observable<number>;
    deleteRangeFooterLinkContainer(ids: number[]): Observable<FileResponse>;
    getAllFooterLinkContainers(): Observable<FooterLinkContainerDto[]>;
    getFooterLinkContainerById(id: number): Observable<FooterLinkContainerDto>;
    update(id: number, command: UpdateFooterLinkContainerCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class FooterLinkContainersClient implements IFooterLinkContainersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getFooterLinkContainersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFooterLinkContainerDto> {
        let url_ = this.baseUrl + "/api/FooterLinkContainers?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFooterLinkContainersWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFooterLinkContainersWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfFooterLinkContainerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfFooterLinkContainerDto>;
        }));
    }

    protected processGetFooterLinkContainersWithPagination(response: HttpResponseBase): Observable<PaginatedListOfFooterLinkContainerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfFooterLinkContainerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateFooterLinkContainerCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/FooterLinkContainers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeFooterLinkContainer(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FooterLinkContainers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeFooterLinkContainer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeFooterLinkContainer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeFooterLinkContainer(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFooterLinkContainers(): Observable<FooterLinkContainerDto[]> {
        let url_ = this.baseUrl + "/api/FooterLinkContainers/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFooterLinkContainers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFooterLinkContainers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterLinkContainerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterLinkContainerDto[]>;
        }));
    }

    protected processGetAllFooterLinkContainers(response: HttpResponseBase): Observable<FooterLinkContainerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FooterLinkContainerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFooterLinkContainerById(id: number): Observable<FooterLinkContainerDto> {
        let url_ = this.baseUrl + "/api/FooterLinkContainers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFooterLinkContainerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFooterLinkContainerById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterLinkContainerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterLinkContainerDto>;
        }));
    }

    protected processGetFooterLinkContainerById(response: HttpResponseBase): Observable<FooterLinkContainerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FooterLinkContainerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateFooterLinkContainerCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FooterLinkContainers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FooterLinkContainers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FooterLinkContainers/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFooterLinksClient {
    getFooterLinksWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFooterLinkDto>;
    create(command: CreateFooterLinkCommand): Observable<number>;
    deleteRangeFooterLink(ids: number[]): Observable<FileResponse>;
    getAllFooterLinks(): Observable<FooterLinkDto[]>;
    getFooterLinksByFooterLinkContainerId(footerLinkContainerId: number): Observable<FooterLinkDto[]>;
    getFooterLinkById(id: number): Observable<FooterLinkDto>;
    update(id: number, command: UpdateFooterLinkCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class FooterLinksClient implements IFooterLinksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getFooterLinksWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFooterLinkDto> {
        let url_ = this.baseUrl + "/api/FooterLinks?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFooterLinksWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFooterLinksWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfFooterLinkDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfFooterLinkDto>;
        }));
    }

    protected processGetFooterLinksWithPagination(response: HttpResponseBase): Observable<PaginatedListOfFooterLinkDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfFooterLinkDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateFooterLinkCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/FooterLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeFooterLink(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FooterLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeFooterLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeFooterLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeFooterLink(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFooterLinks(): Observable<FooterLinkDto[]> {
        let url_ = this.baseUrl + "/api/FooterLinks/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFooterLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFooterLinks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterLinkDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterLinkDto[]>;
        }));
    }

    protected processGetAllFooterLinks(response: HttpResponseBase): Observable<FooterLinkDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FooterLinkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFooterLinksByFooterLinkContainerId(footerLinkContainerId: number): Observable<FooterLinkDto[]> {
        let url_ = this.baseUrl + "/api/FooterLinks/footerLinkContainerId{footerLinkContainerId}";
        if (footerLinkContainerId === undefined || footerLinkContainerId === null)
            throw new Error("The parameter 'footerLinkContainerId' must be defined.");
        url_ = url_.replace("{footerLinkContainerId}", encodeURIComponent("" + footerLinkContainerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFooterLinksByFooterLinkContainerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFooterLinksByFooterLinkContainerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterLinkDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterLinkDto[]>;
        }));
    }

    protected processGetFooterLinksByFooterLinkContainerId(response: HttpResponseBase): Observable<FooterLinkDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FooterLinkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFooterLinkById(id: number): Observable<FooterLinkDto> {
        let url_ = this.baseUrl + "/api/FooterLinks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFooterLinkById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFooterLinkById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterLinkDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterLinkDto>;
        }));
    }

    protected processGetFooterLinkById(response: HttpResponseBase): Observable<FooterLinkDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FooterLinkDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateFooterLinkCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FooterLinks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FooterLinks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FooterLinks/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISocialLinksClient {
    getAllSocialLinks(): Observable<SocialLinkDto[]>;
    getSocialLinkById(id: number): Observable<SocialLinkDto>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateSocialLinkCommand): Observable<number>;
    deleteRangeSocialLink(ids: number[]): Observable<FileResponse>;
    update(urlId: number, command: UpdateSocialLinkCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class SocialLinksClient implements ISocialLinksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllSocialLinks(): Observable<SocialLinkDto[]> {
        let url_ = this.baseUrl + "/api/SocialLinks/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSocialLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSocialLinks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialLinkDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialLinkDto[]>;
        }));
    }

    protected processGetAllSocialLinks(response: HttpResponseBase): Observable<SocialLinkDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocialLinkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSocialLinkById(id: number): Observable<SocialLinkDto> {
        let url_ = this.baseUrl + "/api/SocialLinks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSocialLinkById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSocialLinkById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialLinkDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialLinkDto>;
        }));
    }

    protected processGetSocialLinkById(response: HttpResponseBase): Observable<SocialLinkDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SocialLinkDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SocialLinks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SocialLinks/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateSocialLinkCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/SocialLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeSocialLink(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SocialLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeSocialLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeSocialLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeSocialLink(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateSocialLinkCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SocialLinks/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IThemesClient {
    getThemesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfThemeDto>;
    create(command: CreateThemeCommand): Observable<number>;
    deleteRangeTheme(ids: number[]): Observable<FileResponse>;
    getAllThemes(): Observable<ThemeDto[]>;
    getThemeById(id: number): Observable<ThemeDto>;
    delete(id: number): Observable<FileResponse>;
    update(urlId: number, command: UpdateThemeCommand): Observable<FileResponse>;
    isUniqueThemeTitle(themeId: number | undefined, themeTitle: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ThemesClient implements IThemesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getThemesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfThemeDto> {
        let url_ = this.baseUrl + "/api/Themes?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThemesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThemesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfThemeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfThemeDto>;
        }));
    }

    protected processGetThemesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfThemeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfThemeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateThemeCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Themes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeTheme(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Themes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeTheme(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllThemes(): Observable<ThemeDto[]> {
        let url_ = this.baseUrl + "/api/Themes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllThemes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllThemes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThemeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThemeDto[]>;
        }));
    }

    protected processGetAllThemes(response: HttpResponseBase): Observable<ThemeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getThemeById(id: number): Observable<ThemeDto> {
        let url_ = this.baseUrl + "/api/Themes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThemeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThemeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThemeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThemeDto>;
        }));
    }

    protected processGetThemeById(response: HttpResponseBase): Observable<ThemeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThemeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Themes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateThemeCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Themes/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueThemeTitle(themeId: number | undefined, themeTitle: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Themes/isUniqueTitle?";
        if (themeId === null)
            throw new Error("The parameter 'themeId' cannot be null.");
        else if (themeId !== undefined)
            url_ += "ThemeId=" + encodeURIComponent("" + themeId) + "&";
        if (themeTitle === null)
            throw new Error("The parameter 'themeTitle' cannot be null.");
        else if (themeTitle !== undefined)
            url_ += "ThemeTitle=" + encodeURIComponent("" + themeTitle) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueThemeTitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueThemeTitle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueThemeTitle(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAboutUsClient {
    getAllAboutUs(): Observable<AboutUsDto[]>;
    create(command: CreateAboutUsCommand): Observable<number>;
    deleteRangeAboutUs(ids: number[]): Observable<FileResponse>;
    update(urlId: number, command: UpdateAboutUsCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    isUniqueAboutUsTitle(aboutUsId: number | undefined, title: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class AboutUsClient implements IAboutUsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllAboutUs(): Observable<AboutUsDto[]> {
        let url_ = this.baseUrl + "/api/AboutUs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAboutUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAboutUs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AboutUsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AboutUsDto[]>;
        }));
    }

    protected processGetAllAboutUs(response: HttpResponseBase): Observable<AboutUsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AboutUsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateAboutUsCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/AboutUs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeAboutUs(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/AboutUs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeAboutUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeAboutUs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeAboutUs(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateAboutUsCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/AboutUs/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/AboutUs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueAboutUsTitle(aboutUsId: number | undefined, title: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AboutUs/isUniqueTitle?";
        if (aboutUsId === null)
            throw new Error("The parameter 'aboutUsId' cannot be null.");
        else if (aboutUsId !== undefined)
            url_ += "AboutUsId=" + encodeURIComponent("" + aboutUsId) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueAboutUsTitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueAboutUsTitle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueAboutUsTitle(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICorporationInfosClient {
    getAllCorporationInfos(): Observable<CorporationInfoDto[]>;
    create(command: CreateCorporationInfoCommand): Observable<number>;
    deleteRangeCorporationInfo(ids: number[]): Observable<FileResponse>;
    getCorporationInfoById(id: number): Observable<CorporationInfoDto>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    update(urlId: number, command: UpdateCorporationInfoCommand): Observable<FileResponse>;
    addEmailAddress(urlId: number, command: AddEmailAddressCommand): Observable<FileResponse>;
    removeEmailAddress(urlId: number, command: RemoveEmailAddressCommand): Observable<FileResponse>;
    addLocationAddress(urlId: number, command: AddLocationAddressCommand): Observable<FileResponse>;
    removeLocationAddress(urlId: number, command: RemoveLocationAddressCommand): Observable<FileResponse>;
    addPhoneNumber(urlId: number, command: AddPhoneNumberCommand): Observable<FileResponse>;
    removePhoneNumber(urlId: number, command: RemovePhoneNumberCommand): Observable<FileResponse>;
    addWorkingHour(urlId: number, command: AddWorkingHourCommand): Observable<FileResponse>;
    removeWorkingHour(urlId: number, command: RemoveWorkingHourCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CorporationInfosClient implements ICorporationInfosClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllCorporationInfos(): Observable<CorporationInfoDto[]> {
        let url_ = this.baseUrl + "/api/CorporationInfos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCorporationInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCorporationInfos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporationInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporationInfoDto[]>;
        }));
    }

    protected processGetAllCorporationInfos(response: HttpResponseBase): Observable<CorporationInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CorporationInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCorporationInfoCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CorporationInfos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeCorporationInfo(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeCorporationInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeCorporationInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeCorporationInfo(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCorporationInfoById(id: number): Observable<CorporationInfoDto> {
        let url_ = this.baseUrl + "/api/CorporationInfos/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCorporationInfoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCorporationInfoById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporationInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporationInfoDto>;
        }));
    }

    protected processGetCorporationInfoById(response: HttpResponseBase): Observable<CorporationInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporationInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateCorporationInfoCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addEmailAddress(urlId: number, command: AddEmailAddressCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos/addEmailAddress{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmailAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmailAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAddEmailAddress(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeEmailAddress(urlId: number, command: RemoveEmailAddressCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos/removeEmailAddress{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEmailAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEmailAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveEmailAddress(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addLocationAddress(urlId: number, command: AddLocationAddressCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos/addLocationAddress{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLocationAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLocationAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAddLocationAddress(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeLocationAddress(urlId: number, command: RemoveLocationAddressCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos/removeLocationAddress{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveLocationAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveLocationAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveLocationAddress(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addPhoneNumber(urlId: number, command: AddPhoneNumberCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos/addPhoneNumber{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPhoneNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAddPhoneNumber(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removePhoneNumber(urlId: number, command: RemovePhoneNumberCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos/removePhoneNumber{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovePhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovePhoneNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemovePhoneNumber(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addWorkingHour(urlId: number, command: AddWorkingHourCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos/addWorkingHour{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWorkingHour(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWorkingHour(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAddWorkingHour(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeWorkingHour(urlId: number, command: RemoveWorkingHourCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CorporationInfos/removeWorkingHour{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveWorkingHour(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveWorkingHour(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveWorkingHour(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICountriesClient {
    getCountriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountryDto>;
    create(command: CreateCountryCommand): Observable<number>;
    deleteRangeCountry(ids: number[]): Observable<FileResponse>;
    getAllCountries(): Observable<CountryDto[]>;
    getAllCountriesDropDown(): Observable<AllCountryDropDownDto[]>;
    getCountryById(id: number): Observable<CountryDto>;
    update(id: number, command: UpdateCountryCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueCountryLocalizedName(countryId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueCountryName(countryId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class CountriesClient implements ICountriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCountriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountryDto> {
        let url_ = this.baseUrl + "/api/Countries?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountriesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountriesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCountryDto>;
        }));
    }

    protected processGetCountriesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCountryCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Countries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeCountry(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Countries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeCountry(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCountries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/Countries/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processGetAllCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCountriesDropDown(): Observable<AllCountryDropDownDto[]> {
        let url_ = this.baseUrl + "/api/Countries/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountriesDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountriesDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllCountryDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllCountryDropDownDto[]>;
        }));
    }

    protected processGetAllCountriesDropDown(response: HttpResponseBase): Observable<AllCountryDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllCountryDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCountryById(id: number): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/Countries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processGetCountryById(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCountryCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Countries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Countries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Countries/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueCountryLocalizedName(countryId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Countries/isUniqueLocalizedName?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueCountryLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueCountryLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueCountryLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueCountryName(countryId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Countries/isUniqueName?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueCountryName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueCountryName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueCountryName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuestionsClient {
    getQuestionsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfQuestionDto>;
    create(command: CreateQuestionCommand): Observable<number>;
    deleteRangeQuestion(ids: number[]): Observable<FileResponse>;
    getAllQuestions(): Observable<QuestionDto[]>;
    getQuestionById(id: number): Observable<QuestionDto>;
    update(id: number, command: UpdateQuestionCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueQuestionText(questionId: number | undefined, questionText: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class QuestionsClient implements IQuestionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getQuestionsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfQuestionDto> {
        let url_ = this.baseUrl + "/api/Questions?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfQuestionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfQuestionDto>;
        }));
    }

    protected processGetQuestionsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfQuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateQuestionCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Questions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeQuestion(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Questions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeQuestion(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllQuestions(): Observable<QuestionDto[]> {
        let url_ = this.baseUrl + "/api/Questions/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuestions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuestionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuestionDto[]>;
        }));
    }

    protected processGetAllQuestions(response: HttpResponseBase): Observable<QuestionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuestionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getQuestionById(id: number): Observable<QuestionDto> {
        let url_ = this.baseUrl + "/api/Questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuestionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuestionDto>;
        }));
    }

    protected processGetQuestionById(response: HttpResponseBase): Observable<QuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateQuestionCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Questions/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueQuestionText(questionId: number | undefined, questionText: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Questions/isUniqueQuestionText?";
        if (questionId === null)
            throw new Error("The parameter 'questionId' cannot be null.");
        else if (questionId !== undefined)
            url_ += "QuestionId=" + encodeURIComponent("" + questionId) + "&";
        if (questionText === null)
            throw new Error("The parameter 'questionText' cannot be null.");
        else if (questionText !== undefined)
            url_ += "QuestionText=" + encodeURIComponent("" + questionText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueQuestionText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueQuestionText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueQuestionText(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITeamMembersClient {
    getTeamMembersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTeamMemberDto>;
    create(command: CreateTeamMemberCommand): Observable<number>;
    deleteRangeTeamMember(ids: number[]): Observable<FileResponse>;
    getAllTeamMembers(): Observable<TeamMemberDto[]>;
    getTeamMemberById(id: number): Observable<TeamMemberDto>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    update(urlId: number, command: UpdateTeamMemberCommand): Observable<FileResponse>;
    isUniqueTeamMemberName(teamMemberId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class TeamMembersClient implements ITeamMembersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getTeamMembersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTeamMemberDto> {
        let url_ = this.baseUrl + "/api/TeamMembers?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeamMembersWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamMembersWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTeamMemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTeamMemberDto>;
        }));
    }

    protected processGetTeamMembersWithPagination(response: HttpResponseBase): Observable<PaginatedListOfTeamMemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTeamMemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTeamMemberCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TeamMembers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeTeamMember(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TeamMembers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeTeamMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeTeamMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeTeamMember(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllTeamMembers(): Observable<TeamMemberDto[]> {
        let url_ = this.baseUrl + "/api/TeamMembers/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeamMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeamMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamMemberDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamMemberDto[]>;
        }));
    }

    protected processGetAllTeamMembers(response: HttpResponseBase): Observable<TeamMemberDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeamMemberDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTeamMemberById(id: number): Observable<TeamMemberDto> {
        let url_ = this.baseUrl + "/api/TeamMembers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeamMemberById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamMemberById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamMemberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamMemberDto>;
        }));
    }

    protected processGetTeamMemberById(response: HttpResponseBase): Observable<TeamMemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamMemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TeamMembers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TeamMembers/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateTeamMemberCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TeamMembers/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueTeamMemberName(teamMemberId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TeamMembers/isUniqueName?";
        if (teamMemberId === null)
            throw new Error("The parameter 'teamMemberId' cannot be null.");
        else if (teamMemberId !== undefined)
            url_ += "TeamMemberId=" + encodeURIComponent("" + teamMemberId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueTeamMemberName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueTeamMemberName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueTeamMemberName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITestimonialsClient {
    getTestimonialsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTestimonialDto>;
    create(command: CreateTestimonialCommand): Observable<number>;
    deleteRangeTestimonial(ids: number[]): Observable<FileResponse>;
    getAllTestimonials(): Observable<TestimonialDto[]>;
    getTestimonialById(id: number): Observable<TestimonialDto>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    update(urlId: number, command: UpdateTestimonialCommand): Observable<FileResponse>;
    isUniqueTestimonialName(testimonialId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class TestimonialsClient implements ITestimonialsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getTestimonialsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTestimonialDto> {
        let url_ = this.baseUrl + "/api/Testimonials?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestimonialsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestimonialsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTestimonialDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTestimonialDto>;
        }));
    }

    protected processGetTestimonialsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfTestimonialDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTestimonialDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTestimonialCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Testimonials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeTestimonial(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Testimonials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeTestimonial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeTestimonial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeTestimonial(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllTestimonials(): Observable<TestimonialDto[]> {
        let url_ = this.baseUrl + "/api/Testimonials/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTestimonials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTestimonials(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestimonialDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestimonialDto[]>;
        }));
    }

    protected processGetAllTestimonials(response: HttpResponseBase): Observable<TestimonialDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TestimonialDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTestimonialById(id: number): Observable<TestimonialDto> {
        let url_ = this.baseUrl + "/api/Testimonials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestimonialById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestimonialById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestimonialDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestimonialDto>;
        }));
    }

    protected processGetTestimonialById(response: HttpResponseBase): Observable<TestimonialDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestimonialDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Testimonials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Testimonials/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateTestimonialCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Testimonials/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueTestimonialName(testimonialId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Testimonials/isUniqueName?";
        if (testimonialId === null)
            throw new Error("The parameter 'testimonialId' cannot be null.");
        else if (testimonialId !== undefined)
            url_ += "TestimonialId=" + encodeURIComponent("" + testimonialId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueTestimonialName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueTestimonialName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueTestimonialName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFilesClient {
    uploadTemp(file: FileParameter | null | undefined): Observable<FileUploadMetadataDto>;
    downloadTemp(fileId: string): Observable<FileResponse>;
    deleteTemp(fileId: string): Observable<boolean>;
    getTempInfo(fileId: string): Observable<FileUploadMetadataDto>;
    downloadPersisted(fileId: string): Observable<FileResponse>;
    deletePersisted(fileId: string): Observable<boolean>;
    getInfoPersisted(fileId: string): Observable<StoredFileDto>;
}

@Injectable({
    providedIn: 'root'
})
export class FilesClient implements IFilesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    uploadTemp(file: FileParameter | null | undefined): Observable<FileUploadMetadataDto> {
        let url_ = this.baseUrl + "/api/Files/temp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadTemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadTemp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileUploadMetadataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileUploadMetadataDto>;
        }));
    }

    protected processUploadTemp(response: HttpResponseBase): Observable<FileUploadMetadataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileUploadMetadataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadTemp(fileId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Files/temp/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTemp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadTemp(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTemp(fileId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Files/temp/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteTemp(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTempInfo(fileId: string): Observable<FileUploadMetadataDto> {
        let url_ = this.baseUrl + "/api/Files/temp/{fileId}/info";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTempInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTempInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileUploadMetadataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileUploadMetadataDto>;
        }));
    }

    protected processGetTempInfo(response: HttpResponseBase): Observable<FileUploadMetadataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileUploadMetadataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadPersisted(fileId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Files/store/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadPersisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadPersisted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadPersisted(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deletePersisted(fileId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Files/store/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePersisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePersisted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeletePersisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getInfoPersisted(fileId: string): Observable<StoredFileDto> {
        let url_ = this.baseUrl + "/api/Files/store/{fileId}/info";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfoPersisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfoPersisted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoredFileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoredFileDto>;
        }));
    }

    protected processGetInfoPersisted(response: HttpResponseBase): Observable<StoredFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoredFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICustomerTicketsClient {
    getCustomerTicketsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredCustomerTicketDto>;
    create(command: CreateCustomerTicketCommand): Observable<number>;
    deleteRangeCustomerTicket(ids: number[]): Observable<FileResponse>;
    getCustomerTicketsByCustomerId(customerId: string): Observable<CustomerTicketDto[]>;
    getCustomerTicketById(id: number): Observable<CustomerTicketDto>;
    update(id: number, command: UpdateCustomerTicketCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomerTicketsClient implements ICustomerTicketsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCustomerTicketsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredCustomerTicketDto> {
        let url_ = this.baseUrl + "/api/CustomerTickets?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTicketsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTicketsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredCustomerTicketDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredCustomerTicketDto>;
        }));
    }

    protected processGetCustomerTicketsWithPagination(response: HttpResponseBase): Observable<FilteredCustomerTicketDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredCustomerTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCustomerTicketCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CustomerTickets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeCustomerTicket(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CustomerTickets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeCustomerTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeCustomerTicket(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeCustomerTicket(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomerTicketsByCustomerId(customerId: string): Observable<CustomerTicketDto[]> {
        let url_ = this.baseUrl + "/api/CustomerTickets/customer{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTicketsByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTicketsByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTicketDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTicketDto[]>;
        }));
    }

    protected processGetCustomerTicketsByCustomerId(response: HttpResponseBase): Observable<CustomerTicketDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerTicketDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomerTicketById(id: number): Observable<CustomerTicketDto> {
        let url_ = this.baseUrl + "/api/CustomerTickets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTicketById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTicketById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTicketDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTicketDto>;
        }));
    }

    protected processGetCustomerTicketById(response: HttpResponseBase): Observable<CustomerTicketDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCustomerTicketCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CustomerTickets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CustomerTickets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CustomerTickets/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IBlogCategoriesClient {
    getAllBlogCategories(): Observable<BlogCategoryDto[]>;
    getBlogCategoriesByBlogParentCategoryId(blogParentCategoryId: number | null | undefined): Observable<BlogCategoryDto[]>;
    getBlogCategoryById(id: number): Observable<BlogCategoryDto>;
    update(id: number, command: UpdateBlogCategoryCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getBlogCategoryBySlug(slug: string | undefined): Observable<BlogCategoryDto>;
    create(command: CreateBlogCategoryCommand): Observable<number>;
    isUniqueBlogCategoryLocalizedName(blogCategoryId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueBlogCategoryName(blogCategoryId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class BlogCategoriesClient implements IBlogCategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllBlogCategories(): Observable<BlogCategoryDto[]> {
        let url_ = this.baseUrl + "/api/BlogCategories/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBlogCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBlogCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlogCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlogCategoryDto[]>;
        }));
    }

    protected processGetAllBlogCategories(response: HttpResponseBase): Observable<BlogCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlogCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBlogCategoriesByBlogParentCategoryId(blogParentCategoryId: number | null | undefined): Observable<BlogCategoryDto[]> {
        let url_ = this.baseUrl + "/api/BlogCategories/blogParentCategory?";
        if (blogParentCategoryId !== undefined && blogParentCategoryId !== null)
            url_ += "BlogParentCategoryId=" + encodeURIComponent("" + blogParentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlogCategoriesByBlogParentCategoryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlogCategoriesByBlogParentCategoryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlogCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlogCategoryDto[]>;
        }));
    }

    protected processGetBlogCategoriesByBlogParentCategoryId(response: HttpResponseBase): Observable<BlogCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlogCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBlogCategoryById(id: number): Observable<BlogCategoryDto> {
        let url_ = this.baseUrl + "/api/BlogCategories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlogCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlogCategoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlogCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlogCategoryDto>;
        }));
    }

    protected processGetBlogCategoryById(response: HttpResponseBase): Observable<BlogCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlogCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateBlogCategoryCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/BlogCategories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/BlogCategories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBlogCategoryBySlug(slug: string | undefined): Observable<BlogCategoryDto> {
        let url_ = this.baseUrl + "/api/BlogCategories/slug?";
        if (slug === null)
            throw new Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "Slug=" + encodeURIComponent("" + slug) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlogCategoryBySlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlogCategoryBySlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlogCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlogCategoryDto>;
        }));
    }

    protected processGetBlogCategoryBySlug(response: HttpResponseBase): Observable<BlogCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlogCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateBlogCategoryCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/BlogCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueBlogCategoryLocalizedName(blogCategoryId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/BlogCategories/isUniqueLocalizedName?";
        if (blogCategoryId === null)
            throw new Error("The parameter 'blogCategoryId' cannot be null.");
        else if (blogCategoryId !== undefined)
            url_ += "BlogCategoryId=" + encodeURIComponent("" + blogCategoryId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueBlogCategoryLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueBlogCategoryLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueBlogCategoryLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueBlogCategoryName(blogCategoryId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/BlogCategories/isUniqueName?";
        if (blogCategoryId === null)
            throw new Error("The parameter 'blogCategoryId' cannot be null.");
        else if (blogCategoryId !== undefined)
            url_ += "BlogCategoryId=" + encodeURIComponent("" + blogCategoryId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueBlogCategoryName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueBlogCategoryName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueBlogCategoryName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductCategoriesClient {
    getAllProductCategories(): Observable<ProductCategoryDto[]>;
    getAllProductCategoriesDropDown(): Observable<AllProductCategoryDropDownDto[]>;
    getAllFirstLayerProductCategories(): Observable<ProductCategoryDto[]>;
    getProductCategoriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductCategoryDto>;
    getProductCategoriesByProductParentCategoryId(productParentCategoryId: number | null | undefined): Observable<ProductCategoryDto[]>;
    getProductCategoryById(id: number): Observable<ProductCategoryDto>;
    delete(id: number): Observable<FileResponse>;
    getProductCategoryBySlug(slug: string | undefined): Observable<ProductCategoryDto>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateProductCategoryCommand): Observable<number>;
    deleteRangeProductCategory(ids: number[]): Observable<FileResponse>;
    update(urlId: number, command: UpdateProductCategoryCommand): Observable<FileResponse>;
    isUniqueProductCategoryLocalizedName(productCategoryId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueProductCategoryName(productId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductCategoriesClient implements IProductCategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductCategories(): Observable<ProductCategoryDto[]> {
        let url_ = this.baseUrl + "/api/ProductCategories/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDto[]>;
        }));
    }

    protected processGetAllProductCategories(response: HttpResponseBase): Observable<ProductCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductCategoriesDropDown(): Observable<AllProductCategoryDropDownDto[]> {
        let url_ = this.baseUrl + "/api/ProductCategories/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCategoriesDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCategoriesDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductCategoryDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductCategoryDropDownDto[]>;
        }));
    }

    protected processGetAllProductCategoriesDropDown(response: HttpResponseBase): Observable<AllProductCategoryDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductCategoryDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFirstLayerProductCategories(): Observable<ProductCategoryDto[]> {
        let url_ = this.baseUrl + "/api/ProductCategories/allFirstLayer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFirstLayerProductCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFirstLayerProductCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDto[]>;
        }));
    }

    protected processGetAllFirstLayerProductCategories(response: HttpResponseBase): Observable<ProductCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductCategoriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductCategoryDto> {
        let url_ = this.baseUrl + "/api/ProductCategories/allWithPagination?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoriesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoriesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductCategoryDto>;
        }));
    }

    protected processGetProductCategoriesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductCategoriesByProductParentCategoryId(productParentCategoryId: number | null | undefined): Observable<ProductCategoryDto[]> {
        let url_ = this.baseUrl + "/api/ProductCategories/productParentCategory?";
        if (productParentCategoryId !== undefined && productParentCategoryId !== null)
            url_ += "ProductParentCategoryId=" + encodeURIComponent("" + productParentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoriesByProductParentCategoryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoriesByProductParentCategoryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDto[]>;
        }));
    }

    protected processGetProductCategoriesByProductParentCategoryId(response: HttpResponseBase): Observable<ProductCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductCategoryById(id: number): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/ProductCategories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDto>;
        }));
    }

    protected processGetProductCategoryById(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductCategories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductCategoryBySlug(slug: string | undefined): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/ProductCategories/slug?";
        if (slug === null)
            throw new Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "Slug=" + encodeURIComponent("" + slug) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoryBySlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoryBySlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDto>;
        }));
    }

    protected processGetProductCategoryBySlug(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductCategories/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductCategoryCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeProductCategory(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeProductCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeProductCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeProductCategory(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateProductCategoryCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductCategories/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductCategoryLocalizedName(productCategoryId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProductCategories/isUniqueLocalizedName?";
        if (productCategoryId === null)
            throw new Error("The parameter 'productCategoryId' cannot be null.");
        else if (productCategoryId !== undefined)
            url_ += "ProductCategoryId=" + encodeURIComponent("" + productCategoryId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductCategoryLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductCategoryLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductCategoryLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductCategoryName(productId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProductCategories/isUniqueName?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductCategoryName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductCategoryName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductCategoryName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFamiliesClient {
    getFamiliesWithPagination(brandId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFamilyDto>;
    create(command: CreateFamilyCommand): Observable<number>;
    deleteRangeFamily(ids: number[]): Observable<FileResponse>;
    getAllFamilies(): Observable<FamilyDto[]>;
    getFamiliesByBrandId(brandId: number): Observable<FamilyDto[]>;
    getFamilyById(id: number): Observable<FamilyDto>;
    update(id: number, command: UpdateFamilyCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueFamilyLocalizedName(familyId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueFamilyName(familyId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class FamiliesClient implements IFamiliesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getFamiliesWithPagination(brandId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFamilyDto> {
        let url_ = this.baseUrl + "/api/Families?";
        if (brandId !== undefined && brandId !== null)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFamiliesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFamiliesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfFamilyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfFamilyDto>;
        }));
    }

    protected processGetFamiliesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfFamilyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfFamilyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateFamilyCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Families";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeFamily(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Families";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeFamily(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeFamily(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeFamily(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFamilies(): Observable<FamilyDto[]> {
        let url_ = this.baseUrl + "/api/Families/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFamilies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFamilies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDto[]>;
        }));
    }

    protected processGetAllFamilies(response: HttpResponseBase): Observable<FamilyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FamilyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFamiliesByBrandId(brandId: number): Observable<FamilyDto[]> {
        let url_ = this.baseUrl + "/api/Families/brand{brandId}";
        if (brandId === undefined || brandId === null)
            throw new Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFamiliesByBrandId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFamiliesByBrandId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDto[]>;
        }));
    }

    protected processGetFamiliesByBrandId(response: HttpResponseBase): Observable<FamilyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FamilyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFamilyById(id: number): Observable<FamilyDto> {
        let url_ = this.baseUrl + "/api/Families/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFamilyById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFamilyById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDto>;
        }));
    }

    protected processGetFamilyById(response: HttpResponseBase): Observable<FamilyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateFamilyCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Families/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Families/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Families/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueFamilyLocalizedName(familyId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Families/isUniqueLocalizedName?";
        if (familyId === null)
            throw new Error("The parameter 'familyId' cannot be null.");
        else if (familyId !== undefined)
            url_ += "FamilyId=" + encodeURIComponent("" + familyId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueFamilyLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueFamilyLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueFamilyLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueFamilyName(familyId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Families/isUniqueName?";
        if (familyId === null)
            throw new Error("The parameter 'familyId' cannot be null.");
        else if (familyId !== undefined)
            url_ += "FamilyId=" + encodeURIComponent("" + familyId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueFamilyName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueFamilyName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueFamilyName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IKindsClient {
    getKindsWithPagination(modelId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfKindDto>;
    create(command: CreateKindCommand): Observable<number>;
    deleteRangeKinds(ids: number[]): Observable<FileResponse>;
    getAllKinds(): Observable<KindDto[]>;
    getAllKindsDropDown(): Observable<AllKindDropDownDto[]>;
    getKindById(id: number): Observable<KindDto>;
    update(id: number, command: UpdateKindCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getKindsWithModelId(modelId: number): Observable<KindDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueKindLocalizedName(kindId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueKindName(kindId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class KindsClient implements IKindsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getKindsWithPagination(modelId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfKindDto> {
        let url_ = this.baseUrl + "/api/Kinds?";
        if (modelId !== undefined && modelId !== null)
            url_ += "ModelId=" + encodeURIComponent("" + modelId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKindsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKindsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfKindDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfKindDto>;
        }));
    }

    protected processGetKindsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfKindDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfKindDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateKindCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Kinds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeKinds(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Kinds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeKinds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeKinds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeKinds(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllKinds(): Observable<KindDto[]> {
        let url_ = this.baseUrl + "/api/Kinds/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKinds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKinds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KindDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KindDto[]>;
        }));
    }

    protected processGetAllKinds(response: HttpResponseBase): Observable<KindDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KindDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllKindsDropDown(): Observable<AllKindDropDownDto[]> {
        let url_ = this.baseUrl + "/api/Kinds/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKindsDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKindsDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllKindDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllKindDropDownDto[]>;
        }));
    }

    protected processGetAllKindsDropDown(response: HttpResponseBase): Observable<AllKindDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllKindDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getKindById(id: number): Observable<KindDto> {
        let url_ = this.baseUrl + "/api/Kinds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKindById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKindById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KindDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KindDto>;
        }));
    }

    protected processGetKindById(response: HttpResponseBase): Observable<KindDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KindDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateKindCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Kinds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Kinds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getKindsWithModelId(modelId: number): Observable<KindDto[]> {
        let url_ = this.baseUrl + "/api/Kinds/model{modelId}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKindsWithModelId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKindsWithModelId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KindDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KindDto[]>;
        }));
    }

    protected processGetKindsWithModelId(response: HttpResponseBase): Observable<KindDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KindDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Kinds/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueKindLocalizedName(kindId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Kinds/isUniqueLocalizedName?";
        if (kindId === null)
            throw new Error("The parameter 'kindId' cannot be null.");
        else if (kindId !== undefined)
            url_ += "KindId=" + encodeURIComponent("" + kindId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueKindLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueKindLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueKindLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueKindName(kindId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Kinds/isUniqueName?";
        if (kindId === null)
            throw new Error("The parameter 'kindId' cannot be null.");
        else if (kindId !== undefined)
            url_ += "KindId=" + encodeURIComponent("" + kindId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueKindName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueKindName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueKindName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IModelsClient {
    getModelsWithPagination(familyId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfModelDto>;
    create(command: CreateModelCommand): Observable<number>;
    deleteRangeModel(ids: number[]): Observable<FileResponse>;
    getAllModels(): Observable<ModelDto[]>;
    getModelsWithFamilyId(familyId: number): Observable<ModelDto[]>;
    getModelById(id: number): Observable<ModelDto>;
    update(id: number, command: UpdateModelCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueModelLocalizedName(modelId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueModelName(modelId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ModelsClient implements IModelsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getModelsWithPagination(familyId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfModelDto> {
        let url_ = this.baseUrl + "/api/Models?";
        if (familyId !== undefined && familyId !== null)
            url_ += "FamilyId=" + encodeURIComponent("" + familyId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModelsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModelsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfModelDto>;
        }));
    }

    protected processGetModelsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateModelCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Models";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeModel(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Models";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeModel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeModel(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllModels(): Observable<ModelDto[]> {
        let url_ = this.baseUrl + "/api/Models/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllModels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllModels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModelDto[]>;
        }));
    }

    protected processGetAllModels(response: HttpResponseBase): Observable<ModelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getModelsWithFamilyId(familyId: number): Observable<ModelDto[]> {
        let url_ = this.baseUrl + "/api/Models/family{familyId}";
        if (familyId === undefined || familyId === null)
            throw new Error("The parameter 'familyId' must be defined.");
        url_ = url_.replace("{familyId}", encodeURIComponent("" + familyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModelsWithFamilyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModelsWithFamilyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModelDto[]>;
        }));
    }

    protected processGetModelsWithFamilyId(response: HttpResponseBase): Observable<ModelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getModelById(id: number): Observable<ModelDto> {
        let url_ = this.baseUrl + "/api/Models/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModelById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModelById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModelDto>;
        }));
    }

    protected processGetModelById(response: HttpResponseBase): Observable<ModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateModelCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Models/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Models/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Models/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueModelLocalizedName(modelId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Models/isUniqueLocalizedName?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "ModelId=" + encodeURIComponent("" + modelId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueModelLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueModelLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueModelLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueModelName(modelId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Models/isUniqueName?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "ModelId=" + encodeURIComponent("" + modelId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueModelName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueModelName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueModelName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductBrandsClient {
    getAllProductBrands(): Observable<ProductBrandDto[]>;
    getAllProductBrandsDropDown(): Observable<AllProductBrandDropDownDto[]>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    getProductBrandById(id: number): Observable<ProductBrandDto>;
    delete(id: number): Observable<FileResponse>;
    create(command: CreateProductBrandCommand): Observable<number>;
    deleteRangeProductBrand(ids: number[]): Observable<FileResponse>;
    update(urlId: number, command: UpdateProductBrandCommand): Observable<FileResponse>;
    isUniqueProductBrandLocalizedName(productBrandId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueProductBrandName(productBrandId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductBrandsClient implements IProductBrandsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductBrands(): Observable<ProductBrandDto[]> {
        let url_ = this.baseUrl + "/api/ProductBrands/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductBrandDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductBrandDto[]>;
        }));
    }

    protected processGetAllProductBrands(response: HttpResponseBase): Observable<ProductBrandDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductBrandDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductBrandsDropDown(): Observable<AllProductBrandDropDownDto[]> {
        let url_ = this.baseUrl + "/api/ProductBrands/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductBrandsDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductBrandsDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductBrandDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductBrandDropDownDto[]>;
        }));
    }

    protected processGetAllProductBrandsDropDown(response: HttpResponseBase): Observable<AllProductBrandDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductBrandDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductBrands/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductBrandById(id: number): Observable<ProductBrandDto> {
        let url_ = this.baseUrl + "/api/ProductBrands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductBrandById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductBrandById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductBrandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductBrandDto>;
        }));
    }

    protected processGetProductBrandById(response: HttpResponseBase): Observable<ProductBrandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductBrandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductBrands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductBrandCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductBrands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeProductBrand(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductBrands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeProductBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeProductBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeProductBrand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateProductBrandCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductBrands/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductBrandLocalizedName(productBrandId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProductBrands/isUniqueLocalizedName?";
        if (productBrandId === null)
            throw new Error("The parameter 'productBrandId' cannot be null.");
        else if (productBrandId !== undefined)
            url_ += "ProductBrandId=" + encodeURIComponent("" + productBrandId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductBrandLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductBrandLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductBrandLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueProductBrandName(productBrandId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProductBrands/isUniqueName?";
        if (productBrandId === null)
            throw new Error("The parameter 'productBrandId' cannot be null.");
        else if (productBrandId !== undefined)
            url_ += "ProductBrandId=" + encodeURIComponent("" + productBrandId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueProductBrandName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueProductBrandName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueProductBrandName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVehicleBrandsClient {
    getAllVehicleBrands(): Observable<VehicleBrandDto[]>;
    getAllVehicleBrandsDropDown(): Observable<AllVehicleBrandDropDownDto[]>;
    getVehicleBrandById(id: number): Observable<VehicleBrandDto>;
    delete(id: number): Observable<FileResponse>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    create(command: CreateVehicleBrandCommand): Observable<number>;
    deleteRangeVehicleBrand(ids: number[]): Observable<FileResponse>;
    update(urlId: number, command: UpdateVehicleBrandCommand): Observable<FileResponse>;
    isUniqueVehicleBrandLocalizedName(vehicleBrandId: number | undefined, localizedName: string | undefined): Observable<boolean>;
    isUniqueVehicleBrandName(vehicleBrandId: number | undefined, name: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class VehicleBrandsClient implements IVehicleBrandsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllVehicleBrands(): Observable<VehicleBrandDto[]> {
        let url_ = this.baseUrl + "/api/VehicleBrands/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVehicleBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVehicleBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleBrandDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleBrandDto[]>;
        }));
    }

    protected processGetAllVehicleBrands(response: HttpResponseBase): Observable<VehicleBrandDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleBrandDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllVehicleBrandsDropDown(): Observable<AllVehicleBrandDropDownDto[]> {
        let url_ = this.baseUrl + "/api/VehicleBrands/allDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVehicleBrandsDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVehicleBrandsDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllVehicleBrandDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllVehicleBrandDropDownDto[]>;
        }));
    }

    protected processGetAllVehicleBrandsDropDown(response: HttpResponseBase): Observable<AllVehicleBrandDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllVehicleBrandDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehicleBrandById(id: number): Observable<VehicleBrandDto> {
        let url_ = this.baseUrl + "/api/VehicleBrands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleBrandById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleBrandById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleBrandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleBrandDto>;
        }));
    }

    protected processGetVehicleBrandById(response: HttpResponseBase): Observable<VehicleBrandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleBrandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/VehicleBrands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/VehicleBrands/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateVehicleBrandCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/VehicleBrands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeVehicleBrand(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/VehicleBrands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeVehicleBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeVehicleBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeVehicleBrand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: number, command: UpdateVehicleBrandCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/VehicleBrands/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueVehicleBrandLocalizedName(vehicleBrandId: number | undefined, localizedName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/VehicleBrands/isUniqueLocalizedName?";
        if (vehicleBrandId === null)
            throw new Error("The parameter 'vehicleBrandId' cannot be null.");
        else if (vehicleBrandId !== undefined)
            url_ += "VehicleBrandId=" + encodeURIComponent("" + vehicleBrandId) + "&";
        if (localizedName === null)
            throw new Error("The parameter 'localizedName' cannot be null.");
        else if (localizedName !== undefined)
            url_ += "LocalizedName=" + encodeURIComponent("" + localizedName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueVehicleBrandLocalizedName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueVehicleBrandLocalizedName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueVehicleBrandLocalizedName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueVehicleBrandName(vehicleBrandId: number | undefined, name: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/VehicleBrands/isUniqueName?";
        if (vehicleBrandId === null)
            throw new Error("The parameter 'vehicleBrandId' cannot be null.");
        else if (vehicleBrandId !== undefined)
            url_ += "VehicleBrandId=" + encodeURIComponent("" + vehicleBrandId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueVehicleBrandName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueVehicleBrandName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueVehicleBrandName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVehiclesClient {
    getVehiclesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfVehicleByIdDto>;
    create(command: CreateVehicleCommand): Observable<number>;
    deleteRangeVehicle(ids: number[]): Observable<FileResponse>;
    getAllVehicles(): Observable<VehicleDto[]>;
    getVehicleById(id: number): Observable<VehicleByIdDto>;
    update(id: number, command: UpdateVehicleCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getVehiclesByCustomerId(customerId: string): Observable<VehicleByIdDto[]>;
    getVehiclesByKindId(kindId: number): Observable<VehicleByIdDto[]>;
    getVehicleByVinNumber(vinNumber: string): Observable<VehicleForVinDto>;
    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse>;
    isUniqueVehicleKindId(vehicleId: number | undefined, kindId: number | undefined): Observable<boolean>;
    isUniqueVehicleVinNumber(vehicleId: number | undefined, vinNumber: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class VehiclesClient implements IVehiclesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getVehiclesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfVehicleByIdDto> {
        let url_ = this.baseUrl + "/api/Vehicles?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehiclesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehiclesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfVehicleByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfVehicleByIdDto>;
        }));
    }

    protected processGetVehiclesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfVehicleByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfVehicleByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateVehicleCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Vehicles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeVehicle(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Vehicles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeVehicle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeVehicle(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllVehicles(): Observable<VehicleDto[]> {
        let url_ = this.baseUrl + "/api/Vehicles/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVehicles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVehicles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleDto[]>;
        }));
    }

    protected processGetAllVehicles(response: HttpResponseBase): Observable<VehicleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehicleById(id: number): Observable<VehicleByIdDto> {
        let url_ = this.baseUrl + "/api/Vehicles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleByIdDto>;
        }));
    }

    protected processGetVehicleById(response: HttpResponseBase): Observable<VehicleByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateVehicleCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Vehicles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Vehicles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehiclesByCustomerId(customerId: string): Observable<VehicleByIdDto[]> {
        let url_ = this.baseUrl + "/api/Vehicles/customer{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehiclesByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehiclesByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleByIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleByIdDto[]>;
        }));
    }

    protected processGetVehiclesByCustomerId(response: HttpResponseBase): Observable<VehicleByIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleByIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehiclesByKindId(kindId: number): Observable<VehicleByIdDto[]> {
        let url_ = this.baseUrl + "/api/Vehicles/kind{kindId}";
        if (kindId === undefined || kindId === null)
            throw new Error("The parameter 'kindId' must be defined.");
        url_ = url_.replace("{kindId}", encodeURIComponent("" + kindId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehiclesByKindId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehiclesByKindId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleByIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleByIdDto[]>;
        }));
    }

    protected processGetVehiclesByKindId(response: HttpResponseBase): Observable<VehicleByIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleByIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehicleByVinNumber(vinNumber: string): Observable<VehicleForVinDto> {
        let url_ = this.baseUrl + "/api/Vehicles/vin{vinNumber}";
        if (vinNumber === undefined || vinNumber === null)
            throw new Error("The parameter 'vinNumber' must be defined.");
        url_ = url_.replace("{vinNumber}", encodeURIComponent("" + vinNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleByVinNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleByVinNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleForVinDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleForVinDto>;
        }));
    }

    protected processGetVehicleByVinNumber(response: HttpResponseBase): Observable<VehicleForVinDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleForVinDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelQuery(searchText: string | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, startCreationDate: Date | null | undefined, endCreationDate: Date | null | undefined, startChangeDate: Date | null | undefined, endChangeDate: Date | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Vehicles/exportExcel?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (startCreationDate !== undefined && startCreationDate !== null)
            url_ += "StartCreationDate=" + encodeURIComponent(startCreationDate ? "" + startCreationDate.toISOString() : "") + "&";
        if (endCreationDate !== undefined && endCreationDate !== null)
            url_ += "EndCreationDate=" + encodeURIComponent(endCreationDate ? "" + endCreationDate.toISOString() : "") + "&";
        if (startChangeDate !== undefined && startChangeDate !== null)
            url_ += "StartChangeDate=" + encodeURIComponent(startChangeDate ? "" + startChangeDate.toISOString() : "") + "&";
        if (endChangeDate !== undefined && endChangeDate !== null)
            url_ += "EndChangeDate=" + encodeURIComponent(endChangeDate ? "" + endChangeDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExportExcelQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueVehicleKindId(vehicleId: number | undefined, kindId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Vehicles/isUniqueVehicleKindId?";
        if (vehicleId === null)
            throw new Error("The parameter 'vehicleId' cannot be null.");
        else if (vehicleId !== undefined)
            url_ += "VehicleId=" + encodeURIComponent("" + vehicleId) + "&";
        if (kindId === null)
            throw new Error("The parameter 'kindId' cannot be null.");
        else if (kindId !== undefined)
            url_ += "KindId=" + encodeURIComponent("" + kindId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueVehicleKindId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueVehicleKindId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueVehicleKindId(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueVehicleVinNumber(vehicleId: number | undefined, vinNumber: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Vehicles/isUniqueVehicleVinNumber?";
        if (vehicleId === null)
            throw new Error("The parameter 'vehicleId' cannot be null.");
        else if (vehicleId !== undefined)
            url_ += "VehicleId=" + encodeURIComponent("" + vehicleId) + "&";
        if (vinNumber === null)
            throw new Error("The parameter 'vinNumber' cannot be null.");
        else if (vinNumber !== undefined)
            url_ += "VinNumber=" + encodeURIComponent("" + vinNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueVehicleVinNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueVehicleVinNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueVehicleVinNumber(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICommentsClient {
    getCommentsByParentCommentId(parentCommentId: number): Observable<CommentDto[]>;
    getCommentsByPostId(postId: number): Observable<CommentDto[]>;
    getCommentsByCustomerId(customerId: string): Observable<CommentDto[]>;
    getCommentById(id: number): Observable<CommentDto>;
    update(id: number, command: UpdateCommentCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    create(command: CreateCommentCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class CommentsClient implements ICommentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCommentsByParentCommentId(parentCommentId: number): Observable<CommentDto[]> {
        let url_ = this.baseUrl + "/api/Comments/parentComment{parentCommentId}";
        if (parentCommentId === undefined || parentCommentId === null)
            throw new Error("The parameter 'parentCommentId' must be defined.");
        url_ = url_.replace("{parentCommentId}", encodeURIComponent("" + parentCommentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommentsByParentCommentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommentsByParentCommentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto[]>;
        }));
    }

    protected processGetCommentsByParentCommentId(response: HttpResponseBase): Observable<CommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCommentsByPostId(postId: number): Observable<CommentDto[]> {
        let url_ = this.baseUrl + "/api/Comments/post{postId}";
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommentsByPostId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommentsByPostId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto[]>;
        }));
    }

    protected processGetCommentsByPostId(response: HttpResponseBase): Observable<CommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCommentsByCustomerId(customerId: string): Observable<CommentDto[]> {
        let url_ = this.baseUrl + "/api/Comments/customer{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommentsByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommentsByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto[]>;
        }));
    }

    protected processGetCommentsByCustomerId(response: HttpResponseBase): Observable<CommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCommentById(id: number): Observable<CommentDto> {
        let url_ = this.baseUrl + "/api/Comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommentById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto>;
        }));
    }

    protected processGetCommentById(response: HttpResponseBase): Observable<CommentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCommentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCommentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Comments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPostsClient {
    getPostsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfPostDto>;
    create(title: string | undefined, body: string | undefined, blogCategoryId: number | undefined, authorId: string | undefined, isActive: boolean | undefined, image: FileParameter | null | undefined): Observable<number>;
    getAllPosts(): Observable<PostDto[]>;
    getPostsByBlogSubCategoryId(blogSubCategoryId: number): Observable<PostDto[]>;
    getPostsByUserId(userId: string): Observable<PostDto[]>;
    getPostById(id: number): Observable<PostDto>;
    update(id: number, title: string | undefined, body: string | undefined, blogCategoryId: number | undefined, isActive: boolean | undefined, image: FileParameter | null | undefined): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    selfUpdate(id: number, title: string | undefined, body: string | undefined, blogCategoryId: number | undefined, isActive: boolean | undefined, image: FileParameter | null | undefined): Observable<FileResponse>;
    selfDelete(id: number): Observable<FileResponse>;
    isUniquePostTitle(postId: number | undefined, title: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class PostsClient implements IPostsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getPostsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfPostDto> {
        let url_ = this.baseUrl + "/api/Posts?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfPostDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfPostDto>;
        }));
    }

    protected processGetPostsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfPostDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfPostDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(title: string | undefined, body: string | undefined, blogCategoryId: number | undefined, authorId: string | undefined, isActive: boolean | undefined, image: FileParameter | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Posts?";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (body === null)
            throw new Error("The parameter 'body' cannot be null.");
        else if (body !== undefined)
            url_ += "Body=" + encodeURIComponent("" + body) + "&";
        if (blogCategoryId === null)
            throw new Error("The parameter 'blogCategoryId' cannot be null.");
        else if (blogCategoryId !== undefined)
            url_ += "BlogCategoryId=" + encodeURIComponent("" + blogCategoryId) + "&";
        if (authorId === null)
            throw new Error("The parameter 'authorId' cannot be null.");
        else if (authorId !== undefined)
            url_ += "AuthorId=" + encodeURIComponent("" + authorId) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (image !== null && image !== undefined)
            content_.append("Image", image.data, image.fileName ? image.fileName : "Image");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllPosts(): Observable<PostDto[]> {
        let url_ = this.baseUrl + "/api/Posts/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostDto[]>;
        }));
    }

    protected processGetAllPosts(response: HttpResponseBase): Observable<PostDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPostsByBlogSubCategoryId(blogSubCategoryId: number): Observable<PostDto[]> {
        let url_ = this.baseUrl + "/api/Posts/blogSubCategory{blogSubCategoryId}";
        if (blogSubCategoryId === undefined || blogSubCategoryId === null)
            throw new Error("The parameter 'blogSubCategoryId' must be defined.");
        url_ = url_.replace("{blogSubCategoryId}", encodeURIComponent("" + blogSubCategoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostsByBlogSubCategoryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostsByBlogSubCategoryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostDto[]>;
        }));
    }

    protected processGetPostsByBlogSubCategoryId(response: HttpResponseBase): Observable<PostDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPostsByUserId(userId: string): Observable<PostDto[]> {
        let url_ = this.baseUrl + "/api/Posts/user{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostsByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostsByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostDto[]>;
        }));
    }

    protected processGetPostsByUserId(response: HttpResponseBase): Observable<PostDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPostById(id: number): Observable<PostDto> {
        let url_ = this.baseUrl + "/api/Posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostDto>;
        }));
    }

    protected processGetPostById(response: HttpResponseBase): Observable<PostDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, title: string | undefined, body: string | undefined, blogCategoryId: number | undefined, isActive: boolean | undefined, image: FileParameter | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Posts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (body === null)
            throw new Error("The parameter 'body' cannot be null.");
        else if (body !== undefined)
            url_ += "Body=" + encodeURIComponent("" + body) + "&";
        if (blogCategoryId === null)
            throw new Error("The parameter 'blogCategoryId' cannot be null.");
        else if (blogCategoryId !== undefined)
            url_ += "BlogCategoryId=" + encodeURIComponent("" + blogCategoryId) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (image !== null && image !== undefined)
            content_.append("Image", image.data, image.fileName ? image.fileName : "Image");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfUpdate(id: number, title: string | undefined, body: string | undefined, blogCategoryId: number | undefined, isActive: boolean | undefined, image: FileParameter | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Posts/self{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (body === null)
            throw new Error("The parameter 'body' cannot be null.");
        else if (body !== undefined)
            url_ += "Body=" + encodeURIComponent("" + body) + "&";
        if (blogCategoryId === null)
            throw new Error("The parameter 'blogCategoryId' cannot be null.");
        else if (blogCategoryId !== undefined)
            url_ += "BlogCategoryId=" + encodeURIComponent("" + blogCategoryId) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (image !== null && image !== undefined)
            content_.append("Image", image.data, image.fileName ? image.fileName : "Image");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSelfUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfDelete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Posts/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSelfDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniquePostTitle(postId: number | undefined, title: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Posts/isUniqueTitle?";
        if (postId === null)
            throw new Error("The parameter 'postId' cannot be null.");
        else if (postId !== undefined)
            url_ += "PostId=" + encodeURIComponent("" + postId) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniquePostTitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniquePostTitle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniquePostTitle(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWidgetCommentsClient {
    getWidgetCommentsByCustomerId(customerId: string): Observable<WidgetCommentDto[]>;
    getWidgetCommentById(id: number): Observable<WidgetCommentDto>;
    update(id: number, command: UpdateWidgetCommentCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    create(command: CreateCommentCommand): Observable<number>;
    selfGetWidgetCommentsByCustomerId(): Observable<WidgetCommentDto[]>;
    selfUpdate(id: number, command: UpdateWidgetCommentCommand): Observable<FileResponse>;
    selfDelete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class WidgetCommentsClient implements IWidgetCommentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getWidgetCommentsByCustomerId(customerId: string): Observable<WidgetCommentDto[]> {
        let url_ = this.baseUrl + "/api/WidgetComments/customer{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWidgetCommentsByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidgetCommentsByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetCommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetCommentDto[]>;
        }));
    }

    protected processGetWidgetCommentsByCustomerId(response: HttpResponseBase): Observable<WidgetCommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetCommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWidgetCommentById(id: number): Observable<WidgetCommentDto> {
        let url_ = this.baseUrl + "/api/WidgetComments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWidgetCommentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidgetCommentById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetCommentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetCommentDto>;
        }));
    }

    protected processGetWidgetCommentById(response: HttpResponseBase): Observable<WidgetCommentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WidgetCommentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateWidgetCommentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WidgetComments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WidgetComments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCommentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/WidgetComments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfGetWidgetCommentsByCustomerId(): Observable<WidgetCommentDto[]> {
        let url_ = this.baseUrl + "/api/WidgetComments/selfCustomer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfGetWidgetCommentsByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfGetWidgetCommentsByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetCommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetCommentDto[]>;
        }));
    }

    protected processSelfGetWidgetCommentsByCustomerId(response: HttpResponseBase): Observable<WidgetCommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetCommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfUpdate(id: number, command: UpdateWidgetCommentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WidgetComments/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSelfUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfDelete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WidgetComments/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSelfDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AddressDto implements IAddressDto {
    id?: number;
    title?: string;
    company?: string | undefined;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    countryId?: number | undefined;
    countryName?: string | undefined;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.company = _data["company"];
            this.addressDetails1 = _data["addressDetails1"];
            this.addressDetails2 = _data["addressDetails2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postcode = _data["postcode"];
            this.default = _data["default"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["company"] = this.company;
        data["addressDetails1"] = this.addressDetails1;
        data["addressDetails2"] = this.addressDetails2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postcode"] = this.postcode;
        data["default"] = this.default;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IAddressDto {
    id?: number;
    title?: string;
    company?: string | undefined;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    countryId?: number | undefined;
    countryName?: string | undefined;
}

export class CreateAddressCommand implements ICreateAddressCommand {
    title?: string;
    company?: string | undefined;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    customerId?: string;

    constructor(data?: ICreateAddressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.company = _data["company"];
            this.countryId = _data["countryId"];
            this.addressDetails1 = _data["addressDetails1"];
            this.addressDetails2 = _data["addressDetails2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postcode = _data["postcode"];
            this.default = _data["default"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): CreateAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["company"] = this.company;
        data["countryId"] = this.countryId;
        data["addressDetails1"] = this.addressDetails1;
        data["addressDetails2"] = this.addressDetails2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postcode"] = this.postcode;
        data["default"] = this.default;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface ICreateAddressCommand {
    title?: string;
    company?: string | undefined;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    customerId?: string;
}

export class UpdateAddressCommand implements IUpdateAddressCommand {
    id?: number;
    title?: string;
    company?: string | undefined;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    customerId?: string;

    constructor(data?: IUpdateAddressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.company = _data["company"];
            this.countryId = _data["countryId"];
            this.addressDetails1 = _data["addressDetails1"];
            this.addressDetails2 = _data["addressDetails2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postcode = _data["postcode"];
            this.default = _data["default"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): UpdateAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["company"] = this.company;
        data["countryId"] = this.countryId;
        data["addressDetails1"] = this.addressDetails1;
        data["addressDetails2"] = this.addressDetails2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postcode"] = this.postcode;
        data["default"] = this.default;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IUpdateAddressCommand {
    id?: number;
    title?: string;
    company?: string | undefined;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    customerId?: string;
}

export class FilteredCreditDto implements IFilteredCreditDto {
    credits?: CreditDto[];
    count?: number;

    constructor(data?: IFilteredCreditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["credits"])) {
                this.credits = [] as any;
                for (let item of _data["credits"])
                    this.credits!.push(CreditDto.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): FilteredCreditDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredCreditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.credits)) {
            data["credits"] = [];
            for (let item of this.credits)
                data["credits"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IFilteredCreditDto {
    credits?: CreditDto[];
    count?: number;
}

export class CreditDto implements ICreditDto {
    id?: number;
    date?: string;
    value?: number;
    modifierUserName?: string;
    modifierUserId?: string;
    orderToken?: string | undefined;

    constructor(data?: ICreditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"];
            this.value = _data["value"];
            this.modifierUserName = _data["modifierUserName"];
            this.modifierUserId = _data["modifierUserId"];
            this.orderToken = _data["orderToken"];
        }
    }

    static fromJS(data: any): CreditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date;
        data["value"] = this.value;
        data["modifierUserName"] = this.modifierUserName;
        data["modifierUserId"] = this.modifierUserId;
        data["orderToken"] = this.orderToken;
        return data;
    }
}

export interface ICreditDto {
    id?: number;
    date?: string;
    value?: number;
    modifierUserName?: string;
    modifierUserId?: string;
    orderToken?: string | undefined;
}

export class FilteredMaxCreditDto implements IFilteredMaxCreditDto {
    maxCredits?: MaxCreditDto[];
    count?: number;

    constructor(data?: IFilteredMaxCreditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["maxCredits"])) {
                this.maxCredits = [] as any;
                for (let item of _data["maxCredits"])
                    this.maxCredits!.push(MaxCreditDto.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): FilteredMaxCreditDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredMaxCreditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.maxCredits)) {
            data["maxCredits"] = [];
            for (let item of this.maxCredits)
                data["maxCredits"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IFilteredMaxCreditDto {
    maxCredits?: MaxCreditDto[];
    count?: number;
}

export class MaxCreditDto implements IMaxCreditDto {
    id?: number;
    date?: string;
    value?: number;
    modifierUserName?: string;
    modifierUserId?: string;

    constructor(data?: IMaxCreditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"];
            this.value = _data["value"];
            this.modifierUserName = _data["modifierUserName"];
            this.modifierUserId = _data["modifierUserId"];
        }
    }

    static fromJS(data: any): MaxCreditDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaxCreditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date;
        data["value"] = this.value;
        data["modifierUserName"] = this.modifierUserName;
        data["modifierUserId"] = this.modifierUserId;
        return data;
    }
}

export interface IMaxCreditDto {
    id?: number;
    date?: string;
    value?: number;
    modifierUserName?: string;
    modifierUserId?: string;
}

export class CustomerDto implements ICustomerDto {
    id?: string;
    avatar?: string | undefined;
    credits?: CreditDto2[];
    maxCredits?: MaxCreditDto2[];

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
            if (Array.isArray(_data["credits"])) {
                this.credits = [] as any;
                for (let item of _data["credits"])
                    this.credits!.push(CreditDto2.fromJS(item));
            }
            if (Array.isArray(_data["maxCredits"])) {
                this.maxCredits = [] as any;
                for (let item of _data["maxCredits"])
                    this.maxCredits!.push(MaxCreditDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        if (Array.isArray(this.credits)) {
            data["credits"] = [];
            for (let item of this.credits)
                data["credits"].push(item.toJSON());
        }
        if (Array.isArray(this.maxCredits)) {
            data["maxCredits"] = [];
            for (let item of this.maxCredits)
                data["maxCredits"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomerDto {
    id?: string;
    avatar?: string | undefined;
    credits?: CreditDto2[];
    maxCredits?: MaxCreditDto2[];
}

export class CreditDto2 implements ICreditDto2 {
    id?: number;
    date?: string;
    value?: number;
    modifierUserName?: string;
    modifierUserId?: string;
    orderToken?: string | undefined;

    constructor(data?: ICreditDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"];
            this.value = _data["value"];
            this.modifierUserName = _data["modifierUserName"];
            this.modifierUserId = _data["modifierUserId"];
            this.orderToken = _data["orderToken"];
        }
    }

    static fromJS(data: any): CreditDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new CreditDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date;
        data["value"] = this.value;
        data["modifierUserName"] = this.modifierUserName;
        data["modifierUserId"] = this.modifierUserId;
        data["orderToken"] = this.orderToken;
        return data;
    }
}

export interface ICreditDto2 {
    id?: number;
    date?: string;
    value?: number;
    modifierUserName?: string;
    modifierUserId?: string;
    orderToken?: string | undefined;
}

export class MaxCreditDto2 implements IMaxCreditDto2 {
    id?: number;
    date?: string;
    value?: number;
    modifierUserName?: string;
    modifierUserId?: string;

    constructor(data?: IMaxCreditDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"];
            this.value = _data["value"];
            this.modifierUserName = _data["modifierUserName"];
            this.modifierUserId = _data["modifierUserId"];
        }
    }

    static fromJS(data: any): MaxCreditDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new MaxCreditDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date;
        data["value"] = this.value;
        data["modifierUserName"] = this.modifierUserName;
        data["modifierUserId"] = this.modifierUserId;
        return data;
    }
}

export interface IMaxCreditDto2 {
    id?: number;
    date?: string;
    value?: number;
    modifierUserName?: string;
    modifierUserId?: string;
}

export class CreateCustomerCommand implements ICreateCustomerCommand {
    id?: string;
    avatar?: string | undefined;

    constructor(data?: ICreateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CreateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICreateCustomerCommand {
    id?: string;
    avatar?: string | undefined;
}

export class UpdateCustomerCommand implements IUpdateCustomerCommand {
    id?: string;
    avatar?: string | undefined;

    constructor(data?: IUpdateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): UpdateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface IUpdateCustomerCommand {
    id?: string;
    avatar?: string | undefined;
}

export class SetCustomerCreditCommand implements ISetCustomerCreditCommand {
    id?: string;
    credit?: number;
    modifierUserName?: string;
    modifierUserId?: string;

    constructor(data?: ISetCustomerCreditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.credit = _data["credit"];
            this.modifierUserName = _data["modifierUserName"];
            this.modifierUserId = _data["modifierUserId"];
        }
    }

    static fromJS(data: any): SetCustomerCreditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetCustomerCreditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["credit"] = this.credit;
        data["modifierUserName"] = this.modifierUserName;
        data["modifierUserId"] = this.modifierUserId;
        return data;
    }
}

export interface ISetCustomerCreditCommand {
    id?: string;
    credit?: number;
    modifierUserName?: string;
    modifierUserId?: string;
}

export class SetCustomerMaxCreditCommand implements ISetCustomerMaxCreditCommand {
    id?: string;
    maxCredit?: number;
    modifierUserName?: string;
    modifierUserId?: string;

    constructor(data?: ISetCustomerMaxCreditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.maxCredit = _data["maxCredit"];
            this.modifierUserName = _data["modifierUserName"];
            this.modifierUserId = _data["modifierUserId"];
        }
    }

    static fromJS(data: any): SetCustomerMaxCreditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetCustomerMaxCreditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["maxCredit"] = this.maxCredit;
        data["modifierUserName"] = this.modifierUserName;
        data["modifierUserId"] = this.modifierUserId;
        return data;
    }
}

export interface ISetCustomerMaxCreditCommand {
    id?: string;
    maxCredit?: number;
    modifierUserName?: string;
    modifierUserId?: string;
}

export class AddVehicleToCustomerCommand implements IAddVehicleToCustomerCommand {
    customerId?: string;
    vehicleId?: number;
    kindId?: number;

    constructor(data?: IAddVehicleToCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.vehicleId = _data["vehicleId"];
            this.kindId = _data["kindId"];
        }
    }

    static fromJS(data: any): AddVehicleToCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddVehicleToCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["vehicleId"] = this.vehicleId;
        data["kindId"] = this.kindId;
        return data;
    }
}

export interface IAddVehicleToCustomerCommand {
    customerId?: string;
    vehicleId?: number;
    kindId?: number;
}

export class CustomerTypeDto implements ICustomerTypeDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    customerTypeEnumName?: string;
    discountPercent?: number;

    constructor(data?: ICustomerTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.customerTypeEnumName = _data["customerTypeEnumName"];
            this.discountPercent = _data["discountPercent"];
        }
    }

    static fromJS(data: any): CustomerTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["customerTypeEnumName"] = this.customerTypeEnumName;
        data["discountPercent"] = this.discountPercent;
        return data;
    }
}

export interface ICustomerTypeDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    customerTypeEnumName?: string;
    discountPercent?: number;
}

/** نوع مشتری */
export enum CustomerTypeEnum {
    Personal = 1,
    Store = 2,
    Agency = 3,
    CentralRepairShop = 4,
}

export class CreateCustomerTypeCommand implements ICreateCustomerTypeCommand {
    customerTypeEnum?: number;
    discountPercent?: number;

    constructor(data?: ICreateCustomerTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.discountPercent = _data["discountPercent"];
        }
    }

    static fromJS(data: any): CreateCustomerTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["discountPercent"] = this.discountPercent;
        return data;
    }
}

export interface ICreateCustomerTypeCommand {
    customerTypeEnum?: number;
    discountPercent?: number;
}

export class UpdateCustomerTypeCommand implements IUpdateCustomerTypeCommand {
    id?: number;
    customerTypeEnum?: number;
    discountPercent?: number;

    constructor(data?: IUpdateCustomerTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.discountPercent = _data["discountPercent"];
        }
    }

    static fromJS(data: any): UpdateCustomerTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["discountPercent"] = this.discountPercent;
        return data;
    }
}

export interface IUpdateCustomerTypeCommand {
    id?: number;
    customerTypeEnum?: number;
    discountPercent?: number;
}

export class UserDto implements IUserDto {
    id?: string;
    avatar?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface IUserDto {
    id?: string;
    avatar?: string | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
    id?: string;
    avatar?: string | undefined;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICreateUserCommand {
    id?: string;
    avatar?: string | undefined;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    id?: string;
    avatar?: string | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface IUpdateUserCommand {
    id?: string;
    avatar?: string | undefined;
}

export class UpdateSevenPricesCommand implements IUpdateSevenPricesCommand {
    priceCommands?: UpdateSevenPriceCommand[];

    constructor(data?: IUpdateSevenPricesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priceCommands"])) {
                this.priceCommands = [] as any;
                for (let item of _data["priceCommands"])
                    this.priceCommands!.push(UpdateSevenPriceCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateSevenPricesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSevenPricesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priceCommands)) {
            data["priceCommands"] = [];
            for (let item of this.priceCommands)
                data["priceCommands"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateSevenPricesCommand {
    priceCommands?: UpdateSevenPriceCommand[];
}

export class UpdateSevenPriceCommand implements IUpdateSevenPriceCommand {
    related7SoftProductId?: string;
    price?: number;

    constructor(data?: IUpdateSevenPriceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.related7SoftProductId = _data["related7SoftProductId"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): UpdateSevenPriceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSevenPriceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["related7SoftProductId"] = this.related7SoftProductId;
        data["price"] = this.price;
        return data;
    }
}

export interface IUpdateSevenPriceCommand {
    related7SoftProductId?: string;
    price?: number;
}

export class UpdateSevenCountsAndPricesCommand implements IUpdateSevenCountsAndPricesCommand {
    countAndPriceCommands?: UpdateSevenCountAndPriceCommand[];

    constructor(data?: IUpdateSevenCountsAndPricesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["countAndPriceCommands"])) {
                this.countAndPriceCommands = [] as any;
                for (let item of _data["countAndPriceCommands"])
                    this.countAndPriceCommands!.push(UpdateSevenCountAndPriceCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateSevenCountsAndPricesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSevenCountsAndPricesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.countAndPriceCommands)) {
            data["countAndPriceCommands"] = [];
            for (let item of this.countAndPriceCommands)
                data["countAndPriceCommands"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateSevenCountsAndPricesCommand {
    countAndPriceCommands?: UpdateSevenCountAndPriceCommand[];
}

export class UpdateSevenCountAndPriceCommand implements IUpdateSevenCountAndPriceCommand {
    related7SoftProductId?: string;
    count?: number;
    price?: number;

    constructor(data?: IUpdateSevenCountAndPriceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.related7SoftProductId = _data["related7SoftProductId"];
            this.count = _data["count"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): UpdateSevenCountAndPriceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSevenCountAndPriceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["related7SoftProductId"] = this.related7SoftProductId;
        data["count"] = this.count;
        data["price"] = this.price;
        return data;
    }
}

export interface IUpdateSevenCountAndPriceCommand {
    related7SoftProductId?: string;
    count?: number;
    price?: number;
}

export class UpdateSevenCountsCommand implements IUpdateSevenCountsCommand {
    countCommands?: UpdateSevenCountCommand[];

    constructor(data?: IUpdateSevenCountsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["countCommands"])) {
                this.countCommands = [] as any;
                for (let item of _data["countCommands"])
                    this.countCommands!.push(UpdateSevenCountCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateSevenCountsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSevenCountsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.countCommands)) {
            data["countCommands"] = [];
            for (let item of this.countCommands)
                data["countCommands"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateSevenCountsCommand {
    countCommands?: UpdateSevenCountCommand[];
}

export class UpdateSevenCountCommand implements IUpdateSevenCountCommand {
    related7SoftProductId?: string;
    count?: number;

    constructor(data?: IUpdateSevenCountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.related7SoftProductId = _data["related7SoftProductId"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): UpdateSevenCountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSevenCountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["related7SoftProductId"] = this.related7SoftProductId;
        data["count"] = this.count;
        return data;
    }
}

export interface IUpdateSevenCountCommand {
    related7SoftProductId?: string;
    count?: number;
}

export class ReturnOrderItemDocumentDto implements IReturnOrderItemDocumentDto {
    id?: number;
    image?: string;
    description?: string;
    returnOrderItemId?: number;

    constructor(data?: IReturnOrderItemDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.description = _data["description"];
            this.returnOrderItemId = _data["returnOrderItemId"];
        }
    }

    static fromJS(data: any): ReturnOrderItemDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderItemDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["description"] = this.description;
        data["returnOrderItemId"] = this.returnOrderItemId;
        return data;
    }
}

export interface IReturnOrderItemDocumentDto {
    id?: number;
    image?: string;
    description?: string;
    returnOrderItemId?: number;
}

export class CreateReturnOrderItemDocumentCommand implements ICreateReturnOrderItemDocumentCommand {
    image?: string;
    description?: string;
    returnOrderItemId?: number;
    returnOrderItemGroupId?: number;
    returnOrderId?: number;

    constructor(data?: ICreateReturnOrderItemDocumentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["image"];
            this.description = _data["description"];
            this.returnOrderItemId = _data["returnOrderItemId"];
            this.returnOrderItemGroupId = _data["returnOrderItemGroupId"];
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): CreateReturnOrderItemDocumentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReturnOrderItemDocumentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["description"] = this.description;
        data["returnOrderItemId"] = this.returnOrderItemId;
        data["returnOrderItemGroupId"] = this.returnOrderItemGroupId;
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface ICreateReturnOrderItemDocumentCommand {
    image?: string;
    description?: string;
    returnOrderItemId?: number;
    returnOrderItemGroupId?: number;
    returnOrderId?: number;
}

export class UpdateReturnOrderItemDocumentCommand implements IUpdateReturnOrderItemDocumentCommand {
    id?: number;
    image?: string;
    description?: string;
    returnOrderItemId?: number;
    returnOrderItemGroupId?: number;
    returnOrderId?: number;

    constructor(data?: IUpdateReturnOrderItemDocumentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.description = _data["description"];
            this.returnOrderItemId = _data["returnOrderItemId"];
            this.returnOrderItemGroupId = _data["returnOrderItemGroupId"];
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): UpdateReturnOrderItemDocumentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReturnOrderItemDocumentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["description"] = this.description;
        data["returnOrderItemId"] = this.returnOrderItemId;
        data["returnOrderItemGroupId"] = this.returnOrderItemGroupId;
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface IUpdateReturnOrderItemDocumentCommand {
    id?: number;
    image?: string;
    description?: string;
    returnOrderItemId?: number;
    returnOrderItemGroupId?: number;
    returnOrderId?: number;
}

export class DeleteReturnOrderItemDocumentCommand implements IDeleteReturnOrderItemDocumentCommand {
    id?: number;
    returnOrderId?: number;
    returnOrderItemGroupId?: number;
    returnOrderItemId?: number;

    constructor(data?: IDeleteReturnOrderItemDocumentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.returnOrderId = _data["returnOrderId"];
            this.returnOrderItemGroupId = _data["returnOrderItemGroupId"];
            this.returnOrderItemId = _data["returnOrderItemId"];
        }
    }

    static fromJS(data: any): DeleteReturnOrderItemDocumentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteReturnOrderItemDocumentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["returnOrderId"] = this.returnOrderId;
        data["returnOrderItemGroupId"] = this.returnOrderItemGroupId;
        data["returnOrderItemId"] = this.returnOrderItemId;
        return data;
    }
}

export interface IDeleteReturnOrderItemDocumentCommand {
    id?: number;
    returnOrderId?: number;
    returnOrderItemGroupId?: number;
    returnOrderItemId?: number;
}

export class DeleteRangeReturnOrderItemDocumentCommand implements IDeleteRangeReturnOrderItemDocumentCommand {
    ids?: number[];
    returnOrderId?: number;
    returnOrderItemGroupId?: number;
    returnOrderItemId?: number;

    constructor(data?: IDeleteRangeReturnOrderItemDocumentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.returnOrderId = _data["returnOrderId"];
            this.returnOrderItemGroupId = _data["returnOrderItemGroupId"];
            this.returnOrderItemId = _data["returnOrderItemId"];
        }
    }

    static fromJS(data: any): DeleteRangeReturnOrderItemDocumentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRangeReturnOrderItemDocumentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["returnOrderId"] = this.returnOrderId;
        data["returnOrderItemGroupId"] = this.returnOrderItemGroupId;
        data["returnOrderItemId"] = this.returnOrderItemId;
        return data;
    }
}

export interface IDeleteRangeReturnOrderItemDocumentCommand {
    ids?: number[];
    returnOrderId?: number;
    returnOrderItemGroupId?: number;
    returnOrderItemId?: number;
}

export class ReturnOrderItemGroupProductAttributeOptionValueDto implements IReturnOrderItemGroupProductAttributeOptionValueDto {
    id?: number;
    name?: string;
    value?: string;
    returnOrderItemGroupId?: number;

    constructor(data?: IReturnOrderItemGroupProductAttributeOptionValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.returnOrderItemGroupId = _data["returnOrderItemGroupId"];
        }
    }

    static fromJS(data: any): ReturnOrderItemGroupProductAttributeOptionValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderItemGroupProductAttributeOptionValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["returnOrderItemGroupId"] = this.returnOrderItemGroupId;
        return data;
    }
}

export interface IReturnOrderItemGroupProductAttributeOptionValueDto {
    id?: number;
    name?: string;
    value?: string;
    returnOrderItemGroupId?: number;
}

export class ReturnOrderItemGroupDto implements IReturnOrderItemGroupDto {
    id?: number;
    price?: number;
    totalDiscountPercent?: number;
    productLocalizedName?: string;
    productName?: string;
    productNo?: string | undefined;
    productAttributeOptionId?: number;
    returnOrderId?: number;
    totalQuantity?: number;

    constructor(data?: IReturnOrderItemGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.totalDiscountPercent = _data["totalDiscountPercent"];
            this.productLocalizedName = _data["productLocalizedName"];
            this.productName = _data["productName"];
            this.productNo = _data["productNo"];
            this.productAttributeOptionId = _data["productAttributeOptionId"];
            this.returnOrderId = _data["returnOrderId"];
            this.totalQuantity = _data["totalQuantity"];
        }
    }

    static fromJS(data: any): ReturnOrderItemGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderItemGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["totalDiscountPercent"] = this.totalDiscountPercent;
        data["productLocalizedName"] = this.productLocalizedName;
        data["productName"] = this.productName;
        data["productNo"] = this.productNo;
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        data["returnOrderId"] = this.returnOrderId;
        data["totalQuantity"] = this.totalQuantity;
        return data;
    }
}

export interface IReturnOrderItemGroupDto {
    id?: number;
    price?: number;
    totalDiscountPercent?: number;
    productLocalizedName?: string;
    productName?: string;
    productNo?: string | undefined;
    productAttributeOptionId?: number;
    returnOrderId?: number;
    totalQuantity?: number;
}

export class ReturnOrderItemDto implements IReturnOrderItemDto {
    id?: number;
    quantity?: number;
    total?: number;
    returnOrderReason?: ReturnOrderReasonDto;
    isAccepted?: boolean;

    constructor(data?: IReturnOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quantity = _data["quantity"];
            this.total = _data["total"];
            this.returnOrderReason = _data["returnOrderReason"] ? ReturnOrderReasonDto.fromJS(_data["returnOrderReason"]) : <any>undefined;
            this.isAccepted = _data["isAccepted"];
        }
    }

    static fromJS(data: any): ReturnOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["total"] = this.total;
        data["returnOrderReason"] = this.returnOrderReason ? this.returnOrderReason.toJSON() : <any>undefined;
        data["isAccepted"] = this.isAccepted;
        return data;
    }
}

export interface IReturnOrderItemDto {
    id?: number;
    quantity?: number;
    total?: number;
    returnOrderReason?: ReturnOrderReasonDto;
    isAccepted?: boolean;
}

export class ReturnOrderReasonDto implements IReturnOrderReasonDto {
    id?: number;
    details?: string;
    returnOrderReasonType?: ReturnOrderReasonType;
    returnOrderReasonTypeName?: string;
    customerType?: ReturnOrderCustomerReasonType | undefined;
    customerTypeName?: string | undefined;
    organizationType?: ReturnOrderOrganizationReasonType | undefined;
    organizationTypeName?: string | undefined;

    constructor(data?: IReturnOrderReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
            this.returnOrderReasonType = _data["returnOrderReasonType"];
            this.returnOrderReasonTypeName = _data["returnOrderReasonTypeName"];
            this.customerType = _data["customerType"];
            this.customerTypeName = _data["customerTypeName"];
            this.organizationType = _data["organizationType"];
            this.organizationTypeName = _data["organizationTypeName"];
        }
    }

    static fromJS(data: any): ReturnOrderReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        data["returnOrderReasonType"] = this.returnOrderReasonType;
        data["returnOrderReasonTypeName"] = this.returnOrderReasonTypeName;
        data["customerType"] = this.customerType;
        data["customerTypeName"] = this.customerTypeName;
        data["organizationType"] = this.organizationType;
        data["organizationTypeName"] = this.organizationTypeName;
        return data;
    }
}

export interface IReturnOrderReasonDto {
    id?: number;
    details?: string;
    returnOrderReasonType?: ReturnOrderReasonType;
    returnOrderReasonTypeName?: string;
    customerType?: ReturnOrderCustomerReasonType | undefined;
    customerTypeName?: string | undefined;
    organizationType?: ReturnOrderOrganizationReasonType | undefined;
    organizationTypeName?: string | undefined;
}

export enum ReturnOrderReasonType {
    CustomerSide = 0,
    OrganizationSide = 1,
}

export enum ReturnOrderCustomerReasonType {
    CustomerCancelation = 0,
}

export enum ReturnOrderOrganizationReasonType {
    WrongProduct = 0,
    DefectiveProduct = 1,
    IncompleteProduct = 2,
    Other = 3,
}

export class CreateReturnOrderItemCommand implements ICreateReturnOrderItemCommand {
    quantity?: number;
    isAccepted?: boolean;
    returnOrderItemGroupId?: number;
    details?: string;
    customerType?: ReturnOrderCustomerReasonType | undefined;
    organizationType?: ReturnOrderOrganizationReasonType | undefined;
    returnOrderId?: number;

    constructor(data?: ICreateReturnOrderItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.isAccepted = _data["isAccepted"];
            this.returnOrderItemGroupId = _data["returnOrderItemGroupId"];
            this.details = _data["details"];
            this.customerType = _data["customerType"];
            this.organizationType = _data["organizationType"];
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): CreateReturnOrderItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReturnOrderItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["isAccepted"] = this.isAccepted;
        data["returnOrderItemGroupId"] = this.returnOrderItemGroupId;
        data["details"] = this.details;
        data["customerType"] = this.customerType;
        data["organizationType"] = this.organizationType;
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface ICreateReturnOrderItemCommand {
    quantity?: number;
    isAccepted?: boolean;
    returnOrderItemGroupId?: number;
    details?: string;
    customerType?: ReturnOrderCustomerReasonType | undefined;
    organizationType?: ReturnOrderOrganizationReasonType | undefined;
    returnOrderId?: number;
}

export class UpdateReturnOrderItemCommand implements IUpdateReturnOrderItemCommand {
    id?: number;
    quantity?: number;
    isAccepted?: boolean;
    returnOrderItemGroupId?: number;
    details?: string;
    customerType?: ReturnOrderCustomerReasonType | undefined;
    organizationType?: ReturnOrderOrganizationReasonType | undefined;
    returnOrderId?: number;

    constructor(data?: IUpdateReturnOrderItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quantity = _data["quantity"];
            this.isAccepted = _data["isAccepted"];
            this.returnOrderItemGroupId = _data["returnOrderItemGroupId"];
            this.details = _data["details"];
            this.customerType = _data["customerType"];
            this.organizationType = _data["organizationType"];
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): UpdateReturnOrderItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReturnOrderItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["isAccepted"] = this.isAccepted;
        data["returnOrderItemGroupId"] = this.returnOrderItemGroupId;
        data["details"] = this.details;
        data["customerType"] = this.customerType;
        data["organizationType"] = this.organizationType;
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface IUpdateReturnOrderItemCommand {
    id?: number;
    quantity?: number;
    isAccepted?: boolean;
    returnOrderItemGroupId?: number;
    details?: string;
    customerType?: ReturnOrderCustomerReasonType | undefined;
    organizationType?: ReturnOrderOrganizationReasonType | undefined;
    returnOrderId?: number;
}

export class DeleteReturnOrderItemCommand implements IDeleteReturnOrderItemCommand {
    id?: number;
    returnOrderId?: number;
    returnOrderItemGroupId?: number;

    constructor(data?: IDeleteReturnOrderItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.returnOrderId = _data["returnOrderId"];
            this.returnOrderItemGroupId = _data["returnOrderItemGroupId"];
        }
    }

    static fromJS(data: any): DeleteReturnOrderItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteReturnOrderItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["returnOrderId"] = this.returnOrderId;
        data["returnOrderItemGroupId"] = this.returnOrderItemGroupId;
        return data;
    }
}

export interface IDeleteReturnOrderItemCommand {
    id?: number;
    returnOrderId?: number;
    returnOrderItemGroupId?: number;
}

export class DeleteRangeReturnOrderItemCommand implements IDeleteRangeReturnOrderItemCommand {
    ids?: number[];
    returnOrderId?: number;
    returnOrderItemGroupId?: number;

    constructor(data?: IDeleteRangeReturnOrderItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.returnOrderId = _data["returnOrderId"];
            this.returnOrderItemGroupId = _data["returnOrderItemGroupId"];
        }
    }

    static fromJS(data: any): DeleteRangeReturnOrderItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRangeReturnOrderItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["returnOrderId"] = this.returnOrderId;
        data["returnOrderItemGroupId"] = this.returnOrderItemGroupId;
        return data;
    }
}

export interface IDeleteRangeReturnOrderItemCommand {
    ids?: number[];
    returnOrderId?: number;
    returnOrderItemGroupId?: number;
}

export class ReturnOrderDto implements IReturnOrderDto {
    id?: number;
    token?: string | undefined;
    number?: string;
    quantity?: number;
    subtotal?: number;
    total?: number;
    createdAt?: string;
    costRefundType?: CostRefundType;
    costRefundTypeName?: string;
    returnOrderStateHistory?: ReturnOrderStateBaseDto[];
    currentReturnOrderState?: ReturnOrderStatus;
    currentReturnOrderStateName?: string;
    returnOrderTransportationType?: ReturnOrderTransportationType;
    returnOrderTransportationTypeName?: string;
    orderNumber?: string;
    customerAccountInfo?: string | undefined;
    orderId?: number;
    phoneNumber?: string;
    fullCustomerName?: string;

    constructor(data?: IReturnOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.number = _data["number"];
            this.quantity = _data["quantity"];
            this.subtotal = _data["subtotal"];
            this.total = _data["total"];
            this.createdAt = _data["createdAt"];
            this.costRefundType = _data["costRefundType"];
            this.costRefundTypeName = _data["costRefundTypeName"];
            if (Array.isArray(_data["returnOrderStateHistory"])) {
                this.returnOrderStateHistory = [] as any;
                for (let item of _data["returnOrderStateHistory"])
                    this.returnOrderStateHistory!.push(ReturnOrderStateBaseDto.fromJS(item));
            }
            this.currentReturnOrderState = _data["currentReturnOrderState"];
            this.currentReturnOrderStateName = _data["currentReturnOrderStateName"];
            this.returnOrderTransportationType = _data["returnOrderTransportationType"];
            this.returnOrderTransportationTypeName = _data["returnOrderTransportationTypeName"];
            this.orderNumber = _data["orderNumber"];
            this.customerAccountInfo = _data["customerAccountInfo"];
            this.orderId = _data["orderId"];
            this.phoneNumber = _data["phoneNumber"];
            this.fullCustomerName = _data["fullCustomerName"];
        }
    }

    static fromJS(data: any): ReturnOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["number"] = this.number;
        data["quantity"] = this.quantity;
        data["subtotal"] = this.subtotal;
        data["total"] = this.total;
        data["createdAt"] = this.createdAt;
        data["costRefundType"] = this.costRefundType;
        data["costRefundTypeName"] = this.costRefundTypeName;
        if (Array.isArray(this.returnOrderStateHistory)) {
            data["returnOrderStateHistory"] = [];
            for (let item of this.returnOrderStateHistory)
                data["returnOrderStateHistory"].push(item.toJSON());
        }
        data["currentReturnOrderState"] = this.currentReturnOrderState;
        data["currentReturnOrderStateName"] = this.currentReturnOrderStateName;
        data["returnOrderTransportationType"] = this.returnOrderTransportationType;
        data["returnOrderTransportationTypeName"] = this.returnOrderTransportationTypeName;
        data["orderNumber"] = this.orderNumber;
        data["customerAccountInfo"] = this.customerAccountInfo;
        data["orderId"] = this.orderId;
        data["phoneNumber"] = this.phoneNumber;
        data["fullCustomerName"] = this.fullCustomerName;
        return data;
    }
}

export interface IReturnOrderDto {
    id?: number;
    token?: string | undefined;
    number?: string;
    quantity?: number;
    subtotal?: number;
    total?: number;
    createdAt?: string;
    costRefundType?: CostRefundType;
    costRefundTypeName?: string;
    returnOrderStateHistory?: ReturnOrderStateBaseDto[];
    currentReturnOrderState?: ReturnOrderStatus;
    currentReturnOrderStateName?: string;
    returnOrderTransportationType?: ReturnOrderTransportationType;
    returnOrderTransportationTypeName?: string;
    orderNumber?: string;
    customerAccountInfo?: string | undefined;
    orderId?: number;
    phoneNumber?: string;
    fullCustomerName?: string;
}

export enum CostRefundType {
    NotDetermined = 0,
    Cash = 1,
    Credit = 2,
    Online = 3,
}

export class ReturnOrderStateBaseDto implements IReturnOrderStateBaseDto {
    id?: number;
    returnOrderStatus?: ReturnOrderStatus;
    returnOrderStatusName?: string;
    details?: string;
    created?: string;

    constructor(data?: IReturnOrderStateBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.returnOrderStatus = _data["returnOrderStatus"];
            this.returnOrderStatusName = _data["returnOrderStatusName"];
            this.details = _data["details"];
            this.created = _data["created"];
        }
    }

    static fromJS(data: any): ReturnOrderStateBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderStateBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["returnOrderStatus"] = this.returnOrderStatus;
        data["returnOrderStatusName"] = this.returnOrderStatusName;
        data["details"] = this.details;
        data["created"] = this.created;
        return data;
    }
}

export interface IReturnOrderStateBaseDto {
    id?: number;
    returnOrderStatus?: ReturnOrderStatus;
    returnOrderStatusName?: string;
    details?: string;
    created?: string;
}

export enum ReturnOrderStatus {
    PendingForRegister = 0,
    Registered = 1,
    Rejected = 2,
    Accepted = 3,
    Sent = 4,
    Received = 5,
    AllConfirmed = 6,
    CostRefunded = 7,
    SomeConfirmed = 8,
    Canceled = 9,
    Completed = 10,
}

export enum ReturnOrderTransportationType {
    NotDetermined = 0,
    CustomerReturn = 1,
    OrganizationReturn = 2,
    OnLocation = 3,
}

export class FilteredReturnOrderDto implements IFilteredReturnOrderDto {
    returnOrders?: ReturnOrderDto[];
    count?: number;

    constructor(data?: IFilteredReturnOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["returnOrders"])) {
                this.returnOrders = [] as any;
                for (let item of _data["returnOrders"])
                    this.returnOrders!.push(ReturnOrderDto.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): FilteredReturnOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredReturnOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.returnOrders)) {
            data["returnOrders"] = [];
            for (let item of this.returnOrders)
                data["returnOrders"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IFilteredReturnOrderDto {
    returnOrders?: ReturnOrderDto[];
    count?: number;
}

export class ReturnOrderInfoDto implements IReturnOrderInfoDto {
    id?: number;
    phoneNumber?: string;
    customerFirstName?: string;
    customerLastName?: string;

    constructor(data?: IReturnOrderInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.phoneNumber = _data["phoneNumber"];
            this.customerFirstName = _data["customerFirstName"];
            this.customerLastName = _data["customerLastName"];
        }
    }

    static fromJS(data: any): ReturnOrderInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phoneNumber"] = this.phoneNumber;
        data["customerFirstName"] = this.customerFirstName;
        data["customerLastName"] = this.customerLastName;
        return data;
    }
}

export interface IReturnOrderInfoDto {
    id?: number;
    phoneNumber?: string;
    customerFirstName?: string;
    customerLastName?: string;
}

export class ReturnOrderTotalDto implements IReturnOrderTotalDto {
    id?: number;
    title?: string;
    price?: number;
    type?: ReturnOrderTotalType;
    typeName?: string;
    returnOrderTotalApplyType?: ReturnOrderTotalApplyType;
    returnOrderTotalApplyTypeName?: string;
    returnOrderId?: number;

    constructor(data?: IReturnOrderTotalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.type = _data["type"];
            this.typeName = _data["typeName"];
            this.returnOrderTotalApplyType = _data["returnOrderTotalApplyType"];
            this.returnOrderTotalApplyTypeName = _data["returnOrderTotalApplyTypeName"];
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): ReturnOrderTotalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderTotalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["price"] = this.price;
        data["type"] = this.type;
        data["typeName"] = this.typeName;
        data["returnOrderTotalApplyType"] = this.returnOrderTotalApplyType;
        data["returnOrderTotalApplyTypeName"] = this.returnOrderTotalApplyTypeName;
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface IReturnOrderTotalDto {
    id?: number;
    title?: string;
    price?: number;
    type?: ReturnOrderTotalType;
    typeName?: string;
    returnOrderTotalApplyType?: ReturnOrderTotalApplyType;
    returnOrderTotalApplyTypeName?: string;
    returnOrderId?: number;
}

export enum ReturnOrderTotalType {
    Shipping = 0,
    ReturnShipping = 1,
    ShippingAgain = 2,
    Tax = 3,
    TotalDiscount = 4,
    Other = 5,
}

export enum ReturnOrderTotalApplyType {
    ReduceFromTotal = 0,
    AddToTotal = 1,
    DoNothing = 2,
}

export class SendReturnOrderTotalDto implements ISendReturnOrderTotalDto {
    id?: number;
    title?: string;
    price?: number;
    type?: ReturnOrderTotalType;
    typeName?: string;
    returnOrderTotalApplyType?: ReturnOrderTotalApplyType;
    returnOrderTotalApplyTypeName?: string;
    returnOrderTotalDocuments?: ReturnOrderTotalDocumentDto[];
    returnOrderId?: number;

    constructor(data?: ISendReturnOrderTotalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.type = _data["type"];
            this.typeName = _data["typeName"];
            this.returnOrderTotalApplyType = _data["returnOrderTotalApplyType"];
            this.returnOrderTotalApplyTypeName = _data["returnOrderTotalApplyTypeName"];
            if (Array.isArray(_data["returnOrderTotalDocuments"])) {
                this.returnOrderTotalDocuments = [] as any;
                for (let item of _data["returnOrderTotalDocuments"])
                    this.returnOrderTotalDocuments!.push(ReturnOrderTotalDocumentDto.fromJS(item));
            }
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): SendReturnOrderTotalDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendReturnOrderTotalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["price"] = this.price;
        data["type"] = this.type;
        data["typeName"] = this.typeName;
        data["returnOrderTotalApplyType"] = this.returnOrderTotalApplyType;
        data["returnOrderTotalApplyTypeName"] = this.returnOrderTotalApplyTypeName;
        if (Array.isArray(this.returnOrderTotalDocuments)) {
            data["returnOrderTotalDocuments"] = [];
            for (let item of this.returnOrderTotalDocuments)
                data["returnOrderTotalDocuments"].push(item.toJSON());
        }
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface ISendReturnOrderTotalDto {
    id?: number;
    title?: string;
    price?: number;
    type?: ReturnOrderTotalType;
    typeName?: string;
    returnOrderTotalApplyType?: ReturnOrderTotalApplyType;
    returnOrderTotalApplyTypeName?: string;
    returnOrderTotalDocuments?: ReturnOrderTotalDocumentDto[];
    returnOrderId?: number;
}

export class ReturnOrderTotalDocumentDto implements IReturnOrderTotalDocumentDto {
    id?: number;
    image?: string;
    description?: string;
    returnOrderTotalId?: number;

    constructor(data?: IReturnOrderTotalDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.description = _data["description"];
            this.returnOrderTotalId = _data["returnOrderTotalId"];
        }
    }

    static fromJS(data: any): ReturnOrderTotalDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderTotalDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["description"] = this.description;
        data["returnOrderTotalId"] = this.returnOrderTotalId;
        return data;
    }
}

export interface IReturnOrderTotalDocumentDto {
    id?: number;
    image?: string;
    description?: string;
    returnOrderTotalId?: number;
}

export class CreateReturnOrderCommand implements ICreateReturnOrderCommand {
    itemGroups?: CreateItemGroupCommandForReturnOrder[];
    orderId?: number;
    customerId?: string;
    details?: string;
    quantity?: number;
    subtotal?: number;
    total?: number;
    customerAccountInfo?: string | undefined;

    constructor(data?: ICreateReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["itemGroups"])) {
                this.itemGroups = [] as any;
                for (let item of _data["itemGroups"])
                    this.itemGroups!.push(CreateItemGroupCommandForReturnOrder.fromJS(item));
            }
            this.orderId = _data["orderId"];
            this.customerId = _data["customerId"];
            this.details = _data["details"];
            this.quantity = _data["quantity"];
            this.subtotal = _data["subtotal"];
            this.total = _data["total"];
            this.customerAccountInfo = _data["customerAccountInfo"];
        }
    }

    static fromJS(data: any): CreateReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemGroups)) {
            data["itemGroups"] = [];
            for (let item of this.itemGroups)
                data["itemGroups"].push(item.toJSON());
        }
        data["orderId"] = this.orderId;
        data["customerId"] = this.customerId;
        data["details"] = this.details;
        data["quantity"] = this.quantity;
        data["subtotal"] = this.subtotal;
        data["total"] = this.total;
        data["customerAccountInfo"] = this.customerAccountInfo;
        return data;
    }
}

export interface ICreateReturnOrderCommand {
    itemGroups?: CreateItemGroupCommandForReturnOrder[];
    orderId?: number;
    customerId?: string;
    details?: string;
    quantity?: number;
    subtotal?: number;
    total?: number;
    customerAccountInfo?: string | undefined;
}

export class CreateItemGroupCommandForReturnOrder implements ICreateItemGroupCommandForReturnOrder {
    productAttributeOptionId?: number;
    orderItems?: CreateItemCommandForItemGroup[];

    constructor(data?: ICreateItemGroupCommandForReturnOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productAttributeOptionId = _data["productAttributeOptionId"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(CreateItemCommandForItemGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateItemGroupCommandForReturnOrder {
        data = typeof data === 'object' ? data : {};
        let result = new CreateItemGroupCommandForReturnOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateItemGroupCommandForReturnOrder {
    productAttributeOptionId?: number;
    orderItems?: CreateItemCommandForItemGroup[];
}

export class CreateItemCommandForItemGroup implements ICreateItemCommandForItemGroup {
    quantity?: number;
    returnOrderReason?: CreateReasonCommandForItem;
    returnOrderItemDocuments?: DocumentCommandForItem[];

    constructor(data?: ICreateItemCommandForItemGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.returnOrderReason = _data["returnOrderReason"] ? CreateReasonCommandForItem.fromJS(_data["returnOrderReason"]) : <any>undefined;
            if (Array.isArray(_data["returnOrderItemDocuments"])) {
                this.returnOrderItemDocuments = [] as any;
                for (let item of _data["returnOrderItemDocuments"])
                    this.returnOrderItemDocuments!.push(DocumentCommandForItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateItemCommandForItemGroup {
        data = typeof data === 'object' ? data : {};
        let result = new CreateItemCommandForItemGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["returnOrderReason"] = this.returnOrderReason ? this.returnOrderReason.toJSON() : <any>undefined;
        if (Array.isArray(this.returnOrderItemDocuments)) {
            data["returnOrderItemDocuments"] = [];
            for (let item of this.returnOrderItemDocuments)
                data["returnOrderItemDocuments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateItemCommandForItemGroup {
    quantity?: number;
    returnOrderReason?: CreateReasonCommandForItem;
    returnOrderItemDocuments?: DocumentCommandForItem[];
}

export class CreateReasonCommandForItem implements ICreateReasonCommandForItem {
    details?: string;
    customerType?: number | undefined;
    organizationType?: number | undefined;

    constructor(data?: ICreateReasonCommandForItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"];
            this.customerType = _data["customerType"];
            this.organizationType = _data["organizationType"];
        }
    }

    static fromJS(data: any): CreateReasonCommandForItem {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReasonCommandForItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details;
        data["customerType"] = this.customerType;
        data["organizationType"] = this.organizationType;
        return data;
    }
}

export interface ICreateReasonCommandForItem {
    details?: string;
    customerType?: number | undefined;
    organizationType?: number | undefined;
}

export class DocumentCommandForItem implements IDocumentCommandForItem {
    image?: string;
    description?: string;

    constructor(data?: IDocumentCommandForItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["image"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DocumentCommandForItem {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentCommandForItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["description"] = this.description;
        return data;
    }
}

export interface IDocumentCommandForItem {
    image?: string;
    description?: string;
}

export class AcceptReturnOrderCommand implements IAcceptReturnOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: IAcceptReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): AcceptReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IAcceptReturnOrderCommand {
    id?: number;
    details?: string;
}

export class CancelReturnOrderCommand implements ICancelReturnOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: ICancelReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): CancelReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CancelReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface ICancelReturnOrderCommand {
    id?: number;
    details?: string;
}

export class CompleteReturnOrderCommand implements ICompleteReturnOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: ICompleteReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): CompleteReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface ICompleteReturnOrderCommand {
    id?: number;
    details?: string;
}

export class ConfirmAllReturnOrderCommand implements IConfirmAllReturnOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: IConfirmAllReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): ConfirmAllReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmAllReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IConfirmAllReturnOrderCommand {
    id?: number;
    details?: string;
}

export class ConfirmSomeReturnOrderCommand implements IConfirmSomeReturnOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: IConfirmSomeReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): ConfirmSomeReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmSomeReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IConfirmSomeReturnOrderCommand {
    id?: number;
    details?: string;
}

export class ReceiveReturnOrderCommand implements IReceiveReturnOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: IReceiveReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): ReceiveReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReceiveReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IReceiveReturnOrderCommand {
    id?: number;
    details?: string;
}

export class RefundReturnOrderCostCommand implements IRefundReturnOrderCostCommand {
    id?: number;
    details?: string;
    costRefundType?: CostRefundType;

    constructor(data?: IRefundReturnOrderCostCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
            this.costRefundType = _data["costRefundType"];
        }
    }

    static fromJS(data: any): RefundReturnOrderCostCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefundReturnOrderCostCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        data["costRefundType"] = this.costRefundType;
        return data;
    }
}

export interface IRefundReturnOrderCostCommand {
    id?: number;
    details?: string;
    costRefundType?: CostRefundType;
}

export class RejectReturnOrderCommand implements IRejectReturnOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: IRejectReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): RejectReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RejectReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IRejectReturnOrderCommand {
    id?: number;
    details?: string;
}

export class SendReturnOrderCommand implements ISendReturnOrderCommand {
    id?: number;
    details?: string;
    returnOrderTransportationType?: ReturnOrderTransportationType;
    returnShippingPrice?: number | undefined;
    documentCommandForTotals?: DocumentCommandForTotal[];

    constructor(data?: ISendReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
            this.returnOrderTransportationType = _data["returnOrderTransportationType"];
            this.returnShippingPrice = _data["returnShippingPrice"];
            if (Array.isArray(_data["documentCommandForTotals"])) {
                this.documentCommandForTotals = [] as any;
                for (let item of _data["documentCommandForTotals"])
                    this.documentCommandForTotals!.push(DocumentCommandForTotal.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        data["returnOrderTransportationType"] = this.returnOrderTransportationType;
        data["returnShippingPrice"] = this.returnShippingPrice;
        if (Array.isArray(this.documentCommandForTotals)) {
            data["documentCommandForTotals"] = [];
            for (let item of this.documentCommandForTotals)
                data["documentCommandForTotals"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISendReturnOrderCommand {
    id?: number;
    details?: string;
    returnOrderTransportationType?: ReturnOrderTransportationType;
    returnShippingPrice?: number | undefined;
    documentCommandForTotals?: DocumentCommandForTotal[];
}

export class DocumentCommandForTotal implements IDocumentCommandForTotal {
    image?: string;
    description?: string;

    constructor(data?: IDocumentCommandForTotal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["image"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DocumentCommandForTotal {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentCommandForTotal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["description"] = this.description;
        return data;
    }
}

export interface IDocumentCommandForTotal {
    image?: string;
    description?: string;
}

export class UpdateReturnOrderCommand implements IUpdateReturnOrderCommand {
    id?: number;
    phoneNumber?: string;
    customerFirstName?: string;
    customerLastName?: string;

    constructor(data?: IUpdateReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.phoneNumber = _data["phoneNumber"];
            this.customerFirstName = _data["customerFirstName"];
            this.customerLastName = _data["customerLastName"];
        }
    }

    static fromJS(data: any): UpdateReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phoneNumber"] = this.phoneNumber;
        data["customerFirstName"] = this.customerFirstName;
        data["customerLastName"] = this.customerLastName;
        return data;
    }
}

export interface IUpdateReturnOrderCommand {
    id?: number;
    phoneNumber?: string;
    customerFirstName?: string;
    customerLastName?: string;
}

export class CreateReturnOrderTotalDocumentCommand implements ICreateReturnOrderTotalDocumentCommand {
    image?: string;
    description?: string;
    returnOrderTotalId?: number;
    returnOrderId?: number;

    constructor(data?: ICreateReturnOrderTotalDocumentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["image"];
            this.description = _data["description"];
            this.returnOrderTotalId = _data["returnOrderTotalId"];
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): CreateReturnOrderTotalDocumentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReturnOrderTotalDocumentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["description"] = this.description;
        data["returnOrderTotalId"] = this.returnOrderTotalId;
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface ICreateReturnOrderTotalDocumentCommand {
    image?: string;
    description?: string;
    returnOrderTotalId?: number;
    returnOrderId?: number;
}

export class UpdateReturnOrderTotalDocumentCommand implements IUpdateReturnOrderTotalDocumentCommand {
    id?: number;
    image?: string;
    description?: string;
    returnOrderTotalId?: number;
    returnOrderId?: number;

    constructor(data?: IUpdateReturnOrderTotalDocumentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.description = _data["description"];
            this.returnOrderTotalId = _data["returnOrderTotalId"];
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): UpdateReturnOrderTotalDocumentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReturnOrderTotalDocumentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["description"] = this.description;
        data["returnOrderTotalId"] = this.returnOrderTotalId;
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface IUpdateReturnOrderTotalDocumentCommand {
    id?: number;
    image?: string;
    description?: string;
    returnOrderTotalId?: number;
    returnOrderId?: number;
}

export class DeleteReturnOrderTotalDocumentCommand implements IDeleteReturnOrderTotalDocumentCommand {
    id?: number;
    returnOrderId?: number;
    returnOrderTotalId?: number;

    constructor(data?: IDeleteReturnOrderTotalDocumentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.returnOrderId = _data["returnOrderId"];
            this.returnOrderTotalId = _data["returnOrderTotalId"];
        }
    }

    static fromJS(data: any): DeleteReturnOrderTotalDocumentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteReturnOrderTotalDocumentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["returnOrderId"] = this.returnOrderId;
        data["returnOrderTotalId"] = this.returnOrderTotalId;
        return data;
    }
}

export interface IDeleteReturnOrderTotalDocumentCommand {
    id?: number;
    returnOrderId?: number;
    returnOrderTotalId?: number;
}

export class DeleteRangeReturnOrderTotalDocumentCommand implements IDeleteRangeReturnOrderTotalDocumentCommand {
    ids?: number[];
    returnOrderId?: number;
    returnOrderTotalId?: number;

    constructor(data?: IDeleteRangeReturnOrderTotalDocumentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.returnOrderId = _data["returnOrderId"];
            this.returnOrderTotalId = _data["returnOrderTotalId"];
        }
    }

    static fromJS(data: any): DeleteRangeReturnOrderTotalDocumentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRangeReturnOrderTotalDocumentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["returnOrderId"] = this.returnOrderId;
        data["returnOrderTotalId"] = this.returnOrderTotalId;
        return data;
    }
}

export interface IDeleteRangeReturnOrderTotalDocumentCommand {
    ids?: number[];
    returnOrderId?: number;
    returnOrderTotalId?: number;
}

export class CreateReturnOrderTotalCommand implements ICreateReturnOrderTotalCommand {
    title?: string;
    price?: number;
    type?: ReturnOrderTotalType;
    returnOrderTotalApplyType?: ReturnOrderTotalApplyType;
    returnOrderId?: number;

    constructor(data?: ICreateReturnOrderTotalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.price = _data["price"];
            this.type = _data["type"];
            this.returnOrderTotalApplyType = _data["returnOrderTotalApplyType"];
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): CreateReturnOrderTotalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReturnOrderTotalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["price"] = this.price;
        data["type"] = this.type;
        data["returnOrderTotalApplyType"] = this.returnOrderTotalApplyType;
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface ICreateReturnOrderTotalCommand {
    title?: string;
    price?: number;
    type?: ReturnOrderTotalType;
    returnOrderTotalApplyType?: ReturnOrderTotalApplyType;
    returnOrderId?: number;
}

export class UpdateReturnOrderTotalCommand implements IUpdateReturnOrderTotalCommand {
    id?: number;
    title?: string;
    price?: number;
    type?: ReturnOrderTotalType;
    returnOrderTotalApplyType?: ReturnOrderTotalApplyType;
    returnOrderId?: number;

    constructor(data?: IUpdateReturnOrderTotalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.type = _data["type"];
            this.returnOrderTotalApplyType = _data["returnOrderTotalApplyType"];
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): UpdateReturnOrderTotalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReturnOrderTotalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["price"] = this.price;
        data["type"] = this.type;
        data["returnOrderTotalApplyType"] = this.returnOrderTotalApplyType;
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface IUpdateReturnOrderTotalCommand {
    id?: number;
    title?: string;
    price?: number;
    type?: ReturnOrderTotalType;
    returnOrderTotalApplyType?: ReturnOrderTotalApplyType;
    returnOrderId?: number;
}

export class DeleteReturnOrderTotalCommand implements IDeleteReturnOrderTotalCommand {
    id?: number;
    returnOrderId?: number;

    constructor(data?: IDeleteReturnOrderTotalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): DeleteReturnOrderTotalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteReturnOrderTotalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface IDeleteReturnOrderTotalCommand {
    id?: number;
    returnOrderId?: number;
}

export class DeleteRangeReturnOrderTotalCommand implements IDeleteRangeReturnOrderTotalCommand {
    ids?: number[];
    returnOrderId?: number;

    constructor(data?: IDeleteRangeReturnOrderTotalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.returnOrderId = _data["returnOrderId"];
        }
    }

    static fromJS(data: any): DeleteRangeReturnOrderTotalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRangeReturnOrderTotalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["returnOrderId"] = this.returnOrderId;
        return data;
    }
}

export interface IDeleteRangeReturnOrderTotalCommand {
    ids?: number[];
    returnOrderId?: number;
}

export class FilteredRequestLogDto implements IFilteredRequestLogDto {
    requestLogs?: RequestLogDto[];
    count?: number;

    constructor(data?: IFilteredRequestLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["requestLogs"])) {
                this.requestLogs = [] as any;
                for (let item of _data["requestLogs"])
                    this.requestLogs!.push(RequestLogDto.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): FilteredRequestLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredRequestLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requestLogs)) {
            data["requestLogs"] = [];
            for (let item of this.requestLogs)
                data["requestLogs"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IFilteredRequestLogDto {
    requestLogs?: RequestLogDto[];
    count?: number;
}

export class RequestLogDto implements IRequestLogDto {
    id?: number;
    apiAddress?: string;
    requestBody?: string | undefined;
    errorMessage?: string | undefined;
    responseStatus?: HttpStatusCode;
    httpStatusCodeName?: string;
    created?: string;
    requestType?: RequestType;
    requestTypeName?: string;
    apiType?: ApiType;
    apiTypeName?: string;

    constructor(data?: IRequestLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.apiAddress = _data["apiAddress"];
            this.requestBody = _data["requestBody"];
            this.errorMessage = _data["errorMessage"];
            this.responseStatus = _data["responseStatus"];
            this.httpStatusCodeName = _data["httpStatusCodeName"];
            this.created = _data["created"];
            this.requestType = _data["requestType"];
            this.requestTypeName = _data["requestTypeName"];
            this.apiType = _data["apiType"];
            this.apiTypeName = _data["apiTypeName"];
        }
    }

    static fromJS(data: any): RequestLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["apiAddress"] = this.apiAddress;
        data["requestBody"] = this.requestBody;
        data["errorMessage"] = this.errorMessage;
        data["responseStatus"] = this.responseStatus;
        data["httpStatusCodeName"] = this.httpStatusCodeName;
        data["created"] = this.created;
        data["requestType"] = this.requestType;
        data["requestTypeName"] = this.requestTypeName;
        data["apiType"] = this.apiType;
        data["apiTypeName"] = this.apiTypeName;
        return data;
    }
}

export interface IRequestLogDto {
    id?: number;
    apiAddress?: string;
    requestBody?: string | undefined;
    errorMessage?: string | undefined;
    responseStatus?: HttpStatusCode;
    httpStatusCodeName?: string;
    created?: string;
    requestType?: RequestType;
    requestTypeName?: string;
    apiType?: ApiType;
    apiTypeName?: string;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    UnprocessableContent = 422,
    Locked = 423,
    FailedDependency = 424,
    UpgradeRequired = 426,
    PreconditionRequired = 428,
    TooManyRequests = 429,
    RequestHeaderFieldsTooLarge = 431,
    UnavailableForLegalReasons = 451,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthenticationRequired = 511,
}

export enum RequestType {
    Brand = 0,
    VehicleType = 1,
    Vehicle = 2,
    VehicleModel = 3,
    PartGroup = 4,
    Country = 5,
    CountingUnitType = 6,
    CountingUnit = 7,
    PartStatus = 8,
    PartType = 9,
    Provider = 10,
    Part = 11,
    PartVehicleModel = 12,
    PartPrice = 13,
    PartCount = 14,
    CostType = 15,
    PartFull = 16,
    PartVehicleModelFull = 17,
    InsertOrder = 18,
    CancelOrder = 19,
    ResendableCancelOrder = 20,
    Authenticate = 21,
    Invoice = 22,
}

export enum ApiType {
    Get = 0,
    Post = 1,
    Put = 2,
    Delete = 3,
}

export class ResendCancelOrderRequestsCommand implements IResendCancelOrderRequestsCommand {
    ids?: number[];

    constructor(data?: IResendCancelOrderRequestsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): ResendCancelOrderRequestsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResendCancelOrderRequestsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

export interface IResendCancelOrderRequestsCommand {
    ids?: number[];
}

export class BadgeDto implements IBadgeDto {
    id?: number;
    value?: string;
    isActive?: boolean;

    constructor(data?: IBadgeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): BadgeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BadgeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IBadgeDto {
    id?: number;
    value?: string;
    isActive?: boolean;
}

export class CreateBadgeCommand implements ICreateBadgeCommand {
    value?: string;
    isActive?: boolean;
    productAttributeOptionIds?: number[];

    constructor(data?: ICreateBadgeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["productAttributeOptionIds"])) {
                this.productAttributeOptionIds = [] as any;
                for (let item of _data["productAttributeOptionIds"])
                    this.productAttributeOptionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateBadgeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBadgeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.productAttributeOptionIds)) {
            data["productAttributeOptionIds"] = [];
            for (let item of this.productAttributeOptionIds)
                data["productAttributeOptionIds"].push(item);
        }
        return data;
    }
}

export interface ICreateBadgeCommand {
    value?: string;
    isActive?: boolean;
    productAttributeOptionIds?: number[];
}

export class UpdateBadgeCommand implements IUpdateBadgeCommand {
    id?: number;
    value?: string;
    isActive?: boolean;
    productAttributeOptionIds?: number[];

    constructor(data?: IUpdateBadgeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["productAttributeOptionIds"])) {
                this.productAttributeOptionIds = [] as any;
                for (let item of _data["productAttributeOptionIds"])
                    this.productAttributeOptionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateBadgeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBadgeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.productAttributeOptionIds)) {
            data["productAttributeOptionIds"] = [];
            for (let item of this.productAttributeOptionIds)
                data["productAttributeOptionIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateBadgeCommand {
    id?: number;
    value?: string;
    isActive?: boolean;
    productAttributeOptionIds?: number[];
}

export class AddRangeProductAttributeOptionBadgesCommand implements IAddRangeProductAttributeOptionBadgesCommand {
    badgeIds?: number[];
    productAttributeOptionId?: number;

    constructor(data?: IAddRangeProductAttributeOptionBadgesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["badgeIds"])) {
                this.badgeIds = [] as any;
                for (let item of _data["badgeIds"])
                    this.badgeIds!.push(item);
            }
            this.productAttributeOptionId = _data["productAttributeOptionId"];
        }
    }

    static fromJS(data: any): AddRangeProductAttributeOptionBadgesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddRangeProductAttributeOptionBadgesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.badgeIds)) {
            data["badgeIds"] = [];
            for (let item of this.badgeIds)
                data["badgeIds"].push(item);
        }
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        return data;
    }
}

export interface IAddRangeProductAttributeOptionBadgesCommand {
    badgeIds?: number[];
    productAttributeOptionId?: number;
}

export class PaginatedListOfCountingUnitDto implements IPaginatedListOfCountingUnitDto {
    items?: CountingUnitDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCountingUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountingUnitDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCountingUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCountingUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCountingUnitDto {
    items?: CountingUnitDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CountingUnitDto implements ICountingUnitDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitTypeId?: number;
    countingUnitTypeName?: string;

    constructor(data?: ICountingUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isDecimal = _data["isDecimal"];
            this.countingUnitTypeId = _data["countingUnitTypeId"];
            this.countingUnitTypeName = _data["countingUnitTypeName"];
        }
    }

    static fromJS(data: any): CountingUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountingUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isDecimal"] = this.isDecimal;
        data["countingUnitTypeId"] = this.countingUnitTypeId;
        data["countingUnitTypeName"] = this.countingUnitTypeName;
        return data;
    }
}

export interface ICountingUnitDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitTypeId?: number;
    countingUnitTypeName?: string;
}

export class AllCountingUnitDropDownDto implements IAllCountingUnitDropDownDto {
    id?: number;
    localizedName?: string;

    constructor(data?: IAllCountingUnitDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllCountingUnitDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllCountingUnitDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllCountingUnitDropDownDto {
    id?: number;
    localizedName?: string;
}

export class CreateCountingUnitCommand implements ICreateCountingUnitCommand {
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitTypeId?: number | undefined;

    constructor(data?: ICreateCountingUnitCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isDecimal = _data["isDecimal"];
            this.countingUnitTypeId = _data["countingUnitTypeId"];
        }
    }

    static fromJS(data: any): CreateCountingUnitCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountingUnitCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isDecimal"] = this.isDecimal;
        data["countingUnitTypeId"] = this.countingUnitTypeId;
        return data;
    }
}

export interface ICreateCountingUnitCommand {
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitTypeId?: number | undefined;
}

export class UpdateCountingUnitCommand implements IUpdateCountingUnitCommand {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitTypeId?: number | undefined;

    constructor(data?: IUpdateCountingUnitCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isDecimal = _data["isDecimal"];
            this.countingUnitTypeId = _data["countingUnitTypeId"];
        }
    }

    static fromJS(data: any): UpdateCountingUnitCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCountingUnitCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isDecimal"] = this.isDecimal;
        data["countingUnitTypeId"] = this.countingUnitTypeId;
        return data;
    }
}

export interface IUpdateCountingUnitCommand {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitTypeId?: number | undefined;
}

export class PaginatedListOfCountingUnitTypeDto implements IPaginatedListOfCountingUnitTypeDto {
    items?: CountingUnitTypeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCountingUnitTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountingUnitTypeDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCountingUnitTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCountingUnitTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCountingUnitTypeDto {
    items?: CountingUnitTypeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CountingUnitTypeDto implements ICountingUnitTypeDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: ICountingUnitTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): CountingUnitTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountingUnitTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface ICountingUnitTypeDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class CreateCountingUnitTypeCommand implements ICreateCountingUnitTypeCommand {
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: ICreateCountingUnitTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): CreateCountingUnitTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountingUnitTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface ICreateCountingUnitTypeCommand {
    code?: number;
    name?: string;
    localizedName?: string;
}

export class UpdateCountingUnitTypeCommand implements IUpdateCountingUnitTypeCommand {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IUpdateCountingUnitTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): UpdateCountingUnitTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCountingUnitTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IUpdateCountingUnitTypeCommand {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class CreatePriceCommand implements ICreatePriceCommand {
    date?: Date;
    mainPrice?: number;
    productAttributeOptionId?: number;

    constructor(data?: ICreatePriceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.mainPrice = _data["mainPrice"];
            this.productAttributeOptionId = _data["productAttributeOptionId"];
        }
    }

    static fromJS(data: any): CreatePriceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePriceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["mainPrice"] = this.mainPrice;
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        return data;
    }
}

export interface ICreatePriceCommand {
    date?: Date;
    mainPrice?: number;
    productAttributeOptionId?: number;
}

export class UpdatePriceCommand implements IUpdatePriceCommand {
    id?: number;
    date?: Date;
    mainPrice?: number;
    productAttributeOptionId?: number;

    constructor(data?: IUpdatePriceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.mainPrice = _data["mainPrice"];
            this.productAttributeOptionId = _data["productAttributeOptionId"];
        }
    }

    static fromJS(data: any): UpdatePriceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePriceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["mainPrice"] = this.mainPrice;
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        return data;
    }
}

export interface IUpdatePriceCommand {
    id?: number;
    date?: Date;
    mainPrice?: number;
    productAttributeOptionId?: number;
}

export class PriceDto implements IPriceDto {
    id?: number;
    date?: Date;
    mainPrice?: number;

    constructor(data?: IPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.mainPrice = _data["mainPrice"];
        }
    }

    static fromJS(data: any): PriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["mainPrice"] = this.mainPrice;
        return data;
    }
}

export interface IPriceDto {
    id?: number;
    date?: Date;
    mainPrice?: number;
}

export class ProductDisplayVariantDto implements IProductDisplayVariantDto {
    id?: number;
    name?: string;
    productName?: string;
    productId?: number;
    isBestSeller?: boolean;
    isFeatured?: boolean;
    isLatest?: boolean;
    isNew?: boolean;
    isPopular?: boolean;
    isSale?: boolean;
    isSpecialOffer?: boolean;
    isTopRated?: boolean;
    isActive?: boolean;

    constructor(data?: IProductDisplayVariantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.productName = _data["productName"];
            this.productId = _data["productId"];
            this.isBestSeller = _data["isBestSeller"];
            this.isFeatured = _data["isFeatured"];
            this.isLatest = _data["isLatest"];
            this.isNew = _data["isNew"];
            this.isPopular = _data["isPopular"];
            this.isSale = _data["isSale"];
            this.isSpecialOffer = _data["isSpecialOffer"];
            this.isTopRated = _data["isTopRated"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductDisplayVariantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDisplayVariantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["productName"] = this.productName;
        data["productId"] = this.productId;
        data["isBestSeller"] = this.isBestSeller;
        data["isFeatured"] = this.isFeatured;
        data["isLatest"] = this.isLatest;
        data["isNew"] = this.isNew;
        data["isPopular"] = this.isPopular;
        data["isSale"] = this.isSale;
        data["isSpecialOffer"] = this.isSpecialOffer;
        data["isTopRated"] = this.isTopRated;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductDisplayVariantDto {
    id?: number;
    name?: string;
    productName?: string;
    productId?: number;
    isBestSeller?: boolean;
    isFeatured?: boolean;
    isLatest?: boolean;
    isNew?: boolean;
    isPopular?: boolean;
    isSale?: boolean;
    isSpecialOffer?: boolean;
    isTopRated?: boolean;
    isActive?: boolean;
}

export class CreateVariantCommand implements ICreateVariantCommand {
    name?: string;
    productId?: number;
    isBestSeller?: boolean;
    isFeatured?: boolean;
    isLatest?: boolean;
    isNew?: boolean;
    isPopular?: boolean;
    isSale?: boolean;
    isSpecialOffer?: boolean;
    isTopRated?: boolean;
    isActive?: boolean;

    constructor(data?: ICreateVariantCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.productId = _data["productId"];
            this.isBestSeller = _data["isBestSeller"];
            this.isFeatured = _data["isFeatured"];
            this.isLatest = _data["isLatest"];
            this.isNew = _data["isNew"];
            this.isPopular = _data["isPopular"];
            this.isSale = _data["isSale"];
            this.isSpecialOffer = _data["isSpecialOffer"];
            this.isTopRated = _data["isTopRated"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateVariantCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVariantCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["productId"] = this.productId;
        data["isBestSeller"] = this.isBestSeller;
        data["isFeatured"] = this.isFeatured;
        data["isLatest"] = this.isLatest;
        data["isNew"] = this.isNew;
        data["isPopular"] = this.isPopular;
        data["isSale"] = this.isSale;
        data["isSpecialOffer"] = this.isSpecialOffer;
        data["isTopRated"] = this.isTopRated;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateVariantCommand {
    name?: string;
    productId?: number;
    isBestSeller?: boolean;
    isFeatured?: boolean;
    isLatest?: boolean;
    isNew?: boolean;
    isPopular?: boolean;
    isSale?: boolean;
    isSpecialOffer?: boolean;
    isTopRated?: boolean;
    isActive?: boolean;
}

export class UpdateVariantCommand implements IUpdateVariantCommand {
    id?: number;
    name?: string;
    productId?: number;
    isBestSeller?: boolean;
    isFeatured?: boolean;
    isLatest?: boolean;
    isNew?: boolean;
    isPopular?: boolean;
    isSale?: boolean;
    isSpecialOffer?: boolean;
    isTopRated?: boolean;
    isActive?: boolean;

    constructor(data?: IUpdateVariantCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.productId = _data["productId"];
            this.isBestSeller = _data["isBestSeller"];
            this.isFeatured = _data["isFeatured"];
            this.isLatest = _data["isLatest"];
            this.isNew = _data["isNew"];
            this.isPopular = _data["isPopular"];
            this.isSale = _data["isSale"];
            this.isSpecialOffer = _data["isSpecialOffer"];
            this.isTopRated = _data["isTopRated"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateVariantCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateVariantCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["productId"] = this.productId;
        data["isBestSeller"] = this.isBestSeller;
        data["isFeatured"] = this.isFeatured;
        data["isLatest"] = this.isLatest;
        data["isNew"] = this.isNew;
        data["isPopular"] = this.isPopular;
        data["isSale"] = this.isSale;
        data["isSpecialOffer"] = this.isSpecialOffer;
        data["isTopRated"] = this.isTopRated;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateVariantCommand {
    id?: number;
    name?: string;
    productId?: number;
    isBestSeller?: boolean;
    isFeatured?: boolean;
    isLatest?: boolean;
    isNew?: boolean;
    isPopular?: boolean;
    isSale?: boolean;
    isSpecialOffer?: boolean;
    isTopRated?: boolean;
    isActive?: boolean;
}

export class ProductImagesDto implements IProductImagesDto {
    id?: number;
    productId?: number;
    image?: string;
    order?: number;
    isActive?: boolean;

    constructor(data?: IProductImagesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.image = _data["image"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductImagesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImagesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["image"] = this.image;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductImagesDto {
    id?: number;
    productId?: number;
    image?: string;
    order?: number;
    isActive?: boolean;
}

export class CreateProductImageCommand implements ICreateProductImageCommand {
    image?: string;
    order?: number;
    productId?: number;
    isActive?: boolean;

    constructor(data?: ICreateProductImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["image"];
            this.order = _data["order"];
            this.productId = _data["productId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateProductImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["order"] = this.order;
        data["productId"] = this.productId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateProductImageCommand {
    image?: string;
    order?: number;
    productId?: number;
    isActive?: boolean;
}

export class UpdateProductImageCommand implements IUpdateProductImageCommand {
    id?: number;
    image?: string;
    order?: number;
    productId?: number;
    isActive?: boolean;

    constructor(data?: IUpdateProductImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.order = _data["order"];
            this.productId = _data["productId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateProductImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["order"] = this.order;
        data["productId"] = this.productId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateProductImageCommand {
    id?: number;
    image?: string;
    order?: number;
    productId?: number;
    isActive?: boolean;
}

export class CreateProductKindsCommand implements ICreateProductKindsCommand {
    kindId?: number;
    productId?: number;

    constructor(data?: ICreateProductKindsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kindId = _data["kindId"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): CreateProductKindsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductKindsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kindId"] = this.kindId;
        data["productId"] = this.productId;
        return data;
    }
}

export interface ICreateProductKindsCommand {
    kindId?: number;
    productId?: number;
}

export class AllProductKindByProductIdDto implements IAllProductKindByProductIdDto {
    id?: number;
    kindId?: number;
    kindName?: string;
    productId?: number;

    constructor(data?: IAllProductKindByProductIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.kindId = _data["kindId"];
            this.kindName = _data["kindName"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): AllProductKindByProductIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductKindByProductIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["kindId"] = this.kindId;
        data["kindName"] = this.kindName;
        data["productId"] = this.productId;
        return data;
    }
}

export interface IAllProductKindByProductIdDto {
    id?: number;
    kindId?: number;
    kindName?: string;
    productId?: number;
}

export class AddRangeProductKindsCommand implements IAddRangeProductKindsCommand {
    kindIds?: number[];
    productId?: number;

    constructor(data?: IAddRangeProductKindsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["kindIds"])) {
                this.kindIds = [] as any;
                for (let item of _data["kindIds"])
                    this.kindIds!.push(item);
            }
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): AddRangeProductKindsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddRangeProductKindsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.kindIds)) {
            data["kindIds"] = [];
            for (let item of this.kindIds)
                data["kindIds"].push(item);
        }
        data["productId"] = this.productId;
        return data;
    }
}

export interface IAddRangeProductKindsCommand {
    kindIds?: number[];
    productId?: number;
}

export class PaginatedListOfBackOfficeProductDto implements IPaginatedListOfBackOfficeProductDto {
    items?: BackOfficeProductDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfBackOfficeProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BackOfficeProductDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfBackOfficeProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfBackOfficeProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfBackOfficeProductDto {
    items?: BackOfficeProductDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class BackOfficeProductDto implements IBackOfficeProductDto {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    mileage?: number | undefined;
    duration?: number | undefined;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    providerId?: number | undefined;
    providerName?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    productTypeId?: number | undefined;
    productTypeName?: string | undefined;
    productStatusId?: number | undefined;
    productStatusName?: string | undefined;
    mainCountingUnitId?: number | undefined;
    mainCountingUnitName?: string | undefined;
    commonCountingUnitId?: number | undefined;
    commonCountingUnitName?: string | undefined;
    brandId?: number;
    brandName?: string;
    productCategoryId?: number;
    productCategoryName?: string;
    productAttributeTypeId?: number | undefined;
    productAttributeTypeName?: string;
    colorOptionId?: number | undefined;
    colorOptionName?: string | undefined;
    materialOptionId?: number | undefined;
    materialOptionName?: string | undefined;
    isActive?: boolean;
    compatibility?: CompatibilityEnum;
    compatibilityName?: string;

    constructor(data?: IBackOfficeProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.productNo = _data["productNo"];
            this.oldProductNo = _data["oldProductNo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.productCatalog = _data["productCatalog"];
            this.orderRate = _data["orderRate"];
            this.mileage = _data["mileage"];
            this.duration = _data["duration"];
            this.excerpt = _data["excerpt"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.providerId = _data["providerId"];
            this.providerName = _data["providerName"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.productTypeId = _data["productTypeId"];
            this.productTypeName = _data["productTypeName"];
            this.productStatusId = _data["productStatusId"];
            this.productStatusName = _data["productStatusName"];
            this.mainCountingUnitId = _data["mainCountingUnitId"];
            this.mainCountingUnitName = _data["mainCountingUnitName"];
            this.commonCountingUnitId = _data["commonCountingUnitId"];
            this.commonCountingUnitName = _data["commonCountingUnitName"];
            this.brandId = _data["brandId"];
            this.brandName = _data["brandName"];
            this.productCategoryId = _data["productCategoryId"];
            this.productCategoryName = _data["productCategoryName"];
            this.productAttributeTypeId = _data["productAttributeTypeId"];
            this.productAttributeTypeName = _data["productAttributeTypeName"];
            this.colorOptionId = _data["colorOptionId"];
            this.colorOptionName = _data["colorOptionName"];
            this.materialOptionId = _data["materialOptionId"];
            this.materialOptionName = _data["materialOptionName"];
            this.isActive = _data["isActive"];
            this.compatibility = _data["compatibility"];
            this.compatibilityName = _data["compatibilityName"];
        }
    }

    static fromJS(data: any): BackOfficeProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new BackOfficeProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["productNo"] = this.productNo;
        data["oldProductNo"] = this.oldProductNo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["productCatalog"] = this.productCatalog;
        data["orderRate"] = this.orderRate;
        data["mileage"] = this.mileage;
        data["duration"] = this.duration;
        data["excerpt"] = this.excerpt;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["providerId"] = this.providerId;
        data["providerName"] = this.providerName;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["productTypeId"] = this.productTypeId;
        data["productTypeName"] = this.productTypeName;
        data["productStatusId"] = this.productStatusId;
        data["productStatusName"] = this.productStatusName;
        data["mainCountingUnitId"] = this.mainCountingUnitId;
        data["mainCountingUnitName"] = this.mainCountingUnitName;
        data["commonCountingUnitId"] = this.commonCountingUnitId;
        data["commonCountingUnitName"] = this.commonCountingUnitName;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["productCategoryId"] = this.productCategoryId;
        data["productCategoryName"] = this.productCategoryName;
        data["productAttributeTypeId"] = this.productAttributeTypeId;
        data["productAttributeTypeName"] = this.productAttributeTypeName;
        data["colorOptionId"] = this.colorOptionId;
        data["colorOptionName"] = this.colorOptionName;
        data["materialOptionId"] = this.materialOptionId;
        data["materialOptionName"] = this.materialOptionName;
        data["isActive"] = this.isActive;
        data["compatibility"] = this.compatibility;
        data["compatibilityName"] = this.compatibilityName;
        return data;
    }
}

export interface IBackOfficeProductDto {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    mileage?: number | undefined;
    duration?: number | undefined;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    providerId?: number | undefined;
    providerName?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    productTypeId?: number | undefined;
    productTypeName?: string | undefined;
    productStatusId?: number | undefined;
    productStatusName?: string | undefined;
    mainCountingUnitId?: number | undefined;
    mainCountingUnitName?: string | undefined;
    commonCountingUnitId?: number | undefined;
    commonCountingUnitName?: string | undefined;
    brandId?: number;
    brandName?: string;
    productCategoryId?: number;
    productCategoryName?: string;
    productAttributeTypeId?: number | undefined;
    productAttributeTypeName?: string;
    colorOptionId?: number | undefined;
    colorOptionName?: string | undefined;
    materialOptionId?: number | undefined;
    materialOptionName?: string | undefined;
    isActive?: boolean;
    compatibility?: CompatibilityEnum;
    compatibilityName?: string;
}

export enum CompatibilityEnum {
    All = 0,
    Unknown = 1,
    Compatible = 2,
}

export class ProductDto implements IProductDto {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    directSalesLicense?: boolean;
    provider?: ProviderDto | undefined;
    country?: CountryDto | undefined;
    productType?: ProductTypeDto | undefined;
    productStatus?: ProductStatusDto | undefined;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    images?: ProductImageDto[];
    compatibility?: CompatibilityEnum;
    productAttributeType?: ProductAttributeTypeDto;
    tags?: TagDto[];
    attributes?: ProductAttributeDto[];
    attributeOptions?: ProductAttributeOptionForProductDto[];
    colorOption?: ProductOptionColorDto | undefined;
    materialOption?: ProductOptionMaterialDto | undefined;
    productCustomFields?: ProductCustomFieldDto[];
    reviews?: ReviewForProductDto[];
    productBrand?: BrandForProductDto;
    productCategory?: ProductCategoryForProductDto;
    kindIds?: number[];
    selectedProductAttributeOption?: ProductAttributeOptionForProductDto | undefined;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.productNo = _data["productNo"];
            this.oldProductNo = _data["oldProductNo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.productCatalog = _data["productCatalog"];
            this.orderRate = _data["orderRate"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.length = _data["length"];
            this.netWeight = _data["netWeight"];
            this.grossWeight = _data["grossWeight"];
            this.volumeWeight = _data["volumeWeight"];
            this.mileage = _data["mileage"];
            this.duration = _data["duration"];
            this.directSalesLicense = _data["directSalesLicense"];
            this.provider = _data["provider"] ? ProviderDto.fromJS(_data["provider"]) : <any>undefined;
            this.country = _data["country"] ? CountryDto.fromJS(_data["country"]) : <any>undefined;
            this.productType = _data["productType"] ? ProductTypeDto.fromJS(_data["productType"]) : <any>undefined;
            this.productStatus = _data["productStatus"] ? ProductStatusDto.fromJS(_data["productStatus"]) : <any>undefined;
            this.excerpt = _data["excerpt"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ProductImageDto.fromJS(item));
            }
            this.compatibility = _data["compatibility"];
            this.productAttributeType = _data["productAttributeType"] ? ProductAttributeTypeDto.fromJS(_data["productAttributeType"]) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagDto.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ProductAttributeDto.fromJS(item));
            }
            if (Array.isArray(_data["attributeOptions"])) {
                this.attributeOptions = [] as any;
                for (let item of _data["attributeOptions"])
                    this.attributeOptions!.push(ProductAttributeOptionForProductDto.fromJS(item));
            }
            this.colorOption = _data["colorOption"] ? ProductOptionColorDto.fromJS(_data["colorOption"]) : <any>undefined;
            this.materialOption = _data["materialOption"] ? ProductOptionMaterialDto.fromJS(_data["materialOption"]) : <any>undefined;
            if (Array.isArray(_data["productCustomFields"])) {
                this.productCustomFields = [] as any;
                for (let item of _data["productCustomFields"])
                    this.productCustomFields!.push(ProductCustomFieldDto.fromJS(item));
            }
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(ReviewForProductDto.fromJS(item));
            }
            this.productBrand = _data["productBrand"] ? BrandForProductDto.fromJS(_data["productBrand"]) : <any>undefined;
            this.productCategory = _data["productCategory"] ? ProductCategoryForProductDto.fromJS(_data["productCategory"]) : <any>undefined;
            if (Array.isArray(_data["kindIds"])) {
                this.kindIds = [] as any;
                for (let item of _data["kindIds"])
                    this.kindIds!.push(item);
            }
            this.selectedProductAttributeOption = _data["selectedProductAttributeOption"] ? ProductAttributeOptionForProductDto.fromJS(_data["selectedProductAttributeOption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["productNo"] = this.productNo;
        data["oldProductNo"] = this.oldProductNo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["productCatalog"] = this.productCatalog;
        data["orderRate"] = this.orderRate;
        data["height"] = this.height;
        data["width"] = this.width;
        data["length"] = this.length;
        data["netWeight"] = this.netWeight;
        data["grossWeight"] = this.grossWeight;
        data["volumeWeight"] = this.volumeWeight;
        data["mileage"] = this.mileage;
        data["duration"] = this.duration;
        data["directSalesLicense"] = this.directSalesLicense;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>undefined;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["productType"] = this.productType ? this.productType.toJSON() : <any>undefined;
        data["productStatus"] = this.productStatus ? this.productStatus.toJSON() : <any>undefined;
        data["excerpt"] = this.excerpt;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["compatibility"] = this.compatibility;
        data["productAttributeType"] = this.productAttributeType ? this.productAttributeType.toJSON() : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (Array.isArray(this.attributeOptions)) {
            data["attributeOptions"] = [];
            for (let item of this.attributeOptions)
                data["attributeOptions"].push(item.toJSON());
        }
        data["colorOption"] = this.colorOption ? this.colorOption.toJSON() : <any>undefined;
        data["materialOption"] = this.materialOption ? this.materialOption.toJSON() : <any>undefined;
        if (Array.isArray(this.productCustomFields)) {
            data["productCustomFields"] = [];
            for (let item of this.productCustomFields)
                data["productCustomFields"].push(item.toJSON());
        }
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        data["productBrand"] = this.productBrand ? this.productBrand.toJSON() : <any>undefined;
        data["productCategory"] = this.productCategory ? this.productCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.kindIds)) {
            data["kindIds"] = [];
            for (let item of this.kindIds)
                data["kindIds"].push(item);
        }
        data["selectedProductAttributeOption"] = this.selectedProductAttributeOption ? this.selectedProductAttributeOption.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDto {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    directSalesLicense?: boolean;
    provider?: ProviderDto | undefined;
    country?: CountryDto | undefined;
    productType?: ProductTypeDto | undefined;
    productStatus?: ProductStatusDto | undefined;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    images?: ProductImageDto[];
    compatibility?: CompatibilityEnum;
    productAttributeType?: ProductAttributeTypeDto;
    tags?: TagDto[];
    attributes?: ProductAttributeDto[];
    attributeOptions?: ProductAttributeOptionForProductDto[];
    colorOption?: ProductOptionColorDto | undefined;
    materialOption?: ProductOptionMaterialDto | undefined;
    productCustomFields?: ProductCustomFieldDto[];
    reviews?: ReviewForProductDto[];
    productBrand?: BrandForProductDto;
    productCategory?: ProductCategoryForProductDto;
    kindIds?: number[];
    selectedProductAttributeOption?: ProductAttributeOptionForProductDto | undefined;
}

export class ProviderDto implements IProviderDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;

    constructor(data?: IProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.localizedCode = _data["localizedCode"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["localizedCode"] = this.localizedCode;
        data["description"] = this.description;
        return data;
    }
}

export interface IProviderDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;
}

export class CountryDto implements ICountryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    code?: number;
    isActive?: boolean;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICountryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    code?: number;
    isActive?: boolean;
}

export class ProductTypeDto implements IProductTypeDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IProductTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): ProductTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IProductTypeDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class ProductStatusDto implements IProductStatusDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IProductStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): ProductStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IProductStatusDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class ProductImageDto implements IProductImageDto {
    id?: number;
    productId?: number;
    image?: string | undefined;
    order?: number;
    isActive?: boolean;

    constructor(data?: IProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.image = _data["image"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["image"] = this.image;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductImageDto {
    id?: number;
    productId?: number;
    image?: string | undefined;
    order?: number;
    isActive?: boolean;
}

export class ProductAttributeTypeDto implements IProductAttributeTypeDto {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: ProductTypeAttributeGroupDto[];

    constructor(data?: IProductAttributeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["attributeGroups"])) {
                this.attributeGroups = [] as any;
                for (let item of _data["attributeGroups"])
                    this.attributeGroups!.push(ProductTypeAttributeGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttributeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.attributeGroups)) {
            data["attributeGroups"] = [];
            for (let item of this.attributeGroups)
                data["attributeGroups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAttributeTypeDto {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: ProductTypeAttributeGroupDto[];
}

export class ProductTypeAttributeGroupDto implements IProductTypeAttributeGroupDto {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto[];
    attributes?: ProductTypeAttributeGroupAttributeDto[];

    constructor(data?: IProductTypeAttributeGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["productTypeAttributeGroupCustomFields"])) {
                this.productTypeAttributeGroupCustomFields = [] as any;
                for (let item of _data["productTypeAttributeGroupCustomFields"])
                    this.productTypeAttributeGroupCustomFields!.push(ProductTypeAttributeGroupCustomFieldDto.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ProductTypeAttributeGroupAttributeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.productTypeAttributeGroupCustomFields)) {
            data["productTypeAttributeGroupCustomFields"] = [];
            for (let item of this.productTypeAttributeGroupCustomFields)
                data["productTypeAttributeGroupCustomFields"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductTypeAttributeGroupDto {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto[];
    attributes?: ProductTypeAttributeGroupAttributeDto[];
}

export class ProductTypeAttributeGroupCustomFieldDto implements IProductTypeAttributeGroupCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;

    constructor(data?: IProductTypeAttributeGroupCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductTypeAttributeGroupCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;
}

export class ProductTypeAttributeGroupAttributeDto implements IProductTypeAttributeGroupAttributeDto {
    id?: number;
    value?: string;

    constructor(data?: IProductTypeAttributeGroupAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductTypeAttributeGroupAttributeDto {
    id?: number;
    value?: string;
}

export class TagDto implements ITagDto {
    id?: number;
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;

    constructor(data?: ITagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.enTitle = _data["enTitle"];
            this.faTitle = _data["faTitle"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["enTitle"] = this.enTitle;
        data["faTitle"] = this.faTitle;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITagDto {
    id?: number;
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;
}

export class ProductAttributeDto implements IProductAttributeDto {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    productAttributeCustomFields?: ProductAttributeCustomFieldDto[];
    valueName?: string;
    valueSlug?: string;
    productAttributeValueCustomFields?: ProductAttributeValueCustomFieldDto[];

    constructor(data?: IProductAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.featured = _data["featured"];
            if (Array.isArray(_data["productAttributeCustomFields"])) {
                this.productAttributeCustomFields = [] as any;
                for (let item of _data["productAttributeCustomFields"])
                    this.productAttributeCustomFields!.push(ProductAttributeCustomFieldDto.fromJS(item));
            }
            this.valueName = _data["valueName"];
            this.valueSlug = _data["valueSlug"];
            if (Array.isArray(_data["productAttributeValueCustomFields"])) {
                this.productAttributeValueCustomFields = [] as any;
                for (let item of _data["productAttributeValueCustomFields"])
                    this.productAttributeValueCustomFields!.push(ProductAttributeValueCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["featured"] = this.featured;
        if (Array.isArray(this.productAttributeCustomFields)) {
            data["productAttributeCustomFields"] = [];
            for (let item of this.productAttributeCustomFields)
                data["productAttributeCustomFields"].push(item.toJSON());
        }
        data["valueName"] = this.valueName;
        data["valueSlug"] = this.valueSlug;
        if (Array.isArray(this.productAttributeValueCustomFields)) {
            data["productAttributeValueCustomFields"] = [];
            for (let item of this.productAttributeValueCustomFields)
                data["productAttributeValueCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAttributeDto {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    productAttributeCustomFields?: ProductAttributeCustomFieldDto[];
    valueName?: string;
    valueSlug?: string;
    productAttributeValueCustomFields?: ProductAttributeValueCustomFieldDto[];
}

export class ProductAttributeCustomFieldDto implements IProductAttributeCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;

    constructor(data?: IProductAttributeCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductAttributeCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductAttributeCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;
}

export class ProductAttributeValueCustomFieldDto implements IProductAttributeValueCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;

    constructor(data?: IProductAttributeValueCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductAttributeValueCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeValueCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductAttributeValueCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;
}

export class ProductAttributeOptionForProductDto implements IProductAttributeOptionForProductDto {
    id?: number;
    totalCount?: number;
    safetyStockQty?: number;
    minStockQty?: number;
    maxStockQty?: number;
    prices?: PriceDto2[];
    maxSalePriceNonCompanyProductPercent?: number | undefined;
    badges?: BadgeDto[];
    optionValues?: ProductAttributeOptionValueDto[];
    isDefault?: boolean;
    productId?: number;
    productAttributeOptionRoles?: ProductAttributeOptionRoleDto[];

    constructor(data?: IProductAttributeOptionForProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.totalCount = _data["totalCount"];
            this.safetyStockQty = _data["safetyStockQty"];
            this.minStockQty = _data["minStockQty"];
            this.maxStockQty = _data["maxStockQty"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(PriceDto2.fromJS(item));
            }
            this.maxSalePriceNonCompanyProductPercent = _data["maxSalePriceNonCompanyProductPercent"];
            if (Array.isArray(_data["badges"])) {
                this.badges = [] as any;
                for (let item of _data["badges"])
                    this.badges!.push(BadgeDto.fromJS(item));
            }
            if (Array.isArray(_data["optionValues"])) {
                this.optionValues = [] as any;
                for (let item of _data["optionValues"])
                    this.optionValues!.push(ProductAttributeOptionValueDto.fromJS(item));
            }
            this.isDefault = _data["isDefault"];
            this.productId = _data["productId"];
            if (Array.isArray(_data["productAttributeOptionRoles"])) {
                this.productAttributeOptionRoles = [] as any;
                for (let item of _data["productAttributeOptionRoles"])
                    this.productAttributeOptionRoles!.push(ProductAttributeOptionRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttributeOptionForProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionForProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["totalCount"] = this.totalCount;
        data["safetyStockQty"] = this.safetyStockQty;
        data["minStockQty"] = this.minStockQty;
        data["maxStockQty"] = this.maxStockQty;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        data["maxSalePriceNonCompanyProductPercent"] = this.maxSalePriceNonCompanyProductPercent;
        if (Array.isArray(this.badges)) {
            data["badges"] = [];
            for (let item of this.badges)
                data["badges"].push(item.toJSON());
        }
        if (Array.isArray(this.optionValues)) {
            data["optionValues"] = [];
            for (let item of this.optionValues)
                data["optionValues"].push(item.toJSON());
        }
        data["isDefault"] = this.isDefault;
        data["productId"] = this.productId;
        if (Array.isArray(this.productAttributeOptionRoles)) {
            data["productAttributeOptionRoles"] = [];
            for (let item of this.productAttributeOptionRoles)
                data["productAttributeOptionRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAttributeOptionForProductDto {
    id?: number;
    totalCount?: number;
    safetyStockQty?: number;
    minStockQty?: number;
    maxStockQty?: number;
    prices?: PriceDto2[];
    maxSalePriceNonCompanyProductPercent?: number | undefined;
    badges?: BadgeDto[];
    optionValues?: ProductAttributeOptionValueDto[];
    isDefault?: boolean;
    productId?: number;
    productAttributeOptionRoles?: ProductAttributeOptionRoleDto[];
}

export class PriceDto2 implements IPriceDto2 {
    id?: number;
    date?: Date;
    mainPrice?: number;
    productAttributeOptionId?: number;

    constructor(data?: IPriceDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.mainPrice = _data["mainPrice"];
            this.productAttributeOptionId = _data["productAttributeOptionId"];
        }
    }

    static fromJS(data: any): PriceDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new PriceDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["mainPrice"] = this.mainPrice;
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        return data;
    }
}

export interface IPriceDto2 {
    id?: number;
    date?: Date;
    mainPrice?: number;
    productAttributeOptionId?: number;
}

export class ProductAttributeOptionValueDto implements IProductAttributeOptionValueDto {
    id?: number;
    productAttributeOptionId?: number;
    name?: string;
    value?: string;

    constructor(data?: IProductAttributeOptionValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productAttributeOptionId = _data["productAttributeOptionId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductAttributeOptionValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductAttributeOptionValueDto {
    id?: number;
    productAttributeOptionId?: number;
    name?: string;
    value?: string;
}

export class ProductAttributeOptionRoleDto implements IProductAttributeOptionRoleDto {
    id?: number;
    minimumStockToDisplayProductForThisCustomerTypeEnum?: number;
    availability?: AvailabilityEnum;
    availabilityName?: string;
    mainMaxOrderQty?: number;
    currentMaxOrderQty?: number;
    mainMinOrderQty?: number;
    currentMinOrderQty?: number;
    customerTypeEnum?: CustomerTypeEnum;
    customerTypeEnumName?: string;
    discountPercent?: number;

    constructor(data?: IProductAttributeOptionRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.minimumStockToDisplayProductForThisCustomerTypeEnum = _data["minimumStockToDisplayProductForThisCustomerTypeEnum"];
            this.availability = _data["availability"];
            this.availabilityName = _data["availabilityName"];
            this.mainMaxOrderQty = _data["mainMaxOrderQty"];
            this.currentMaxOrderQty = _data["currentMaxOrderQty"];
            this.mainMinOrderQty = _data["mainMinOrderQty"];
            this.currentMinOrderQty = _data["currentMinOrderQty"];
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.customerTypeEnumName = _data["customerTypeEnumName"];
            this.discountPercent = _data["discountPercent"];
        }
    }

    static fromJS(data: any): ProductAttributeOptionRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["minimumStockToDisplayProductForThisCustomerTypeEnum"] = this.minimumStockToDisplayProductForThisCustomerTypeEnum;
        data["availability"] = this.availability;
        data["availabilityName"] = this.availabilityName;
        data["mainMaxOrderQty"] = this.mainMaxOrderQty;
        data["currentMaxOrderQty"] = this.currentMaxOrderQty;
        data["mainMinOrderQty"] = this.mainMinOrderQty;
        data["currentMinOrderQty"] = this.currentMinOrderQty;
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["customerTypeEnumName"] = this.customerTypeEnumName;
        data["discountPercent"] = this.discountPercent;
        return data;
    }
}

export interface IProductAttributeOptionRoleDto {
    id?: number;
    minimumStockToDisplayProductForThisCustomerTypeEnum?: number;
    availability?: AvailabilityEnum;
    availabilityName?: string;
    mainMaxOrderQty?: number;
    currentMaxOrderQty?: number;
    mainMinOrderQty?: number;
    currentMinOrderQty?: number;
    customerTypeEnum?: CustomerTypeEnum;
    customerTypeEnumName?: string;
    discountPercent?: number;
}

export enum AvailabilityEnum {
    InStock = 0,
    OutOfStock = 1,
}

export class ProductOptionColorDto implements IProductOptionColorDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueColorDto[];

    constructor(data?: IProductOptionColorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProductOptionValueColorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductOptionColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductOptionColorDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueColorDto[];
}

export enum ProductOptionTypeEnum {
    Color = 1,
    Material = 2,
    Provider = 3,
}

export class ProductOptionValueColorDto implements IProductOptionValueColorDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;

    constructor(data?: IProductOptionValueColorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): ProductOptionValueColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionValueColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["color"] = this.color;
        return data;
    }
}

export interface IProductOptionValueColorDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;
}

export class ProductOptionMaterialDto implements IProductOptionMaterialDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueMaterialDto[];

    constructor(data?: IProductOptionMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProductOptionValueMaterialDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductOptionMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductOptionMaterialDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueMaterialDto[];
}

export class ProductOptionValueMaterialDto implements IProductOptionValueMaterialDto {
    id?: number;
    name?: string;
    slug?: string;

    constructor(data?: IProductOptionValueMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): ProductOptionValueMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionValueMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IProductOptionValueMaterialDto {
    id?: number;
    name?: string;
    slug?: string;
}

export class ProductCustomFieldDto implements IProductCustomFieldDto {
    fieldName?: string;
    value?: string;

    constructor(data?: IProductCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductCustomFieldDto {
    fieldName?: string;
    value?: string;
}

export class ReviewForProductDto implements IReviewForProductDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    isActive?: boolean;

    constructor(data?: IReviewForProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.rating = _data["rating"];
            this.content = _data["content"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ReviewForProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewForProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["rating"] = this.rating;
        data["content"] = this.content;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IReviewForProductDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    isActive?: boolean;
}

export class BrandForProductDto implements IBrandForProductDto {
    id?: number;
    brandLogo?: string;
    localizedName?: string | undefined;
    name?: string;
    code?: number;
    slug?: string | undefined;
    country?: CountryDto | undefined;

    constructor(data?: IBrandForProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.slug = _data["slug"];
            this.country = _data["country"] ? CountryDto.fromJS(_data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BrandForProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandForProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["code"] = this.code;
        data["slug"] = this.slug;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBrandForProductDto {
    id?: number;
    brandLogo?: string;
    localizedName?: string | undefined;
    name?: string;
    code?: number;
    slug?: string | undefined;
    country?: CountryDto | undefined;
}

export class ProductCategoryForProductDto implements IProductCategoryForProductDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productSubCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productSubCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductCategoryForProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productSubCategoryNo = _data["productSubCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["productSubCategoryCustomFields"])) {
                this.productSubCategoryCustomFields = [] as any;
                for (let item of _data["productSubCategoryCustomFields"])
                    this.productSubCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategoryForProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryForProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productSubCategoryNo"] = this.productSubCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.productSubCategoryCustomFields)) {
            data["productSubCategoryCustomFields"] = [];
            for (let item of this.productSubCategoryCustomFields)
                data["productSubCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductCategoryForProductDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productSubCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productSubCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export enum CategoryTypeEnum {
    ProductCategory = 0,
    BlogCategory = 1,
}

export class ProductCategoryCustomFieldDto implements IProductCategoryCustomFieldDto {
    fieldName?: string;
    value?: string;

    constructor(data?: IProductCategoryCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductCategoryCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductCategoryCustomFieldDto {
    fieldName?: string;
    value?: string;
}

export class GetAllProductsQuery implements IGetAllProductsQuery {
    customerTypeEnum?: CustomerTypeEnum;

    constructor(data?: IGetAllProductsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerTypeEnum = _data["customerTypeEnum"];
        }
    }

    static fromJS(data: any): GetAllProductsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllProductsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerTypeEnum"] = this.customerTypeEnum;
        return data;
    }
}

export interface IGetAllProductsQuery {
    customerTypeEnum?: CustomerTypeEnum;
}

export class FilteredProductDto implements IFilteredProductDto {
    products?: BackOfficeProductDto[];
    count?: number;

    constructor(data?: IFilteredProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(BackOfficeProductDto.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): FilteredProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IFilteredProductDto {
    products?: BackOfficeProductDto[];
    count?: number;
}

export class GetProductsByKindIdQuery implements IGetProductsByKindIdQuery {
    kindId?: number;
    customerTypeEnum?: CustomerTypeEnum;

    constructor(data?: IGetProductsByKindIdQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kindId = _data["kindId"];
            this.customerTypeEnum = _data["customerTypeEnum"];
        }
    }

    static fromJS(data: any): GetProductsByKindIdQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductsByKindIdQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kindId"] = this.kindId;
        data["customerTypeEnum"] = this.customerTypeEnum;
        return data;
    }
}

export interface IGetProductsByKindIdQuery {
    kindId?: number;
    customerTypeEnum?: CustomerTypeEnum;
}

export class GetProductsByBrandIdQuery implements IGetProductsByBrandIdQuery {
    brandId?: number;
    customerTypeEnum?: CustomerTypeEnum;

    constructor(data?: IGetProductsByBrandIdQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.customerTypeEnum = _data["customerTypeEnum"];
        }
    }

    static fromJS(data: any): GetProductsByBrandIdQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductsByBrandIdQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["customerTypeEnum"] = this.customerTypeEnum;
        return data;
    }
}

export interface IGetProductsByBrandIdQuery {
    brandId?: number;
    customerTypeEnum?: CustomerTypeEnum;
}

export class GetProductByIdQuery implements IGetProductByIdQuery {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;

    constructor(data?: IGetProductByIdQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerTypeEnum = _data["customerTypeEnum"];
        }
    }

    static fromJS(data: any): GetProductByIdQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductByIdQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerTypeEnum"] = this.customerTypeEnum;
        return data;
    }
}

export interface IGetProductByIdQuery {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
}

export class CreateProductCommand implements ICreateProductCommand {
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    providerId?: number | undefined;
    countryId?: number | undefined;
    productTypeId?: number | undefined;
    productStatusId?: number | undefined;
    mainCountingUnitId?: number | undefined;
    commonCountingUnitId?: number | undefined;
    productBrandId?: number;
    productCategoryId?: number;
    productAttributeTypeId?: number;
    productOptionColorId?: number | undefined;
    productOptionMaterialId?: number | undefined;
    excerpt?: string;
    description?: string;
    sku?: string | undefined;
    compatibility?: number;
    isActive?: boolean;

    constructor(data?: ICreateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.productNo = _data["productNo"];
            this.oldProductNo = _data["oldProductNo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.productCatalog = _data["productCatalog"];
            this.orderRate = _data["orderRate"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.length = _data["length"];
            this.netWeight = _data["netWeight"];
            this.grossWeight = _data["grossWeight"];
            this.volumeWeight = _data["volumeWeight"];
            this.mileage = _data["mileage"];
            this.duration = _data["duration"];
            this.providerId = _data["providerId"];
            this.countryId = _data["countryId"];
            this.productTypeId = _data["productTypeId"];
            this.productStatusId = _data["productStatusId"];
            this.mainCountingUnitId = _data["mainCountingUnitId"];
            this.commonCountingUnitId = _data["commonCountingUnitId"];
            this.productBrandId = _data["productBrandId"];
            this.productCategoryId = _data["productCategoryId"];
            this.productAttributeTypeId = _data["productAttributeTypeId"];
            this.productOptionColorId = _data["productOptionColorId"];
            this.productOptionMaterialId = _data["productOptionMaterialId"];
            this.excerpt = _data["excerpt"];
            this.description = _data["description"];
            this.sku = _data["sku"];
            this.compatibility = _data["compatibility"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["productNo"] = this.productNo;
        data["oldProductNo"] = this.oldProductNo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["productCatalog"] = this.productCatalog;
        data["orderRate"] = this.orderRate;
        data["height"] = this.height;
        data["width"] = this.width;
        data["length"] = this.length;
        data["netWeight"] = this.netWeight;
        data["grossWeight"] = this.grossWeight;
        data["volumeWeight"] = this.volumeWeight;
        data["mileage"] = this.mileage;
        data["duration"] = this.duration;
        data["providerId"] = this.providerId;
        data["countryId"] = this.countryId;
        data["productTypeId"] = this.productTypeId;
        data["productStatusId"] = this.productStatusId;
        data["mainCountingUnitId"] = this.mainCountingUnitId;
        data["commonCountingUnitId"] = this.commonCountingUnitId;
        data["productBrandId"] = this.productBrandId;
        data["productCategoryId"] = this.productCategoryId;
        data["productAttributeTypeId"] = this.productAttributeTypeId;
        data["productOptionColorId"] = this.productOptionColorId;
        data["productOptionMaterialId"] = this.productOptionMaterialId;
        data["excerpt"] = this.excerpt;
        data["description"] = this.description;
        data["sku"] = this.sku;
        data["compatibility"] = this.compatibility;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateProductCommand {
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    providerId?: number | undefined;
    countryId?: number | undefined;
    productTypeId?: number | undefined;
    productStatusId?: number | undefined;
    mainCountingUnitId?: number | undefined;
    commonCountingUnitId?: number | undefined;
    productBrandId?: number;
    productCategoryId?: number;
    productAttributeTypeId?: number;
    productOptionColorId?: number | undefined;
    productOptionMaterialId?: number | undefined;
    excerpt?: string;
    description?: string;
    sku?: string | undefined;
    compatibility?: number;
    isActive?: boolean;
}

export class UpdateProductCommand implements IUpdateProductCommand {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    providerId?: number | undefined;
    countryId?: number | undefined;
    productTypeId?: number | undefined;
    productStatusId?: number | undefined;
    mainCountingUnitId?: number | undefined;
    commonCountingUnitId?: number | undefined;
    productBrandId?: number;
    productCategoryId?: number;
    productAttributeTypeId?: number;
    productOptionColorId?: number | undefined;
    productOptionMaterialId?: number | undefined;
    excerpt?: string;
    description?: string;
    sku?: string | undefined;
    compatibility?: number;
    isActive?: boolean;

    constructor(data?: IUpdateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.productNo = _data["productNo"];
            this.oldProductNo = _data["oldProductNo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.productCatalog = _data["productCatalog"];
            this.orderRate = _data["orderRate"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.length = _data["length"];
            this.netWeight = _data["netWeight"];
            this.grossWeight = _data["grossWeight"];
            this.volumeWeight = _data["volumeWeight"];
            this.mileage = _data["mileage"];
            this.duration = _data["duration"];
            this.providerId = _data["providerId"];
            this.countryId = _data["countryId"];
            this.productTypeId = _data["productTypeId"];
            this.productStatusId = _data["productStatusId"];
            this.mainCountingUnitId = _data["mainCountingUnitId"];
            this.commonCountingUnitId = _data["commonCountingUnitId"];
            this.productBrandId = _data["productBrandId"];
            this.productCategoryId = _data["productCategoryId"];
            this.productAttributeTypeId = _data["productAttributeTypeId"];
            this.productOptionColorId = _data["productOptionColorId"];
            this.productOptionMaterialId = _data["productOptionMaterialId"];
            this.excerpt = _data["excerpt"];
            this.description = _data["description"];
            this.sku = _data["sku"];
            this.compatibility = _data["compatibility"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["productNo"] = this.productNo;
        data["oldProductNo"] = this.oldProductNo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["productCatalog"] = this.productCatalog;
        data["orderRate"] = this.orderRate;
        data["height"] = this.height;
        data["width"] = this.width;
        data["length"] = this.length;
        data["netWeight"] = this.netWeight;
        data["grossWeight"] = this.grossWeight;
        data["volumeWeight"] = this.volumeWeight;
        data["mileage"] = this.mileage;
        data["duration"] = this.duration;
        data["providerId"] = this.providerId;
        data["countryId"] = this.countryId;
        data["productTypeId"] = this.productTypeId;
        data["productStatusId"] = this.productStatusId;
        data["mainCountingUnitId"] = this.mainCountingUnitId;
        data["commonCountingUnitId"] = this.commonCountingUnitId;
        data["productBrandId"] = this.productBrandId;
        data["productCategoryId"] = this.productCategoryId;
        data["productAttributeTypeId"] = this.productAttributeTypeId;
        data["productOptionColorId"] = this.productOptionColorId;
        data["productOptionMaterialId"] = this.productOptionMaterialId;
        data["excerpt"] = this.excerpt;
        data["description"] = this.description;
        data["sku"] = this.sku;
        data["compatibility"] = this.compatibility;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateProductCommand {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    providerId?: number | undefined;
    countryId?: number | undefined;
    productTypeId?: number | undefined;
    productStatusId?: number | undefined;
    mainCountingUnitId?: number | undefined;
    commonCountingUnitId?: number | undefined;
    productBrandId?: number;
    productCategoryId?: number;
    productAttributeTypeId?: number;
    productOptionColorId?: number | undefined;
    productOptionMaterialId?: number | undefined;
    excerpt?: string;
    description?: string;
    sku?: string | undefined;
    compatibility?: number;
    isActive?: boolean;
}

export class PaginatedListOfProductStatusDto implements IPaginatedListOfProductStatusDto {
    items?: ProductStatusDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductStatusDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductStatusDto {
    items?: ProductStatusDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AllProductStatusDropDownDto implements IAllProductStatusDropDownDto {
    id?: number;
    localizedName?: string;

    constructor(data?: IAllProductStatusDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllProductStatusDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductStatusDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllProductStatusDropDownDto {
    id?: number;
    localizedName?: string;
}

export class CreateProductStatusCommand implements ICreateProductStatusCommand {
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: ICreateProductStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): CreateProductStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface ICreateProductStatusCommand {
    code?: number;
    name?: string;
    localizedName?: string;
}

export class UpdateProductStatusCommand implements IUpdateProductStatusCommand {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IUpdateProductStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): UpdateProductStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IUpdateProductStatusCommand {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class PaginatedListOfProductTypeDto implements IPaginatedListOfProductTypeDto {
    items?: ProductTypeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductTypeDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductTypeDto {
    items?: ProductTypeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AllProductTypeDropDownDto implements IAllProductTypeDropDownDto {
    id?: number;
    localizedName?: string;

    constructor(data?: IAllProductTypeDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllProductTypeDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductTypeDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllProductTypeDropDownDto {
    id?: number;
    localizedName?: string;
}

export class CreateProductTypeCommand implements ICreateProductTypeCommand {
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: ICreateProductTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): CreateProductTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface ICreateProductTypeCommand {
    code?: number;
    name?: string;
    localizedName?: string;
}

export class UpdateProductTypeCommand implements IUpdateProductTypeCommand {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IUpdateProductTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): UpdateProductTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IUpdateProductTypeCommand {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class FilteredProviderDto implements IFilteredProviderDto {
    providers?: ProviderDto[];
    count?: number;

    constructor(data?: IFilteredProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["providers"])) {
                this.providers = [] as any;
                for (let item of _data["providers"])
                    this.providers!.push(ProviderDto.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): FilteredProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.providers)) {
            data["providers"] = [];
            for (let item of this.providers)
                data["providers"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IFilteredProviderDto {
    providers?: ProviderDto[];
    count?: number;
}

export class AllProviderDropDownDto implements IAllProviderDropDownDto {
    id?: number;
    localizedName?: string;

    constructor(data?: IAllProviderDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllProviderDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProviderDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllProviderDropDownDto {
    id?: number;
    localizedName?: string;
}

export class CreateProviderCommand implements ICreateProviderCommand {
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateProviderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.localizedCode = _data["localizedCode"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateProviderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProviderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["localizedCode"] = this.localizedCode;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateProviderCommand {
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;
}

export class UpdateProviderCommand implements IUpdateProviderCommand {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateProviderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.localizedCode = _data["localizedCode"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateProviderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProviderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["localizedCode"] = this.localizedCode;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateProviderCommand {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;
}

export class ReviewDto implements IReviewDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    authorName?: string;
    productName?: string;
    productId?: number;
    customerId?: string;
    isActive?: boolean;

    constructor(data?: IReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.rating = _data["rating"];
            this.content = _data["content"];
            this.authorName = _data["authorName"];
            this.productName = _data["productName"];
            this.productId = _data["productId"];
            this.customerId = _data["customerId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["rating"] = this.rating;
        data["content"] = this.content;
        data["authorName"] = this.authorName;
        data["productName"] = this.productName;
        data["productId"] = this.productId;
        data["customerId"] = this.customerId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IReviewDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    authorName?: string;
    productName?: string;
    productId?: number;
    customerId?: string;
    isActive?: boolean;
}

export class FilteredReviewDto implements IFilteredReviewDto {
    reviews?: ReviewDto[];
    count?: number;

    constructor(data?: IFilteredReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(ReviewDto.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): FilteredReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IFilteredReviewDto {
    reviews?: ReviewDto[];
    count?: number;
}

export class UpdateReviewCommand implements IUpdateReviewCommand {
    id?: number;
    rating?: number;
    content?: string;
    authorName?: string;
    isActive?: boolean;

    constructor(data?: IUpdateReviewCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rating = _data["rating"];
            this.content = _data["content"];
            this.authorName = _data["authorName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateReviewCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReviewCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rating"] = this.rating;
        data["content"] = this.content;
        data["authorName"] = this.authorName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateReviewCommand {
    id?: number;
    rating?: number;
    content?: string;
    authorName?: string;
    isActive?: boolean;
}

export class FilteredTagDto implements IFilteredTagDto {
    tags?: TagDto[];
    count?: number;

    constructor(data?: IFilteredTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagDto.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): FilteredTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IFilteredTagDto {
    tags?: TagDto[];
    count?: number;
}

export class CreateTagCommand implements ICreateTagCommand {
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;
    productIds?: number[];

    constructor(data?: ICreateTagCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enTitle = _data["enTitle"];
            this.faTitle = _data["faTitle"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateTagCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTagCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enTitle"] = this.enTitle;
        data["faTitle"] = this.faTitle;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        return data;
    }
}

export interface ICreateTagCommand {
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;
    productIds?: number[];
}

export class UpdateTagCommand implements IUpdateTagCommand {
    id?: number;
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;
    productIds?: number[];

    constructor(data?: IUpdateTagCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.enTitle = _data["enTitle"];
            this.faTitle = _data["faTitle"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateTagCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTagCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["enTitle"] = this.enTitle;
        data["faTitle"] = this.faTitle;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateTagCommand {
    id?: number;
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;
    productIds?: number[];
}

export class PaginatedListOfProductAttributeOptionRoleDto implements IPaginatedListOfProductAttributeOptionRoleDto {
    items?: ProductAttributeOptionRoleDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductAttributeOptionRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductAttributeOptionRoleDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductAttributeOptionRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductAttributeOptionRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductAttributeOptionRoleDto {
    items?: ProductAttributeOptionRoleDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CreateProductAttributeOptionRoleCommand implements ICreateProductAttributeOptionRoleCommand {
    minimumStockToDisplayProductForThisCustomerTypeEnum?: number;
    mainMaxOrderQty?: number;
    mainMinOrderQty?: number;
    customerTypeEnumId?: number;
    discountPercent?: number;
    productAttributeOptionId?: number;

    constructor(data?: ICreateProductAttributeOptionRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minimumStockToDisplayProductForThisCustomerTypeEnum = _data["minimumStockToDisplayProductForThisCustomerTypeEnum"];
            this.mainMaxOrderQty = _data["mainMaxOrderQty"];
            this.mainMinOrderQty = _data["mainMinOrderQty"];
            this.customerTypeEnumId = _data["customerTypeEnumId"];
            this.discountPercent = _data["discountPercent"];
            this.productAttributeOptionId = _data["productAttributeOptionId"];
        }
    }

    static fromJS(data: any): CreateProductAttributeOptionRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeOptionRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimumStockToDisplayProductForThisCustomerTypeEnum"] = this.minimumStockToDisplayProductForThisCustomerTypeEnum;
        data["mainMaxOrderQty"] = this.mainMaxOrderQty;
        data["mainMinOrderQty"] = this.mainMinOrderQty;
        data["customerTypeEnumId"] = this.customerTypeEnumId;
        data["discountPercent"] = this.discountPercent;
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        return data;
    }
}

export interface ICreateProductAttributeOptionRoleCommand {
    minimumStockToDisplayProductForThisCustomerTypeEnum?: number;
    mainMaxOrderQty?: number;
    mainMinOrderQty?: number;
    customerTypeEnumId?: number;
    discountPercent?: number;
    productAttributeOptionId?: number;
}

export class UpdateProductAttributeOptionRoleCommand implements IUpdateProductAttributeOptionRoleCommand {
    id?: number;
    minimumStockToDisplayProductForThisCustomerTypeEnum?: number;
    mainMaxOrderQty?: number;
    mainMinOrderQty?: number;
    customerTypeEnumId?: number;
    discountPercent?: number;
    productAttributeOptionId?: number;

    constructor(data?: IUpdateProductAttributeOptionRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.minimumStockToDisplayProductForThisCustomerTypeEnum = _data["minimumStockToDisplayProductForThisCustomerTypeEnum"];
            this.mainMaxOrderQty = _data["mainMaxOrderQty"];
            this.mainMinOrderQty = _data["mainMinOrderQty"];
            this.customerTypeEnumId = _data["customerTypeEnumId"];
            this.discountPercent = _data["discountPercent"];
            this.productAttributeOptionId = _data["productAttributeOptionId"];
        }
    }

    static fromJS(data: any): UpdateProductAttributeOptionRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeOptionRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["minimumStockToDisplayProductForThisCustomerTypeEnum"] = this.minimumStockToDisplayProductForThisCustomerTypeEnum;
        data["mainMaxOrderQty"] = this.mainMaxOrderQty;
        data["mainMinOrderQty"] = this.mainMinOrderQty;
        data["customerTypeEnumId"] = this.customerTypeEnumId;
        data["discountPercent"] = this.discountPercent;
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        return data;
    }
}

export interface IUpdateProductAttributeOptionRoleCommand {
    id?: number;
    minimumStockToDisplayProductForThisCustomerTypeEnum?: number;
    mainMaxOrderQty?: number;
    mainMinOrderQty?: number;
    customerTypeEnumId?: number;
    discountPercent?: number;
    productAttributeOptionId?: number;
}

export class CreateProductAttributeOptionCommand implements ICreateProductAttributeOptionCommand {
    totalCount?: number;
    safetyStockQty?: number;
    minStockQty?: number;
    maxStockQty?: number;
    maxSalePriceNonCompanyProductPercent?: number | undefined;
    productAttributeOptionValues?: CreateProductAttributeOptionValueCommand[];
    isDefault?: boolean;
    productId?: number;

    constructor(data?: ICreateProductAttributeOptionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.safetyStockQty = _data["safetyStockQty"];
            this.minStockQty = _data["minStockQty"];
            this.maxStockQty = _data["maxStockQty"];
            this.maxSalePriceNonCompanyProductPercent = _data["maxSalePriceNonCompanyProductPercent"];
            if (Array.isArray(_data["productAttributeOptionValues"])) {
                this.productAttributeOptionValues = [] as any;
                for (let item of _data["productAttributeOptionValues"])
                    this.productAttributeOptionValues!.push(CreateProductAttributeOptionValueCommand.fromJS(item));
            }
            this.isDefault = _data["isDefault"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): CreateProductAttributeOptionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeOptionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["safetyStockQty"] = this.safetyStockQty;
        data["minStockQty"] = this.minStockQty;
        data["maxStockQty"] = this.maxStockQty;
        data["maxSalePriceNonCompanyProductPercent"] = this.maxSalePriceNonCompanyProductPercent;
        if (Array.isArray(this.productAttributeOptionValues)) {
            data["productAttributeOptionValues"] = [];
            for (let item of this.productAttributeOptionValues)
                data["productAttributeOptionValues"].push(item.toJSON());
        }
        data["isDefault"] = this.isDefault;
        data["productId"] = this.productId;
        return data;
    }
}

export interface ICreateProductAttributeOptionCommand {
    totalCount?: number;
    safetyStockQty?: number;
    minStockQty?: number;
    maxStockQty?: number;
    maxSalePriceNonCompanyProductPercent?: number | undefined;
    productAttributeOptionValues?: CreateProductAttributeOptionValueCommand[];
    isDefault?: boolean;
    productId?: number;
}

export class CreateProductAttributeOptionValueCommand implements ICreateProductAttributeOptionValueCommand {
    name?: string;
    value?: string;

    constructor(data?: ICreateProductAttributeOptionValueCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateProductAttributeOptionValueCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeOptionValueCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface ICreateProductAttributeOptionValueCommand {
    name?: string;
    value?: string;
}

export class UpdateProductAttributeOptionCommand implements IUpdateProductAttributeOptionCommand {
    id?: number;
    totalCount?: number;
    safetyStockQty?: number;
    minStockQty?: number;
    maxStockQty?: number;
    maxSalePriceNonCompanyProductPercent?: number | undefined;
    productAttributeOptionValues?: UpdateProductAttributeOptionValueCommand[];
    isDefault?: boolean;
    productId?: number;

    constructor(data?: IUpdateProductAttributeOptionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.totalCount = _data["totalCount"];
            this.safetyStockQty = _data["safetyStockQty"];
            this.minStockQty = _data["minStockQty"];
            this.maxStockQty = _data["maxStockQty"];
            this.maxSalePriceNonCompanyProductPercent = _data["maxSalePriceNonCompanyProductPercent"];
            if (Array.isArray(_data["productAttributeOptionValues"])) {
                this.productAttributeOptionValues = [] as any;
                for (let item of _data["productAttributeOptionValues"])
                    this.productAttributeOptionValues!.push(UpdateProductAttributeOptionValueCommand.fromJS(item));
            }
            this.isDefault = _data["isDefault"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): UpdateProductAttributeOptionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeOptionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["totalCount"] = this.totalCount;
        data["safetyStockQty"] = this.safetyStockQty;
        data["minStockQty"] = this.minStockQty;
        data["maxStockQty"] = this.maxStockQty;
        data["maxSalePriceNonCompanyProductPercent"] = this.maxSalePriceNonCompanyProductPercent;
        if (Array.isArray(this.productAttributeOptionValues)) {
            data["productAttributeOptionValues"] = [];
            for (let item of this.productAttributeOptionValues)
                data["productAttributeOptionValues"].push(item.toJSON());
        }
        data["isDefault"] = this.isDefault;
        data["productId"] = this.productId;
        return data;
    }
}

export interface IUpdateProductAttributeOptionCommand {
    id?: number;
    totalCount?: number;
    safetyStockQty?: number;
    minStockQty?: number;
    maxStockQty?: number;
    maxSalePriceNonCompanyProductPercent?: number | undefined;
    productAttributeOptionValues?: UpdateProductAttributeOptionValueCommand[];
    isDefault?: boolean;
    productId?: number;
}

export class UpdateProductAttributeOptionValueCommand implements IUpdateProductAttributeOptionValueCommand {
    name?: string;
    value?: string;

    constructor(data?: IUpdateProductAttributeOptionValueCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateProductAttributeOptionValueCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeOptionValueCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateProductAttributeOptionValueCommand {
    name?: string;
    value?: string;
}

export class ProductAttributeOptionDto implements IProductAttributeOptionDto {
    id?: number;
    totalCount?: number;
    safetyStockQty?: number;
    minStockQty?: number;
    maxStockQty?: number;
    maxSalePriceNonCompanyProductPercent?: number | undefined;
    isDefault?: boolean;
    optionValues?: ProductAttributeOptionValueDto2[];

    constructor(data?: IProductAttributeOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.totalCount = _data["totalCount"];
            this.safetyStockQty = _data["safetyStockQty"];
            this.minStockQty = _data["minStockQty"];
            this.maxStockQty = _data["maxStockQty"];
            this.maxSalePriceNonCompanyProductPercent = _data["maxSalePriceNonCompanyProductPercent"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["optionValues"])) {
                this.optionValues = [] as any;
                for (let item of _data["optionValues"])
                    this.optionValues!.push(ProductAttributeOptionValueDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttributeOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["totalCount"] = this.totalCount;
        data["safetyStockQty"] = this.safetyStockQty;
        data["minStockQty"] = this.minStockQty;
        data["maxStockQty"] = this.maxStockQty;
        data["maxSalePriceNonCompanyProductPercent"] = this.maxSalePriceNonCompanyProductPercent;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.optionValues)) {
            data["optionValues"] = [];
            for (let item of this.optionValues)
                data["optionValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAttributeOptionDto {
    id?: number;
    totalCount?: number;
    safetyStockQty?: number;
    minStockQty?: number;
    maxStockQty?: number;
    maxSalePriceNonCompanyProductPercent?: number | undefined;
    isDefault?: boolean;
    optionValues?: ProductAttributeOptionValueDto2[];
}

export class ProductAttributeOptionValueDto2 implements IProductAttributeOptionValueDto2 {
    id?: number;
    name?: string;
    value?: string;

    constructor(data?: IProductAttributeOptionValueDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductAttributeOptionValueDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionValueDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductAttributeOptionValueDto2 {
    id?: number;
    name?: string;
    value?: string;
}

export class UpdateProductAttributeOptionValueCommand2 implements IUpdateProductAttributeOptionValueCommand2 {
    id?: number;
    name?: string;
    value?: string;

    constructor(data?: IUpdateProductAttributeOptionValueCommand2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateProductAttributeOptionValueCommand2 {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeOptionValueCommand2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateProductAttributeOptionValueCommand2 {
    id?: number;
    name?: string;
    value?: string;
}

export class AllProductOptionColorDropDownDto implements IAllProductOptionColorDropDownDto {
    id?: number;
    name?: string;

    constructor(data?: IAllProductOptionColorDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AllProductOptionColorDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductOptionColorDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IAllProductOptionColorDropDownDto {
    id?: number;
    name?: string;
}

export class CreateProductOptionColorCommand implements ICreateProductOptionColorCommand {
    name?: string;

    constructor(data?: ICreateProductOptionColorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateProductOptionColorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductOptionColorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateProductOptionColorCommand {
    name?: string;
}

export class UpdateProductOptionColorCommand implements IUpdateProductOptionColorCommand {
    id?: number;
    name?: string;

    constructor(data?: IUpdateProductOptionColorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateProductOptionColorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductOptionColorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateProductOptionColorCommand {
    id?: number;
    name?: string;
}

export class AllProductOptionMaterialDropDownDto implements IAllProductOptionMaterialDropDownDto {
    id?: number;
    name?: string;

    constructor(data?: IAllProductOptionMaterialDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AllProductOptionMaterialDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductOptionMaterialDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IAllProductOptionMaterialDropDownDto {
    id?: number;
    name?: string;
}

export class CreateProductOptionMaterialCommand implements ICreateProductOptionMaterialCommand {
    name?: string;

    constructor(data?: ICreateProductOptionMaterialCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateProductOptionMaterialCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductOptionMaterialCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateProductOptionMaterialCommand {
    name?: string;
}

export class UpdateProductOptionMaterialCommand implements IUpdateProductOptionMaterialCommand {
    id?: number;
    name?: string;

    constructor(data?: IUpdateProductOptionMaterialCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateProductOptionMaterialCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductOptionMaterialCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateProductOptionMaterialCommand {
    id?: number;
    name?: string;
}

export class CreateProductOptionValueColorCommand implements ICreateProductOptionValueColorCommand {
    name?: string;
    color?: string;
    productOptionColorId?: number;

    constructor(data?: ICreateProductOptionValueColorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.color = _data["color"];
            this.productOptionColorId = _data["productOptionColorId"];
        }
    }

    static fromJS(data: any): CreateProductOptionValueColorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductOptionValueColorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["color"] = this.color;
        data["productOptionColorId"] = this.productOptionColorId;
        return data;
    }
}

export interface ICreateProductOptionValueColorCommand {
    name?: string;
    color?: string;
    productOptionColorId?: number;
}

export class UpdateProductOptionValueColorCommand implements IUpdateProductOptionValueColorCommand {
    id?: number;
    name?: string;
    color?: string;
    productOptionColorId?: number;

    constructor(data?: IUpdateProductOptionValueColorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.color = _data["color"];
            this.productOptionColorId = _data["productOptionColorId"];
        }
    }

    static fromJS(data: any): UpdateProductOptionValueColorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductOptionValueColorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["color"] = this.color;
        data["productOptionColorId"] = this.productOptionColorId;
        return data;
    }
}

export interface IUpdateProductOptionValueColorCommand {
    id?: number;
    name?: string;
    color?: string;
    productOptionColorId?: number;
}

export class UpdateProductOptionValueMaterialCommand implements IUpdateProductOptionValueMaterialCommand {
    id?: number;
    name?: string;
    productOptionMaterialId?: number;

    constructor(data?: IUpdateProductOptionValueMaterialCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.productOptionMaterialId = _data["productOptionMaterialId"];
        }
    }

    static fromJS(data: any): UpdateProductOptionValueMaterialCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductOptionValueMaterialCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["productOptionMaterialId"] = this.productOptionMaterialId;
        return data;
    }
}

export interface IUpdateProductOptionValueMaterialCommand {
    id?: number;
    name?: string;
    productOptionMaterialId?: number;
}

export class CreateProductOptionValueMaterialCommand implements ICreateProductOptionValueMaterialCommand {
    name?: string;
    productOptionMaterialId?: number;

    constructor(data?: ICreateProductOptionValueMaterialCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.productOptionMaterialId = _data["productOptionMaterialId"];
        }
    }

    static fromJS(data: any): CreateProductOptionValueMaterialCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductOptionValueMaterialCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["productOptionMaterialId"] = this.productOptionMaterialId;
        return data;
    }
}

export interface ICreateProductOptionValueMaterialCommand {
    name?: string;
    productOptionMaterialId?: number;
}

export class CreateProductAttributeCommand implements ICreateProductAttributeCommand {
    name?: string;
    featured?: boolean;
    productId?: number;
    valueName?: string;

    constructor(data?: ICreateProductAttributeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.featured = _data["featured"];
            this.productId = _data["productId"];
            this.valueName = _data["valueName"];
        }
    }

    static fromJS(data: any): CreateProductAttributeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["featured"] = this.featured;
        data["productId"] = this.productId;
        data["valueName"] = this.valueName;
        return data;
    }
}

export interface ICreateProductAttributeCommand {
    name?: string;
    featured?: boolean;
    productId?: number;
    valueName?: string;
}

export class UpdateProductAttributeCommand implements IUpdateProductAttributeCommand {
    id?: number;
    featured?: boolean;
    valueName?: string;

    constructor(data?: IUpdateProductAttributeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.featured = _data["featured"];
            this.valueName = _data["valueName"];
        }
    }

    static fromJS(data: any): UpdateProductAttributeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["featured"] = this.featured;
        data["valueName"] = this.valueName;
        return data;
    }
}

export interface IUpdateProductAttributeCommand {
    id?: number;
    featured?: boolean;
    valueName?: string;
}

export class AllProductAttributeTypeDropDownDto implements IAllProductAttributeTypeDropDownDto {
    id?: number;
    name?: string;

    constructor(data?: IAllProductAttributeTypeDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AllProductAttributeTypeDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductAttributeTypeDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IAllProductAttributeTypeDropDownDto {
    id?: number;
    name?: string;
}

export class CreateProductAttributeTypeCommand implements ICreateProductAttributeTypeCommand {
    name?: string;

    constructor(data?: ICreateProductAttributeTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateProductAttributeTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateProductAttributeTypeCommand {
    name?: string;
}

export class AddProductAttributeGroupsCommand implements IAddProductAttributeGroupsCommand {
    id?: number;
    attributeGroupIds?: number[];

    constructor(data?: IAddProductAttributeGroupsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["attributeGroupIds"])) {
                this.attributeGroupIds = [] as any;
                for (let item of _data["attributeGroupIds"])
                    this.attributeGroupIds!.push(item);
            }
        }
    }

    static fromJS(data: any): AddProductAttributeGroupsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddProductAttributeGroupsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.attributeGroupIds)) {
            data["attributeGroupIds"] = [];
            for (let item of this.attributeGroupIds)
                data["attributeGroupIds"].push(item);
        }
        return data;
    }
}

export interface IAddProductAttributeGroupsCommand {
    id?: number;
    attributeGroupIds?: number[];
}

export class RemoveProductAttributeGroupsCommand implements IRemoveProductAttributeGroupsCommand {
    id?: number;
    attributeGroupIds?: number[];

    constructor(data?: IRemoveProductAttributeGroupsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["attributeGroupIds"])) {
                this.attributeGroupIds = [] as any;
                for (let item of _data["attributeGroupIds"])
                    this.attributeGroupIds!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoveProductAttributeGroupsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveProductAttributeGroupsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.attributeGroupIds)) {
            data["attributeGroupIds"] = [];
            for (let item of this.attributeGroupIds)
                data["attributeGroupIds"].push(item);
        }
        return data;
    }
}

export interface IRemoveProductAttributeGroupsCommand {
    id?: number;
    attributeGroupIds?: number[];
}

export class UpdateProductAttributeTypeCommand implements IUpdateProductAttributeTypeCommand {
    id?: number;
    name?: string;

    constructor(data?: IUpdateProductAttributeTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateProductAttributeTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateProductAttributeTypeCommand {
    id?: number;
    name?: string;
}

export class AllProductTypeAttributeGroupAttributeDto implements IAllProductTypeAttributeGroupAttributeDto {
    id?: number;
    value?: string;
    productTypeAttributeGroupId?: number;
    productTypeAttributeGroupName?: string;

    constructor(data?: IAllProductTypeAttributeGroupAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.productTypeAttributeGroupId = _data["productTypeAttributeGroupId"];
            this.productTypeAttributeGroupName = _data["productTypeAttributeGroupName"];
        }
    }

    static fromJS(data: any): AllProductTypeAttributeGroupAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductTypeAttributeGroupAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["productTypeAttributeGroupId"] = this.productTypeAttributeGroupId;
        data["productTypeAttributeGroupName"] = this.productTypeAttributeGroupName;
        return data;
    }
}

export interface IAllProductTypeAttributeGroupAttributeDto {
    id?: number;
    value?: string;
    productTypeAttributeGroupId?: number;
    productTypeAttributeGroupName?: string;
}

export class CreateProductTypeAttributeGroupAttributeCommand implements ICreateProductTypeAttributeGroupAttributeCommand {
    value?: string;
    productTypeAttributeGroupId?: number;

    constructor(data?: ICreateProductTypeAttributeGroupAttributeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.productTypeAttributeGroupId = _data["productTypeAttributeGroupId"];
        }
    }

    static fromJS(data: any): CreateProductTypeAttributeGroupAttributeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductTypeAttributeGroupAttributeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["productTypeAttributeGroupId"] = this.productTypeAttributeGroupId;
        return data;
    }
}

export interface ICreateProductTypeAttributeGroupAttributeCommand {
    value?: string;
    productTypeAttributeGroupId?: number;
}

export class UpdateProductTypeAttributeGroupAttributeCommand implements IUpdateProductTypeAttributeGroupAttributeCommand {
    id?: number;
    value?: string;
    productTypeAttributeGroupId?: number;

    constructor(data?: IUpdateProductTypeAttributeGroupAttributeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.productTypeAttributeGroupId = _data["productTypeAttributeGroupId"];
        }
    }

    static fromJS(data: any): UpdateProductTypeAttributeGroupAttributeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductTypeAttributeGroupAttributeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["productTypeAttributeGroupId"] = this.productTypeAttributeGroupId;
        return data;
    }
}

export interface IUpdateProductTypeAttributeGroupAttributeCommand {
    id?: number;
    value?: string;
    productTypeAttributeGroupId?: number;
}

export class AllProductTypeAttributeGroupDropDownDto implements IAllProductTypeAttributeGroupDropDownDto {
    id?: number;
    name?: string;

    constructor(data?: IAllProductTypeAttributeGroupDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AllProductTypeAttributeGroupDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductTypeAttributeGroupDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IAllProductTypeAttributeGroupDropDownDto {
    id?: number;
    name?: string;
}

export class ProductTypeAttributeGroupByProductAttributeTypeIdDto implements IProductTypeAttributeGroupByProductAttributeTypeIdDto {
    id?: number;
    name?: string;

    constructor(data?: IProductTypeAttributeGroupByProductAttributeTypeIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupByProductAttributeTypeIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupByProductAttributeTypeIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IProductTypeAttributeGroupByProductAttributeTypeIdDto {
    id?: number;
    name?: string;
}

export class CreateProductTypeAttributeGroupCommand implements ICreateProductTypeAttributeGroupCommand {
    name?: string;

    constructor(data?: ICreateProductTypeAttributeGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateProductTypeAttributeGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductTypeAttributeGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateProductTypeAttributeGroupCommand {
    name?: string;
}

export class UpdateProductTypeAttributeGroupCommand implements IUpdateProductTypeAttributeGroupCommand {
    id?: number;
    name?: string;

    constructor(data?: IUpdateProductTypeAttributeGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateProductTypeAttributeGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductTypeAttributeGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateProductTypeAttributeGroupCommand {
    id?: number;
    name?: string;
}

export class OrderDto implements IOrderDto {
    id?: number;
    token?: string;
    number?: string;
    quantity?: number;
    subtotal?: number;
    discountPercentForRole?: number;
    total?: number;
    createdAt?: string;
    orderPaymentType?: OrderPaymentType;
    orderPaymentTypeName?: string;
    isPayed?: boolean;
    orderAddress?: string;
    currentOrderStateId?: OrderStatus;
    currentOrderStateName?: string;
    customerTypeEnum?: CustomerTypeEnum;
    customerTypeEnumName?: string;
    phoneNumber?: string;
    fullCustomerName?: string;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.number = _data["number"];
            this.quantity = _data["quantity"];
            this.subtotal = _data["subtotal"];
            this.discountPercentForRole = _data["discountPercentForRole"];
            this.total = _data["total"];
            this.createdAt = _data["createdAt"];
            this.orderPaymentType = _data["orderPaymentType"];
            this.orderPaymentTypeName = _data["orderPaymentTypeName"];
            this.isPayed = _data["isPayed"];
            this.orderAddress = _data["orderAddress"];
            this.currentOrderStateId = _data["currentOrderStateId"];
            this.currentOrderStateName = _data["currentOrderStateName"];
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.customerTypeEnumName = _data["customerTypeEnumName"];
            this.phoneNumber = _data["phoneNumber"];
            this.fullCustomerName = _data["fullCustomerName"];
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["number"] = this.number;
        data["quantity"] = this.quantity;
        data["subtotal"] = this.subtotal;
        data["discountPercentForRole"] = this.discountPercentForRole;
        data["total"] = this.total;
        data["createdAt"] = this.createdAt;
        data["orderPaymentType"] = this.orderPaymentType;
        data["orderPaymentTypeName"] = this.orderPaymentTypeName;
        data["isPayed"] = this.isPayed;
        data["orderAddress"] = this.orderAddress;
        data["currentOrderStateId"] = this.currentOrderStateId;
        data["currentOrderStateName"] = this.currentOrderStateName;
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["customerTypeEnumName"] = this.customerTypeEnumName;
        data["phoneNumber"] = this.phoneNumber;
        data["fullCustomerName"] = this.fullCustomerName;
        return data;
    }
}

export interface IOrderDto {
    id?: number;
    token?: string;
    number?: string;
    quantity?: number;
    subtotal?: number;
    discountPercentForRole?: number;
    total?: number;
    createdAt?: string;
    orderPaymentType?: OrderPaymentType;
    orderPaymentTypeName?: string;
    isPayed?: boolean;
    orderAddress?: string;
    currentOrderStateId?: OrderStatus;
    currentOrderStateName?: string;
    customerTypeEnum?: CustomerTypeEnum;
    customerTypeEnumName?: string;
    phoneNumber?: string;
    fullCustomerName?: string;
}

export enum OrderPaymentType {
    Unspecified = 0,
    Cash = 1,
    Credit = 2,
    Online = 3,
    CreditOnline = 4,
}

export enum OrderStatus {
    PendingForRegister = 0,
    OrderRegistered = 1,
    OrderPaymentConfirmed = 2,
    OrderConfirmed = 3,
    OrderPrepared = 4,
    OrderShipped = 5,
    OrderPaymentUnconfirmed = 6,
    OrderUnconfirmed = 7,
    OrderCanceled = 8,
    OrderCostRefunded = 9,
    OrderCompleted = 10,
}

export class FilteredOrderDto implements IFilteredOrderDto {
    orders?: OrderDto[];
    count?: number;

    constructor(data?: IFilteredOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(OrderDto.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): FilteredOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IFilteredOrderDto {
    orders?: OrderDto[];
    count?: number;
}

export class OrderInfoDto implements IOrderInfoDto {
    id?: number;
    addressDetails1?: string;
    addressDetails2?: string;
    postcode?: string;
    phoneNumber?: string;
    customerFirstName?: string;
    customerLastName?: string;

    constructor(data?: IOrderInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addressDetails1 = _data["addressDetails1"];
            this.addressDetails2 = _data["addressDetails2"];
            this.postcode = _data["postcode"];
            this.phoneNumber = _data["phoneNumber"];
            this.customerFirstName = _data["customerFirstName"];
            this.customerLastName = _data["customerLastName"];
        }
    }

    static fromJS(data: any): OrderInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addressDetails1"] = this.addressDetails1;
        data["addressDetails2"] = this.addressDetails2;
        data["postcode"] = this.postcode;
        data["phoneNumber"] = this.phoneNumber;
        data["customerFirstName"] = this.customerFirstName;
        data["customerLastName"] = this.customerLastName;
        return data;
    }
}

export interface IOrderInfoDto {
    id?: number;
    addressDetails1?: string;
    addressDetails2?: string;
    postcode?: string;
    phoneNumber?: string;
    customerFirstName?: string;
    customerLastName?: string;
}

export class OrderItemDto implements IOrderItemDto {
    id?: number;
    price?: number;
    discountPercentForProduct?: number;
    quantity?: number;
    total?: number;
    productName?: string;

    constructor(data?: IOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.discountPercentForProduct = _data["discountPercentForProduct"];
            this.quantity = _data["quantity"];
            this.total = _data["total"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): OrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["discountPercentForProduct"] = this.discountPercentForProduct;
        data["quantity"] = this.quantity;
        data["total"] = this.total;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IOrderItemDto {
    id?: number;
    price?: number;
    discountPercentForProduct?: number;
    quantity?: number;
    total?: number;
    productName?: string;
}

export class OrderTotalDto implements IOrderTotalDto {
    id?: number;
    title?: string;
    price?: number;
    type?: OrderTotalType;
    typeName?: string;

    constructor(data?: IOrderTotalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.type = _data["type"];
            this.typeName = _data["typeName"];
        }
    }

    static fromJS(data: any): OrderTotalDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderTotalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["price"] = this.price;
        data["type"] = this.type;
        data["typeName"] = this.typeName;
        return data;
    }
}

export interface IOrderTotalDto {
    id?: number;
    title?: string;
    price?: number;
    type?: OrderTotalType;
    typeName?: string;
}

export enum OrderTotalType {
    Shipping = 0,
    Tax = 1,
    DiscountOnCustomerType = 2,
    DiscountOnProduct = 3,
    Other = 4,
}

export class OrderPaymentDto implements IOrderPaymentDto {
    id?: number;
    paymentType?: PaymentType;
    paymentTypeName?: string;
    amount?: number | undefined;
    paymentServiceType?: PaymentServiceType | undefined;
    paymentServiceTypeName?: string | undefined;
    status?: OnlinePaymentStatus | undefined;
    statusName?: string | undefined;
    authority?: string | undefined;
    cardNumber?: string | undefined;
    rrn?: string | undefined;
    refId?: string | undefined;
    payGateTranId?: string | undefined;
    salesOrderId?: number | undefined;
    serviceTypeId?: number | undefined;
    error?: string | undefined;

    constructor(data?: IOrderPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentType = _data["paymentType"];
            this.paymentTypeName = _data["paymentTypeName"];
            this.amount = _data["amount"];
            this.paymentServiceType = _data["paymentServiceType"];
            this.paymentServiceTypeName = _data["paymentServiceTypeName"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.authority = _data["authority"];
            this.cardNumber = _data["cardNumber"];
            this.rrn = _data["rrn"];
            this.refId = _data["refId"];
            this.payGateTranId = _data["payGateTranId"];
            this.salesOrderId = _data["salesOrderId"];
            this.serviceTypeId = _data["serviceTypeId"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): OrderPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentType"] = this.paymentType;
        data["paymentTypeName"] = this.paymentTypeName;
        data["amount"] = this.amount;
        data["paymentServiceType"] = this.paymentServiceType;
        data["paymentServiceTypeName"] = this.paymentServiceTypeName;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["authority"] = this.authority;
        data["cardNumber"] = this.cardNumber;
        data["rrn"] = this.rrn;
        data["refId"] = this.refId;
        data["payGateTranId"] = this.payGateTranId;
        data["salesOrderId"] = this.salesOrderId;
        data["serviceTypeId"] = this.serviceTypeId;
        data["error"] = this.error;
        return data;
    }
}

export interface IOrderPaymentDto {
    id?: number;
    paymentType?: PaymentType;
    paymentTypeName?: string;
    amount?: number | undefined;
    paymentServiceType?: PaymentServiceType | undefined;
    paymentServiceTypeName?: string | undefined;
    status?: OnlinePaymentStatus | undefined;
    statusName?: string | undefined;
    authority?: string | undefined;
    cardNumber?: string | undefined;
    rrn?: string | undefined;
    refId?: string | undefined;
    payGateTranId?: string | undefined;
    salesOrderId?: number | undefined;
    serviceTypeId?: number | undefined;
    error?: string | undefined;
}

export enum PaymentType {
    Cash = 0,
    Credit = 1,
    Online = 2,
}

export enum PaymentServiceType {
    AsanPardakht = 1,
    Parsian = 2,
}

export enum OnlinePaymentStatus {
    Waiting = 0,
    Completed = 1,
    Failed = 2,
    Expired = 3,
}

export class OrderItemOptionDto implements IOrderItemOptionDto {
    id?: number;
    name?: string;
    value?: string;

    constructor(data?: IOrderItemOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): OrderItemOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IOrderItemOptionDto {
    id?: number;
    name?: string;
    value?: string;
}

export class OrderStateBaseDto implements IOrderStateBaseDto {
    id?: number;
    orderStatus?: OrderStatus;
    orderStatusName?: string;
    details?: string;
    created?: string;

    constructor(data?: IOrderStateBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderStatus = _data["orderStatus"];
            this.orderStatusName = _data["orderStatusName"];
            this.details = _data["details"];
            this.created = _data["created"];
        }
    }

    static fromJS(data: any): OrderStateBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderStateBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderStatus"] = this.orderStatus;
        data["orderStatusName"] = this.orderStatusName;
        data["details"] = this.details;
        data["created"] = this.created;
        return data;
    }
}

export interface IOrderStateBaseDto {
    id?: number;
    orderStatus?: OrderStatus;
    orderStatusName?: string;
    details?: string;
    created?: string;
}

export class UpdateOrderCommand implements IUpdateOrderCommand {
    id?: number;
    addressDetails1?: string;
    addressDetails2?: string;
    postcode?: string;
    phoneNumber?: string;
    firstName?: string;
    lastName?: string;

    constructor(data?: IUpdateOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addressDetails1 = _data["addressDetails1"];
            this.addressDetails2 = _data["addressDetails2"];
            this.postcode = _data["postcode"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): UpdateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addressDetails1"] = this.addressDetails1;
        data["addressDetails2"] = this.addressDetails2;
        data["postcode"] = this.postcode;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IUpdateOrderCommand {
    id?: number;
    addressDetails1?: string;
    addressDetails2?: string;
    postcode?: string;
    phoneNumber?: string;
    firstName?: string;
    lastName?: string;
}

export class CancelOrderCommand implements ICancelOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: ICancelOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): CancelOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CancelOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface ICancelOrderCommand {
    id?: number;
    details?: string;
}

export class ConfirmOrderCommand implements IConfirmOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: IConfirmOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): ConfirmOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IConfirmOrderCommand {
    id?: number;
    details?: string;
}

export class ConfirmOrderPaymentCommand implements IConfirmOrderPaymentCommand {
    id?: number;
    details?: string;

    constructor(data?: IConfirmOrderPaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): ConfirmOrderPaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmOrderPaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IConfirmOrderPaymentCommand {
    id?: number;
    details?: string;
}

export class PrepareOrderCommand implements IPrepareOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: IPrepareOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): PrepareOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PrepareOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IPrepareOrderCommand {
    id?: number;
    details?: string;
}

export class ShipOrderCommand implements IShipOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: IShipOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): ShipOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ShipOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IShipOrderCommand {
    id?: number;
    details?: string;
}

export class UnConfirmOrderCommand implements IUnConfirmOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: IUnConfirmOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): UnConfirmOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UnConfirmOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IUnConfirmOrderCommand {
    id?: number;
    details?: string;
}

export class UnConfirmOrderPaymentCommand implements IUnConfirmOrderPaymentCommand {
    id?: number;
    details?: string;

    constructor(data?: IUnConfirmOrderPaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): UnConfirmOrderPaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UnConfirmOrderPaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IUnConfirmOrderPaymentCommand {
    id?: number;
    details?: string;
}

export class RefundOrderCostCommand implements IRefundOrderCostCommand {
    id?: number;
    details?: string;

    constructor(data?: IRefundOrderCostCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): RefundOrderCostCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefundOrderCostCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface IRefundOrderCostCommand {
    id?: number;
    details?: string;
}

export class CompleteOrderCommand implements ICompleteOrderCommand {
    id?: number;
    details?: string;

    constructor(data?: ICompleteOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): CompleteOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        return data;
    }
}

export interface ICompleteOrderCommand {
    id?: number;
    details?: string;
}

export class PaginatedListOfBlockBannerDto implements IPaginatedListOfBlockBannerDto {
    items?: BlockBannerDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfBlockBannerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BlockBannerDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfBlockBannerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfBlockBannerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfBlockBannerDto {
    items?: BlockBannerDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class BlockBannerDto implements IBlockBannerDto {
    id?: number;
    title?: string;
    subtitle?: string;
    buttonText?: string;
    image?: string;
    isActive?: boolean;
    blockBannerPosition?: BlockBannerPosition;
    blockBannerPositionName?: string;

    constructor(data?: IBlockBannerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.subtitle = _data["subtitle"];
            this.buttonText = _data["buttonText"];
            this.image = _data["image"];
            this.isActive = _data["isActive"];
            this.blockBannerPosition = _data["blockBannerPosition"];
            this.blockBannerPositionName = _data["blockBannerPositionName"];
        }
    }

    static fromJS(data: any): BlockBannerDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlockBannerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["subtitle"] = this.subtitle;
        data["buttonText"] = this.buttonText;
        data["image"] = this.image;
        data["isActive"] = this.isActive;
        data["blockBannerPosition"] = this.blockBannerPosition;
        data["blockBannerPositionName"] = this.blockBannerPositionName;
        return data;
    }
}

export interface IBlockBannerDto {
    id?: number;
    title?: string;
    subtitle?: string;
    buttonText?: string;
    image?: string;
    isActive?: boolean;
    blockBannerPosition?: BlockBannerPosition;
    blockBannerPositionName?: string;
}

export enum BlockBannerPosition {
    LeftSide = 0,
    RightSide = 1,
}

export class CreateBlockBannerCommand implements ICreateBlockBannerCommand {
    title?: string;
    subtitle?: string;
    buttonText?: string;
    image?: string;
    blockBannerPosition?: number;
    isActive?: boolean;

    constructor(data?: ICreateBlockBannerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.subtitle = _data["subtitle"];
            this.buttonText = _data["buttonText"];
            this.image = _data["image"];
            this.blockBannerPosition = _data["blockBannerPosition"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateBlockBannerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBlockBannerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["subtitle"] = this.subtitle;
        data["buttonText"] = this.buttonText;
        data["image"] = this.image;
        data["blockBannerPosition"] = this.blockBannerPosition;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateBlockBannerCommand {
    title?: string;
    subtitle?: string;
    buttonText?: string;
    image?: string;
    blockBannerPosition?: number;
    isActive?: boolean;
}

export class UpdateBlockBannerCommand implements IUpdateBlockBannerCommand {
    id?: number;
    title?: string;
    subtitle?: string;
    buttonText?: string;
    image?: string;
    blockBannerPosition?: number;
    isActive?: boolean;

    constructor(data?: IUpdateBlockBannerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.subtitle = _data["subtitle"];
            this.buttonText = _data["buttonText"];
            this.image = _data["image"];
            this.blockBannerPosition = _data["blockBannerPosition"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateBlockBannerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBlockBannerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["subtitle"] = this.subtitle;
        data["buttonText"] = this.buttonText;
        data["image"] = this.image;
        data["blockBannerPosition"] = this.blockBannerPosition;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateBlockBannerCommand {
    id?: number;
    title?: string;
    subtitle?: string;
    buttonText?: string;
    image?: string;
    blockBannerPosition?: number;
    isActive?: boolean;
}

export class PaginatedListOfCarouselDto implements IPaginatedListOfCarouselDto {
    items?: CarouselDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCarouselDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CarouselDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCarouselDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCarouselDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCarouselDto {
    items?: CarouselDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CarouselDto implements ICarouselDto {
    id?: number;
    url?: string;
    desktopImage?: string;
    mobileImage?: string;
    offer?: string | undefined;
    title?: string;
    details?: string;
    buttonLabel?: string;
    order?: number;
    isActive?: boolean;

    constructor(data?: ICarouselDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.desktopImage = _data["desktopImage"];
            this.mobileImage = _data["mobileImage"];
            this.offer = _data["offer"];
            this.title = _data["title"];
            this.details = _data["details"];
            this.buttonLabel = _data["buttonLabel"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CarouselDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarouselDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["desktopImage"] = this.desktopImage;
        data["mobileImage"] = this.mobileImage;
        data["offer"] = this.offer;
        data["title"] = this.title;
        data["details"] = this.details;
        data["buttonLabel"] = this.buttonLabel;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICarouselDto {
    id?: number;
    url?: string;
    desktopImage?: string;
    mobileImage?: string;
    offer?: string | undefined;
    title?: string;
    details?: string;
    buttonLabel?: string;
    order?: number;
    isActive?: boolean;
}

export class CreateCarouselCommand implements ICreateCarouselCommand {
    url?: string;
    desktopImage?: string;
    mobileImage?: string;
    offer?: string | undefined;
    title?: string;
    details?: string;
    buttonLabel?: string;
    order?: number;
    isActive?: boolean;

    constructor(data?: ICreateCarouselCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.desktopImage = _data["desktopImage"];
            this.mobileImage = _data["mobileImage"];
            this.offer = _data["offer"];
            this.title = _data["title"];
            this.details = _data["details"];
            this.buttonLabel = _data["buttonLabel"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateCarouselCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCarouselCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["desktopImage"] = this.desktopImage;
        data["mobileImage"] = this.mobileImage;
        data["offer"] = this.offer;
        data["title"] = this.title;
        data["details"] = this.details;
        data["buttonLabel"] = this.buttonLabel;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateCarouselCommand {
    url?: string;
    desktopImage?: string;
    mobileImage?: string;
    offer?: string | undefined;
    title?: string;
    details?: string;
    buttonLabel?: string;
    order?: number;
    isActive?: boolean;
}

export class UpdateCarouselCommand implements IUpdateCarouselCommand {
    id?: number;
    url?: string;
    desktopImage?: string;
    mobileImage?: string;
    offer?: string | undefined;
    title?: string;
    details?: string;
    buttonLabel?: string;
    order?: number;
    isActive?: boolean;

    constructor(data?: IUpdateCarouselCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.desktopImage = _data["desktopImage"];
            this.mobileImage = _data["mobileImage"];
            this.offer = _data["offer"];
            this.title = _data["title"];
            this.details = _data["details"];
            this.buttonLabel = _data["buttonLabel"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateCarouselCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCarouselCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["desktopImage"] = this.desktopImage;
        data["mobileImage"] = this.mobileImage;
        data["offer"] = this.offer;
        data["title"] = this.title;
        data["details"] = this.details;
        data["buttonLabel"] = this.buttonLabel;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateCarouselCommand {
    id?: number;
    url?: string;
    desktopImage?: string;
    mobileImage?: string;
    offer?: string | undefined;
    title?: string;
    details?: string;
    buttonLabel?: string;
    order?: number;
    isActive?: boolean;
}

export class PaginatedListOfFooterLinkContainerDto implements IPaginatedListOfFooterLinkContainerDto {
    items?: FooterLinkContainerDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfFooterLinkContainerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FooterLinkContainerDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfFooterLinkContainerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFooterLinkContainerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfFooterLinkContainerDto {
    items?: FooterLinkContainerDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class FooterLinkContainerDto implements IFooterLinkContainerDto {
    id?: number;
    header?: string;
    order?: number;
    isActive?: boolean;

    constructor(data?: IFooterLinkContainerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.header = _data["header"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): FooterLinkContainerDto {
        data = typeof data === 'object' ? data : {};
        let result = new FooterLinkContainerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["header"] = this.header;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IFooterLinkContainerDto {
    id?: number;
    header?: string;
    order?: number;
    isActive?: boolean;
}

export class CreateFooterLinkContainerCommand implements ICreateFooterLinkContainerCommand {
    header?: string;
    order?: number;
    isActive?: boolean;

    constructor(data?: ICreateFooterLinkContainerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateFooterLinkContainerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFooterLinkContainerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateFooterLinkContainerCommand {
    header?: string;
    order?: number;
    isActive?: boolean;
}

export class UpdateFooterLinkContainerCommand implements IUpdateFooterLinkContainerCommand {
    id?: number;
    header?: string;
    order?: number;
    isActive?: boolean;

    constructor(data?: IUpdateFooterLinkContainerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.header = _data["header"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateFooterLinkContainerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFooterLinkContainerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["header"] = this.header;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateFooterLinkContainerCommand {
    id?: number;
    header?: string;
    order?: number;
    isActive?: boolean;
}

export class PaginatedListOfFooterLinkDto implements IPaginatedListOfFooterLinkDto {
    items?: FooterLinkDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfFooterLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FooterLinkDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfFooterLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFooterLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfFooterLinkDto {
    items?: FooterLinkDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class FooterLinkDto implements IFooterLinkDto {
    id?: number;
    title?: string;
    url?: string;
    isActive?: boolean;

    constructor(data?: IFooterLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.url = _data["url"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): FooterLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new FooterLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IFooterLinkDto {
    id?: number;
    title?: string;
    url?: string;
    isActive?: boolean;
}

export class CreateFooterLinkCommand implements ICreateFooterLinkCommand {
    title?: string;
    url?: string;
    footerLinkContainerId?: number;
    isActive?: boolean;

    constructor(data?: ICreateFooterLinkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.url = _data["url"];
            this.footerLinkContainerId = _data["footerLinkContainerId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateFooterLinkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFooterLinkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["url"] = this.url;
        data["footerLinkContainerId"] = this.footerLinkContainerId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateFooterLinkCommand {
    title?: string;
    url?: string;
    footerLinkContainerId?: number;
    isActive?: boolean;
}

export class UpdateFooterLinkCommand implements IUpdateFooterLinkCommand {
    id?: number;
    title?: string;
    url?: string;
    footerLinkContainerId?: number;
    isActive?: boolean;

    constructor(data?: IUpdateFooterLinkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.url = _data["url"];
            this.footerLinkContainerId = _data["footerLinkContainerId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateFooterLinkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFooterLinkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["url"] = this.url;
        data["footerLinkContainerId"] = this.footerLinkContainerId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateFooterLinkCommand {
    id?: number;
    title?: string;
    url?: string;
    footerLinkContainerId?: number;
    isActive?: boolean;
}

export class SocialLinkDto implements ISocialLinkDto {
    id?: number;
    url?: string;
    icon?: string;
    isActive?: boolean;

    constructor(data?: ISocialLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.icon = _data["icon"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SocialLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new SocialLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["icon"] = this.icon;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ISocialLinkDto {
    id?: number;
    url?: string;
    icon?: string;
    isActive?: boolean;
}

export class CreateSocialLinkCommand implements ICreateSocialLinkCommand {
    url?: string;
    icon?: string;
    isActive?: boolean;

    constructor(data?: ICreateSocialLinkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.icon = _data["icon"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateSocialLinkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSocialLinkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["icon"] = this.icon;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateSocialLinkCommand {
    url?: string;
    icon?: string;
    isActive?: boolean;
}

export class UpdateSocialLinkCommand implements IUpdateSocialLinkCommand {
    id?: number;
    url?: string;
    icon?: string;
    isActive?: boolean;

    constructor(data?: IUpdateSocialLinkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.icon = _data["icon"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateSocialLinkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSocialLinkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["icon"] = this.icon;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateSocialLinkCommand {
    id?: number;
    url?: string;
    icon?: string;
    isActive?: boolean;
}

export class PaginatedListOfThemeDto implements IPaginatedListOfThemeDto {
    items?: ThemeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfThemeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ThemeDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfThemeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfThemeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfThemeDto {
    items?: ThemeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ThemeDto implements IThemeDto {
    id?: number;
    title?: string;
    btnPrimaryColor?: string;
    btnPrimaryHoverColor?: string;
    btnSecondaryColor?: string;
    btnSecondaryHoverColor?: string;
    themeColor?: string;
    headerAndFooterColor?: string;
    isDefault?: boolean;

    constructor(data?: IThemeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.btnPrimaryColor = _data["btnPrimaryColor"];
            this.btnPrimaryHoverColor = _data["btnPrimaryHoverColor"];
            this.btnSecondaryColor = _data["btnSecondaryColor"];
            this.btnSecondaryHoverColor = _data["btnSecondaryHoverColor"];
            this.themeColor = _data["themeColor"];
            this.headerAndFooterColor = _data["headerAndFooterColor"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ThemeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["btnPrimaryColor"] = this.btnPrimaryColor;
        data["btnPrimaryHoverColor"] = this.btnPrimaryHoverColor;
        data["btnSecondaryColor"] = this.btnSecondaryColor;
        data["btnSecondaryHoverColor"] = this.btnSecondaryHoverColor;
        data["themeColor"] = this.themeColor;
        data["headerAndFooterColor"] = this.headerAndFooterColor;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IThemeDto {
    id?: number;
    title?: string;
    btnPrimaryColor?: string;
    btnPrimaryHoverColor?: string;
    btnSecondaryColor?: string;
    btnSecondaryHoverColor?: string;
    themeColor?: string;
    headerAndFooterColor?: string;
    isDefault?: boolean;
}

export class CreateThemeCommand implements ICreateThemeCommand {
    title?: string;
    btnPrimaryColor?: string;
    btnPrimaryHoverColor?: string;
    btnSecondaryColor?: string;
    btnSecondaryHoverColor?: string;
    themeColor?: string;
    headerAndFooterColor?: string;
    isDefault?: boolean;

    constructor(data?: ICreateThemeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.btnPrimaryColor = _data["btnPrimaryColor"];
            this.btnPrimaryHoverColor = _data["btnPrimaryHoverColor"];
            this.btnSecondaryColor = _data["btnSecondaryColor"];
            this.btnSecondaryHoverColor = _data["btnSecondaryHoverColor"];
            this.themeColor = _data["themeColor"];
            this.headerAndFooterColor = _data["headerAndFooterColor"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateThemeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateThemeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["btnPrimaryColor"] = this.btnPrimaryColor;
        data["btnPrimaryHoverColor"] = this.btnPrimaryHoverColor;
        data["btnSecondaryColor"] = this.btnSecondaryColor;
        data["btnSecondaryHoverColor"] = this.btnSecondaryHoverColor;
        data["themeColor"] = this.themeColor;
        data["headerAndFooterColor"] = this.headerAndFooterColor;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ICreateThemeCommand {
    title?: string;
    btnPrimaryColor?: string;
    btnPrimaryHoverColor?: string;
    btnSecondaryColor?: string;
    btnSecondaryHoverColor?: string;
    themeColor?: string;
    headerAndFooterColor?: string;
    isDefault?: boolean;
}

export class UpdateThemeCommand implements IUpdateThemeCommand {
    id?: number;
    title?: string;
    btnPrimaryColor?: string;
    btnPrimaryHoverColor?: string;
    btnSecondaryColor?: string;
    btnSecondaryHoverColor?: string;
    themeColor?: string;
    headerAndFooterColor?: string;
    isDefault?: boolean;

    constructor(data?: IUpdateThemeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.btnPrimaryColor = _data["btnPrimaryColor"];
            this.btnPrimaryHoverColor = _data["btnPrimaryHoverColor"];
            this.btnSecondaryColor = _data["btnSecondaryColor"];
            this.btnSecondaryHoverColor = _data["btnSecondaryHoverColor"];
            this.themeColor = _data["themeColor"];
            this.headerAndFooterColor = _data["headerAndFooterColor"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateThemeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateThemeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["btnPrimaryColor"] = this.btnPrimaryColor;
        data["btnPrimaryHoverColor"] = this.btnPrimaryHoverColor;
        data["btnSecondaryColor"] = this.btnSecondaryColor;
        data["btnSecondaryHoverColor"] = this.btnSecondaryHoverColor;
        data["themeColor"] = this.themeColor;
        data["headerAndFooterColor"] = this.headerAndFooterColor;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IUpdateThemeCommand {
    id?: number;
    title?: string;
    btnPrimaryColor?: string;
    btnPrimaryHoverColor?: string;
    btnSecondaryColor?: string;
    btnSecondaryHoverColor?: string;
    themeColor?: string;
    headerAndFooterColor?: string;
    isDefault?: boolean;
}

export class AboutUsDto implements IAboutUsDto {
    id?: number;
    title?: string;
    textContent?: string;
    imageContent?: string;
    isDefault?: boolean;

    constructor(data?: IAboutUsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.textContent = _data["textContent"];
            this.imageContent = _data["imageContent"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): AboutUsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AboutUsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["textContent"] = this.textContent;
        data["imageContent"] = this.imageContent;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IAboutUsDto {
    id?: number;
    title?: string;
    textContent?: string;
    imageContent?: string;
    isDefault?: boolean;
}

export class CreateAboutUsCommand implements ICreateAboutUsCommand {
    title?: string;
    textContent?: string;
    imageContent?: string;
    isDefault?: boolean;

    constructor(data?: ICreateAboutUsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.textContent = _data["textContent"];
            this.imageContent = _data["imageContent"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateAboutUsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAboutUsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["textContent"] = this.textContent;
        data["imageContent"] = this.imageContent;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ICreateAboutUsCommand {
    title?: string;
    textContent?: string;
    imageContent?: string;
    isDefault?: boolean;
}

export class UpdateAboutUsCommand implements IUpdateAboutUsCommand {
    id?: number;
    title?: string;
    textContent?: string;
    imageContent?: string;
    isDefault?: boolean;

    constructor(data?: IUpdateAboutUsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.textContent = _data["textContent"];
            this.imageContent = _data["imageContent"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateAboutUsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAboutUsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["textContent"] = this.textContent;
        data["imageContent"] = this.imageContent;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IUpdateAboutUsCommand {
    id?: number;
    title?: string;
    textContent?: string;
    imageContent?: string;
    isDefault?: boolean;
}

export class CorporationInfoDto implements ICorporationInfoDto {
    id?: number;
    contactUsMessage?: string;
    phoneNumbers?: string[];
    emailAddresses?: string[];
    locationAddresses?: string[];
    workingHours?: string[];
    poweredBy?: string;
    callUs?: string;
    desktopLogo?: string;
    mobileLogo?: string;
    footerLogo?: string;
    sliderBackGroundImage?: string;
    isDefault?: boolean;

    constructor(data?: ICorporationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactUsMessage = _data["contactUsMessage"];
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(item);
            }
            if (Array.isArray(_data["emailAddresses"])) {
                this.emailAddresses = [] as any;
                for (let item of _data["emailAddresses"])
                    this.emailAddresses!.push(item);
            }
            if (Array.isArray(_data["locationAddresses"])) {
                this.locationAddresses = [] as any;
                for (let item of _data["locationAddresses"])
                    this.locationAddresses!.push(item);
            }
            if (Array.isArray(_data["workingHours"])) {
                this.workingHours = [] as any;
                for (let item of _data["workingHours"])
                    this.workingHours!.push(item);
            }
            this.poweredBy = _data["poweredBy"];
            this.callUs = _data["callUs"];
            this.desktopLogo = _data["desktopLogo"];
            this.mobileLogo = _data["mobileLogo"];
            this.footerLogo = _data["footerLogo"];
            this.sliderBackGroundImage = _data["sliderBackGroundImage"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CorporationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CorporationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactUsMessage"] = this.contactUsMessage;
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item);
        }
        if (Array.isArray(this.emailAddresses)) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item);
        }
        if (Array.isArray(this.locationAddresses)) {
            data["locationAddresses"] = [];
            for (let item of this.locationAddresses)
                data["locationAddresses"].push(item);
        }
        if (Array.isArray(this.workingHours)) {
            data["workingHours"] = [];
            for (let item of this.workingHours)
                data["workingHours"].push(item);
        }
        data["poweredBy"] = this.poweredBy;
        data["callUs"] = this.callUs;
        data["desktopLogo"] = this.desktopLogo;
        data["mobileLogo"] = this.mobileLogo;
        data["footerLogo"] = this.footerLogo;
        data["sliderBackGroundImage"] = this.sliderBackGroundImage;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ICorporationInfoDto {
    id?: number;
    contactUsMessage?: string;
    phoneNumbers?: string[];
    emailAddresses?: string[];
    locationAddresses?: string[];
    workingHours?: string[];
    poweredBy?: string;
    callUs?: string;
    desktopLogo?: string;
    mobileLogo?: string;
    footerLogo?: string;
    sliderBackGroundImage?: string;
    isDefault?: boolean;
}

export class CreateCorporationInfoCommand implements ICreateCorporationInfoCommand {
    contactUsMessage?: string;
    poweredBy?: string;
    callUs?: string;
    desktopLogo?: string;
    mobileLogo?: string;
    footerLogo?: string;
    sliderBackGroundImage?: string;
    isDefault?: boolean;

    constructor(data?: ICreateCorporationInfoCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactUsMessage = _data["contactUsMessage"];
            this.poweredBy = _data["poweredBy"];
            this.callUs = _data["callUs"];
            this.desktopLogo = _data["desktopLogo"];
            this.mobileLogo = _data["mobileLogo"];
            this.footerLogo = _data["footerLogo"];
            this.sliderBackGroundImage = _data["sliderBackGroundImage"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateCorporationInfoCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCorporationInfoCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactUsMessage"] = this.contactUsMessage;
        data["poweredBy"] = this.poweredBy;
        data["callUs"] = this.callUs;
        data["desktopLogo"] = this.desktopLogo;
        data["mobileLogo"] = this.mobileLogo;
        data["footerLogo"] = this.footerLogo;
        data["sliderBackGroundImage"] = this.sliderBackGroundImage;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ICreateCorporationInfoCommand {
    contactUsMessage?: string;
    poweredBy?: string;
    callUs?: string;
    desktopLogo?: string;
    mobileLogo?: string;
    footerLogo?: string;
    sliderBackGroundImage?: string;
    isDefault?: boolean;
}

export class UpdateCorporationInfoCommand implements IUpdateCorporationInfoCommand {
    id?: number;
    contactUsMessage?: string;
    poweredBy?: string;
    callUs?: string;
    desktopLogo?: string;
    mobileLogo?: string;
    footerLogo?: string;
    sliderBackGroundImage?: string;
    isDefault?: boolean;

    constructor(data?: IUpdateCorporationInfoCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactUsMessage = _data["contactUsMessage"];
            this.poweredBy = _data["poweredBy"];
            this.callUs = _data["callUs"];
            this.desktopLogo = _data["desktopLogo"];
            this.mobileLogo = _data["mobileLogo"];
            this.footerLogo = _data["footerLogo"];
            this.sliderBackGroundImage = _data["sliderBackGroundImage"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateCorporationInfoCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCorporationInfoCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactUsMessage"] = this.contactUsMessage;
        data["poweredBy"] = this.poweredBy;
        data["callUs"] = this.callUs;
        data["desktopLogo"] = this.desktopLogo;
        data["mobileLogo"] = this.mobileLogo;
        data["footerLogo"] = this.footerLogo;
        data["sliderBackGroundImage"] = this.sliderBackGroundImage;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IUpdateCorporationInfoCommand {
    id?: number;
    contactUsMessage?: string;
    poweredBy?: string;
    callUs?: string;
    desktopLogo?: string;
    mobileLogo?: string;
    footerLogo?: string;
    sliderBackGroundImage?: string;
    isDefault?: boolean;
}

export class AddEmailAddressCommand implements IAddEmailAddressCommand {
    corporationInfoId?: number;
    emailAddress?: string;

    constructor(data?: IAddEmailAddressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.corporationInfoId = _data["corporationInfoId"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): AddEmailAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddEmailAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["corporationInfoId"] = this.corporationInfoId;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface IAddEmailAddressCommand {
    corporationInfoId?: number;
    emailAddress?: string;
}

export class RemoveEmailAddressCommand implements IRemoveEmailAddressCommand {
    corporationInfoId?: number;
    emailAddresses?: string[];

    constructor(data?: IRemoveEmailAddressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.corporationInfoId = _data["corporationInfoId"];
            if (Array.isArray(_data["emailAddresses"])) {
                this.emailAddresses = [] as any;
                for (let item of _data["emailAddresses"])
                    this.emailAddresses!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoveEmailAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveEmailAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["corporationInfoId"] = this.corporationInfoId;
        if (Array.isArray(this.emailAddresses)) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item);
        }
        return data;
    }
}

export interface IRemoveEmailAddressCommand {
    corporationInfoId?: number;
    emailAddresses?: string[];
}

export class AddLocationAddressCommand implements IAddLocationAddressCommand {
    corporationInfoId?: number;
    locationAddress?: string;

    constructor(data?: IAddLocationAddressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.corporationInfoId = _data["corporationInfoId"];
            this.locationAddress = _data["locationAddress"];
        }
    }

    static fromJS(data: any): AddLocationAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddLocationAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["corporationInfoId"] = this.corporationInfoId;
        data["locationAddress"] = this.locationAddress;
        return data;
    }
}

export interface IAddLocationAddressCommand {
    corporationInfoId?: number;
    locationAddress?: string;
}

export class RemoveLocationAddressCommand implements IRemoveLocationAddressCommand {
    corporationInfoId?: number;
    locationAddresses?: string[];

    constructor(data?: IRemoveLocationAddressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.corporationInfoId = _data["corporationInfoId"];
            if (Array.isArray(_data["locationAddresses"])) {
                this.locationAddresses = [] as any;
                for (let item of _data["locationAddresses"])
                    this.locationAddresses!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoveLocationAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveLocationAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["corporationInfoId"] = this.corporationInfoId;
        if (Array.isArray(this.locationAddresses)) {
            data["locationAddresses"] = [];
            for (let item of this.locationAddresses)
                data["locationAddresses"].push(item);
        }
        return data;
    }
}

export interface IRemoveLocationAddressCommand {
    corporationInfoId?: number;
    locationAddresses?: string[];
}

export class AddPhoneNumberCommand implements IAddPhoneNumberCommand {
    corporationInfoId?: number;
    phoneNumber?: string;

    constructor(data?: IAddPhoneNumberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.corporationInfoId = _data["corporationInfoId"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): AddPhoneNumberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddPhoneNumberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["corporationInfoId"] = this.corporationInfoId;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IAddPhoneNumberCommand {
    corporationInfoId?: number;
    phoneNumber?: string;
}

export class RemovePhoneNumberCommand implements IRemovePhoneNumberCommand {
    corporationInfoId?: number;
    phoneNumbers?: string[];

    constructor(data?: IRemovePhoneNumberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.corporationInfoId = _data["corporationInfoId"];
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(item);
            }
        }
    }

    static fromJS(data: any): RemovePhoneNumberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemovePhoneNumberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["corporationInfoId"] = this.corporationInfoId;
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item);
        }
        return data;
    }
}

export interface IRemovePhoneNumberCommand {
    corporationInfoId?: number;
    phoneNumbers?: string[];
}

export class AddWorkingHourCommand implements IAddWorkingHourCommand {
    corporationInfoId?: number;
    workingHour?: string;

    constructor(data?: IAddWorkingHourCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.corporationInfoId = _data["corporationInfoId"];
            this.workingHour = _data["workingHour"];
        }
    }

    static fromJS(data: any): AddWorkingHourCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddWorkingHourCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["corporationInfoId"] = this.corporationInfoId;
        data["workingHour"] = this.workingHour;
        return data;
    }
}

export interface IAddWorkingHourCommand {
    corporationInfoId?: number;
    workingHour?: string;
}

export class RemoveWorkingHourCommand implements IRemoveWorkingHourCommand {
    corporationInfoId?: number;
    workingHours?: string[];

    constructor(data?: IRemoveWorkingHourCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.corporationInfoId = _data["corporationInfoId"];
            if (Array.isArray(_data["workingHours"])) {
                this.workingHours = [] as any;
                for (let item of _data["workingHours"])
                    this.workingHours!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoveWorkingHourCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveWorkingHourCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["corporationInfoId"] = this.corporationInfoId;
        if (Array.isArray(this.workingHours)) {
            data["workingHours"] = [];
            for (let item of this.workingHours)
                data["workingHours"].push(item);
        }
        return data;
    }
}

export interface IRemoveWorkingHourCommand {
    corporationInfoId?: number;
    workingHours?: string[];
}

export class PaginatedListOfCountryDto implements IPaginatedListOfCountryDto {
    items?: CountryDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountryDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCountryDto {
    items?: CountryDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AllCountryDropDownDto implements IAllCountryDropDownDto {
    id?: number;
    localizedName?: string;

    constructor(data?: IAllCountryDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllCountryDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllCountryDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllCountryDropDownDto {
    id?: number;
    localizedName?: string;
}

export class CreateCountryCommand implements ICreateCountryCommand {
    code?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;

    constructor(data?: ICreateCountryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateCountryCommand {
    code?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;
}

export class UpdateCountryCommand implements IUpdateCountryCommand {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;

    constructor(data?: IUpdateCountryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateCountryCommand {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;
}

export class PaginatedListOfQuestionDto implements IPaginatedListOfQuestionDto {
    items?: QuestionDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(QuestionDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfQuestionDto {
    items?: QuestionDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class QuestionDto implements IQuestionDto {
    id?: number;
    questionText?: string;
    answerText?: string;
    questionType?: QuestionType;
    isActive?: boolean;

    constructor(data?: IQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionText = _data["questionText"];
            this.answerText = _data["answerText"];
            this.questionType = _data["questionType"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): QuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionText"] = this.questionText;
        data["answerText"] = this.answerText;
        data["questionType"] = this.questionType;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IQuestionDto {
    id?: number;
    questionText?: string;
    answerText?: string;
    questionType?: QuestionType;
    isActive?: boolean;
}

export enum QuestionType {
    ShippingInformation = 0,
    PaymentInformation = 1,
    OrdersAndReturns = 2,
}

export class CreateQuestionCommand implements ICreateQuestionCommand {
    questionText?: string;
    answerText?: string;
    questionType?: number;
    isActive?: boolean;

    constructor(data?: ICreateQuestionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionText = _data["questionText"];
            this.answerText = _data["answerText"];
            this.questionType = _data["questionType"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateQuestionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuestionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionText"] = this.questionText;
        data["answerText"] = this.answerText;
        data["questionType"] = this.questionType;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateQuestionCommand {
    questionText?: string;
    answerText?: string;
    questionType?: number;
    isActive?: boolean;
}

export class UpdateQuestionCommand implements IUpdateQuestionCommand {
    id?: number;
    questionText?: string;
    answerText?: string;
    questionType?: number;
    isActive?: boolean;

    constructor(data?: IUpdateQuestionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionText = _data["questionText"];
            this.answerText = _data["answerText"];
            this.questionType = _data["questionType"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateQuestionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuestionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionText"] = this.questionText;
        data["answerText"] = this.answerText;
        data["questionType"] = this.questionType;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateQuestionCommand {
    id?: number;
    questionText?: string;
    answerText?: string;
    questionType?: number;
    isActive?: boolean;
}

export class PaginatedListOfTeamMemberDto implements IPaginatedListOfTeamMemberDto {
    items?: TeamMemberDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTeamMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TeamMemberDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTeamMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTeamMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTeamMemberDto {
    items?: TeamMemberDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TeamMemberDto implements ITeamMemberDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    aboutUsTitle?: string;
    isActive?: boolean;
    aboutUsId?: number;

    constructor(data?: ITeamMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
            this.aboutUsTitle = _data["aboutUsTitle"];
            this.isActive = _data["isActive"];
            this.aboutUsId = _data["aboutUsId"];
        }
    }

    static fromJS(data: any): TeamMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        data["aboutUsTitle"] = this.aboutUsTitle;
        data["isActive"] = this.isActive;
        data["aboutUsId"] = this.aboutUsId;
        return data;
    }
}

export interface ITeamMemberDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    aboutUsTitle?: string;
    isActive?: boolean;
    aboutUsId?: number;
}

export class CreateTeamMemberCommand implements ICreateTeamMemberCommand {
    name?: string;
    position?: string;
    avatar?: string;
    isActive?: boolean;
    aboutUsId?: number;

    constructor(data?: ICreateTeamMemberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
            this.isActive = _data["isActive"];
            this.aboutUsId = _data["aboutUsId"];
        }
    }

    static fromJS(data: any): CreateTeamMemberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTeamMemberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        data["isActive"] = this.isActive;
        data["aboutUsId"] = this.aboutUsId;
        return data;
    }
}

export interface ICreateTeamMemberCommand {
    name?: string;
    position?: string;
    avatar?: string;
    isActive?: boolean;
    aboutUsId?: number;
}

export class UpdateTeamMemberCommand implements IUpdateTeamMemberCommand {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    isActive?: boolean;
    aboutUsId?: number;

    constructor(data?: IUpdateTeamMemberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
            this.isActive = _data["isActive"];
            this.aboutUsId = _data["aboutUsId"];
        }
    }

    static fromJS(data: any): UpdateTeamMemberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTeamMemberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        data["isActive"] = this.isActive;
        data["aboutUsId"] = this.aboutUsId;
        return data;
    }
}

export interface IUpdateTeamMemberCommand {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    isActive?: boolean;
    aboutUsId?: number;
}

export class PaginatedListOfTestimonialDto implements IPaginatedListOfTestimonialDto {
    items?: TestimonialDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTestimonialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TestimonialDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTestimonialDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTestimonialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTestimonialDto {
    items?: TestimonialDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TestimonialDto implements ITestimonialDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;
    aboutUsTitle?: string;
    isActive?: boolean;
    aboutUsId?: number;

    constructor(data?: ITestimonialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
            this.rating = _data["rating"];
            this.review = _data["review"];
            this.aboutUsTitle = _data["aboutUsTitle"];
            this.isActive = _data["isActive"];
            this.aboutUsId = _data["aboutUsId"];
        }
    }

    static fromJS(data: any): TestimonialDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestimonialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        data["rating"] = this.rating;
        data["review"] = this.review;
        data["aboutUsTitle"] = this.aboutUsTitle;
        data["isActive"] = this.isActive;
        data["aboutUsId"] = this.aboutUsId;
        return data;
    }
}

export interface ITestimonialDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;
    aboutUsTitle?: string;
    isActive?: boolean;
    aboutUsId?: number;
}

export class CreateTestimonialCommand implements ICreateTestimonialCommand {
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;
    isActive?: boolean;
    aboutUsId?: number;

    constructor(data?: ICreateTestimonialCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
            this.rating = _data["rating"];
            this.review = _data["review"];
            this.isActive = _data["isActive"];
            this.aboutUsId = _data["aboutUsId"];
        }
    }

    static fromJS(data: any): CreateTestimonialCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTestimonialCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        data["rating"] = this.rating;
        data["review"] = this.review;
        data["isActive"] = this.isActive;
        data["aboutUsId"] = this.aboutUsId;
        return data;
    }
}

export interface ICreateTestimonialCommand {
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;
    isActive?: boolean;
    aboutUsId?: number;
}

export class UpdateTestimonialCommand implements IUpdateTestimonialCommand {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;
    isActive?: boolean;
    aboutUsId?: number;

    constructor(data?: IUpdateTestimonialCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
            this.rating = _data["rating"];
            this.review = _data["review"];
            this.isActive = _data["isActive"];
            this.aboutUsId = _data["aboutUsId"];
        }
    }

    static fromJS(data: any): UpdateTestimonialCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTestimonialCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        data["rating"] = this.rating;
        data["review"] = this.review;
        data["isActive"] = this.isActive;
        data["aboutUsId"] = this.aboutUsId;
        return data;
    }
}

export interface IUpdateTestimonialCommand {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;
    isActive?: boolean;
    aboutUsId?: number;
}

export class FileUploadMetadataDto implements IFileUploadMetadataDto {
    fileId?: string;
    uploadName?: string;
    fileSize?: number;
    extension?: string;

    constructor(data?: IFileUploadMetadataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileId = _data["fileId"];
            this.uploadName = _data["uploadName"];
            this.fileSize = _data["fileSize"];
            this.extension = _data["extension"];
        }
    }

    static fromJS(data: any): FileUploadMetadataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadMetadataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileId"] = this.fileId;
        data["uploadName"] = this.uploadName;
        data["fileSize"] = this.fileSize;
        data["extension"] = this.extension;
        return data;
    }
}

export interface IFileUploadMetadataDto {
    fileId?: string;
    uploadName?: string;
    fileSize?: number;
    extension?: string;
}

export class StoredFileDto implements IStoredFileDto {
    id?: number;
    fileId?: string;
    extension?: string;
    fileName?: string;
    fileSize?: number;
    folder?: string;
    category?: FileCategory;
    uploadName?: string;
    uploadDate?: Date;
    owner?: string | undefined;

    constructor(data?: IStoredFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileId = _data["fileId"];
            this.extension = _data["extension"];
            this.fileName = _data["fileName"];
            this.fileSize = _data["fileSize"];
            this.folder = _data["folder"];
            this.category = _data["category"];
            this.uploadName = _data["uploadName"];
            this.uploadDate = _data["uploadDate"] ? new Date(_data["uploadDate"].toString()) : <any>undefined;
            this.owner = _data["owner"];
        }
    }

    static fromJS(data: any): StoredFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoredFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileId"] = this.fileId;
        data["extension"] = this.extension;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["folder"] = this.folder;
        data["category"] = this.category;
        data["uploadName"] = this.uploadName;
        data["uploadDate"] = this.uploadDate ? this.uploadDate.toISOString() : <any>undefined;
        data["owner"] = this.owner;
        return data;
    }
}

export interface IStoredFileDto {
    id?: number;
    fileId?: string;
    extension?: string;
    fileName?: string;
    fileSize?: number;
    folder?: string;
    category?: FileCategory;
    uploadName?: string;
    uploadDate?: Date;
    owner?: string | undefined;
}

export enum FileCategory {
    ProductBrand = 0,
    VehicleBrand = 1,
    BlogCategory = 2,
    ProductCategory = 3,
    Link = 4,
    AboutUs = 5,
    CorporationInfo = 6,
    TeamMember = 7,
    Testimonial = 8,
    BlockBanner = 9,
    Carousel = 10,
    SocialLink = 11,
    ProductImage = 12,
    Customer = 13,
    User = 14,
    ReturnOrderDocument = 15,
}

export class FilteredCustomerTicketDto implements IFilteredCustomerTicketDto {
    customerTickets?: CustomerTicketDto[];
    count?: number;

    constructor(data?: IFilteredCustomerTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["customerTickets"])) {
                this.customerTickets = [] as any;
                for (let item of _data["customerTickets"])
                    this.customerTickets!.push(CustomerTicketDto.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): FilteredCustomerTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredCustomerTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customerTickets)) {
            data["customerTickets"] = [];
            for (let item of this.customerTickets)
                data["customerTickets"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IFilteredCustomerTicketDto {
    customerTickets?: CustomerTicketDto[];
    count?: number;
}

export class CustomerTicketDto implements ICustomerTicketDto {
    id?: number;
    subject?: string;
    message?: string;
    date?: Date;
    customerPhoneNumber?: string;
    customerName?: string;
    isActive?: boolean;

    constructor(data?: ICustomerTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subject = _data["subject"];
            this.message = _data["message"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.customerPhoneNumber = _data["customerPhoneNumber"];
            this.customerName = _data["customerName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CustomerTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subject"] = this.subject;
        data["message"] = this.message;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["customerPhoneNumber"] = this.customerPhoneNumber;
        data["customerName"] = this.customerName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICustomerTicketDto {
    id?: number;
    subject?: string;
    message?: string;
    date?: Date;
    customerPhoneNumber?: string;
    customerName?: string;
    isActive?: boolean;
}

export class CreateCustomerTicketCommand implements ICreateCustomerTicketCommand {
    subject?: string;
    message?: string;
    customerId?: string;
    customerPhoneNumber?: string;
    customerName?: string;

    constructor(data?: ICreateCustomerTicketCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.message = _data["message"];
            this.customerId = _data["customerId"];
            this.customerPhoneNumber = _data["customerPhoneNumber"];
            this.customerName = _data["customerName"];
        }
    }

    static fromJS(data: any): CreateCustomerTicketCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerTicketCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["message"] = this.message;
        data["customerId"] = this.customerId;
        data["customerPhoneNumber"] = this.customerPhoneNumber;
        data["customerName"] = this.customerName;
        return data;
    }
}

export interface ICreateCustomerTicketCommand {
    subject?: string;
    message?: string;
    customerId?: string;
    customerPhoneNumber?: string;
    customerName?: string;
}

export class UpdateCustomerTicketCommand implements IUpdateCustomerTicketCommand {
    id?: number;
    subject?: string;
    message?: string;
    isActive?: boolean;

    constructor(data?: IUpdateCustomerTicketCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subject = _data["subject"];
            this.message = _data["message"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateCustomerTicketCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerTicketCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subject"] = this.subject;
        data["message"] = this.message;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateCustomerTicketCommand {
    id?: number;
    subject?: string;
    message?: string;
    isActive?: boolean;
}

export class BlogCategoryDto implements IBlogCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    blogParentCategory?: BlogParentCategoryDto | undefined;
    blogChildrenCategories?: BlogChildCategoryDto[] | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];

    constructor(data?: IBlogCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.image = _data["image"];
            this.isActive = _data["isActive"];
            this.categoryType = _data["categoryType"];
            this.blogParentCategory = _data["blogParentCategory"] ? BlogParentCategoryDto.fromJS(_data["blogParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["blogChildrenCategories"])) {
                this.blogChildrenCategories = [] as any;
                for (let item of _data["blogChildrenCategories"])
                    this.blogChildrenCategories!.push(BlogChildCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["blogCategoryCustomFields"])) {
                this.blogCategoryCustomFields = [] as any;
                for (let item of _data["blogCategoryCustomFields"])
                    this.blogCategoryCustomFields!.push(BlogCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BlogCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["image"] = this.image;
        data["isActive"] = this.isActive;
        data["categoryType"] = this.categoryType;
        data["blogParentCategory"] = this.blogParentCategory ? this.blogParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.blogChildrenCategories)) {
            data["blogChildrenCategories"] = [];
            for (let item of this.blogChildrenCategories)
                data["blogChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.blogCategoryCustomFields)) {
            data["blogCategoryCustomFields"] = [];
            for (let item of this.blogCategoryCustomFields)
                data["blogCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlogCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    blogParentCategory?: BlogParentCategoryDto | undefined;
    blogChildrenCategories?: BlogChildCategoryDto[] | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];
}

export class BlogParentCategoryDto implements IBlogParentCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    categoryType?: CategoryTypeEnum;
    blogParentCategory?: BlogParentCategoryDto | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];

    constructor(data?: IBlogParentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.blogParentCategory = _data["blogParentCategory"] ? BlogParentCategoryDto.fromJS(_data["blogParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["blogCategoryCustomFields"])) {
                this.blogCategoryCustomFields = [] as any;
                for (let item of _data["blogCategoryCustomFields"])
                    this.blogCategoryCustomFields!.push(BlogCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BlogParentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogParentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["blogParentCategory"] = this.blogParentCategory ? this.blogParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.blogCategoryCustomFields)) {
            data["blogCategoryCustomFields"] = [];
            for (let item of this.blogCategoryCustomFields)
                data["blogCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlogParentCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    categoryType?: CategoryTypeEnum;
    blogParentCategory?: BlogParentCategoryDto | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];
}

export class BlogCategoryCustomFieldDto implements IBlogCategoryCustomFieldDto {
    fieldName?: string;
    value?: string;

    constructor(data?: IBlogCategoryCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BlogCategoryCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogCategoryCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IBlogCategoryCustomFieldDto {
    fieldName?: string;
    value?: string;
}

export class BlogChildCategoryDto implements IBlogChildCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    categoryType?: CategoryTypeEnum;
    blogChildrenCategories?: BlogChildCategoryDto[] | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];

    constructor(data?: IBlogChildCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["blogChildrenCategories"])) {
                this.blogChildrenCategories = [] as any;
                for (let item of _data["blogChildrenCategories"])
                    this.blogChildrenCategories!.push(BlogChildCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["blogCategoryCustomFields"])) {
                this.blogCategoryCustomFields = [] as any;
                for (let item of _data["blogCategoryCustomFields"])
                    this.blogCategoryCustomFields!.push(BlogCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BlogChildCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogChildCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.blogChildrenCategories)) {
            data["blogChildrenCategories"] = [];
            for (let item of this.blogChildrenCategories)
                data["blogChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.blogCategoryCustomFields)) {
            data["blogCategoryCustomFields"] = [];
            for (let item of this.blogCategoryCustomFields)
                data["blogCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlogChildCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    categoryType?: CategoryTypeEnum;
    blogChildrenCategories?: BlogChildCategoryDto[] | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];
}

export class CreateBlogCategoryCommand implements ICreateBlogCategoryCommand {
    localizedName?: string;
    name?: string;
    image?: string;
    items?: number | undefined;
    blogParentCategoryId?: number | undefined;
    isActive?: boolean;

    constructor(data?: ICreateBlogCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.items = _data["items"];
            this.blogParentCategoryId = _data["blogParentCategoryId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateBlogCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBlogCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["image"] = this.image;
        data["items"] = this.items;
        data["blogParentCategoryId"] = this.blogParentCategoryId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateBlogCategoryCommand {
    localizedName?: string;
    name?: string;
    image?: string;
    items?: number | undefined;
    blogParentCategoryId?: number | undefined;
    isActive?: boolean;
}

export class UpdateBlogCategoryCommand implements IUpdateBlogCategoryCommand {
    id?: number;
    localizedName?: string;
    name?: string;
    image?: string;
    items?: number | undefined;
    blogParentCategoryId?: number | undefined;
    isActive?: boolean;

    constructor(data?: IUpdateBlogCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.items = _data["items"];
            this.blogParentCategoryId = _data["blogParentCategoryId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateBlogCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBlogCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["image"] = this.image;
        data["items"] = this.items;
        data["blogParentCategoryId"] = this.blogParentCategoryId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateBlogCategoryCommand {
    id?: number;
    localizedName?: string;
    name?: string;
    image?: string;
    items?: number | undefined;
    blogParentCategoryId?: number | undefined;
    isActive?: boolean;
}

export class ProductCategoryDto implements IProductCategoryDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    menuImage?: string | undefined;
    productParentCategoryId?: number | undefined;
    productParentCategoryName?: string | undefined;
    isFeatured?: boolean;
    isPopular?: boolean;
    isActive?: boolean;

    constructor(data?: IProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.menuImage = _data["menuImage"];
            this.productParentCategoryId = _data["productParentCategoryId"];
            this.productParentCategoryName = _data["productParentCategoryName"];
            this.isFeatured = _data["isFeatured"];
            this.isPopular = _data["isPopular"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["menuImage"] = this.menuImage;
        data["productParentCategoryId"] = this.productParentCategoryId;
        data["productParentCategoryName"] = this.productParentCategoryName;
        data["isFeatured"] = this.isFeatured;
        data["isPopular"] = this.isPopular;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductCategoryDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    menuImage?: string | undefined;
    productParentCategoryId?: number | undefined;
    productParentCategoryName?: string | undefined;
    isFeatured?: boolean;
    isPopular?: boolean;
    isActive?: boolean;
}

export class AllProductCategoryDropDownDto implements IAllProductCategoryDropDownDto {
    id?: number;
    localizedName?: string;

    constructor(data?: IAllProductCategoryDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllProductCategoryDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductCategoryDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllProductCategoryDropDownDto {
    id?: number;
    localizedName?: string;
}

export class PaginatedListOfProductCategoryDto implements IPaginatedListOfProductCategoryDto {
    items?: ProductCategoryDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductCategoryDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductCategoryDto {
    items?: ProductCategoryDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CreateProductCategoryCommand implements ICreateProductCategoryCommand {
    code?: number;
    localizedName?: string;
    name?: string;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    menuImage?: string | undefined;
    productParentCategoryId?: number | undefined;
    isPopular?: boolean;
    isFeatured?: boolean;
    isActive?: boolean;

    constructor(data?: ICreateProductCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.menuImage = _data["menuImage"];
            this.productParentCategoryId = _data["productParentCategoryId"];
            this.isPopular = _data["isPopular"];
            this.isFeatured = _data["isFeatured"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateProductCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["menuImage"] = this.menuImage;
        data["productParentCategoryId"] = this.productParentCategoryId;
        data["isPopular"] = this.isPopular;
        data["isFeatured"] = this.isFeatured;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateProductCategoryCommand {
    code?: number;
    localizedName?: string;
    name?: string;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    menuImage?: string | undefined;
    productParentCategoryId?: number | undefined;
    isPopular?: boolean;
    isFeatured?: boolean;
    isActive?: boolean;
}

export class UpdateProductCategoryCommand implements IUpdateProductCategoryCommand {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    menuImage?: string | undefined;
    productParentCategoryId?: number | undefined;
    isPopular?: boolean;
    isFeatured?: boolean;
    isActive?: boolean;

    constructor(data?: IUpdateProductCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.menuImage = _data["menuImage"];
            this.productParentCategoryId = _data["productParentCategoryId"];
            this.isPopular = _data["isPopular"];
            this.isFeatured = _data["isFeatured"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateProductCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["menuImage"] = this.menuImage;
        data["productParentCategoryId"] = this.productParentCategoryId;
        data["isPopular"] = this.isPopular;
        data["isFeatured"] = this.isFeatured;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateProductCategoryCommand {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    menuImage?: string | undefined;
    productParentCategoryId?: number | undefined;
    isPopular?: boolean;
    isFeatured?: boolean;
    isActive?: boolean;
}

export class PaginatedListOfFamilyDto implements IPaginatedListOfFamilyDto {
    items?: FamilyDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FamilyDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfFamilyDto {
    items?: FamilyDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class FamilyDto implements IFamilyDto {
    id?: number;
    localizedName?: string;
    name?: string;
    brandId?: number;
    brandName?: string;
    isActive?: boolean;

    constructor(data?: IFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.brandId = _data["brandId"];
            this.brandName = _data["brandName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): FamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IFamilyDto {
    id?: number;
    localizedName?: string;
    name?: string;
    brandId?: number;
    brandName?: string;
    isActive?: boolean;
}

export class CreateFamilyCommand implements ICreateFamilyCommand {
    localizedName?: string;
    name?: string;
    vehicleBrandId?: number;
    isActive?: boolean;

    constructor(data?: ICreateFamilyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.vehicleBrandId = _data["vehicleBrandId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateFamilyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFamilyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["vehicleBrandId"] = this.vehicleBrandId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateFamilyCommand {
    localizedName?: string;
    name?: string;
    vehicleBrandId?: number;
    isActive?: boolean;
}

export class UpdateFamilyCommand implements IUpdateFamilyCommand {
    id?: number;
    localizedName?: string;
    name?: string;
    vehicleBrandId?: number;
    isActive?: boolean;

    constructor(data?: IUpdateFamilyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.vehicleBrandId = _data["vehicleBrandId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateFamilyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFamilyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["vehicleBrandId"] = this.vehicleBrandId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateFamilyCommand {
    id?: number;
    localizedName?: string;
    name?: string;
    vehicleBrandId?: number;
    isActive?: boolean;
}

export class PaginatedListOfKindDto implements IPaginatedListOfKindDto {
    items?: KindDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfKindDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(KindDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfKindDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfKindDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfKindDto {
    items?: KindDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class KindDto implements IKindDto {
    id?: number;
    localizedName?: string;
    name?: string;
    modelId?: number;
    isActive?: boolean;
    modelName?: string;

    constructor(data?: IKindDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.modelId = _data["modelId"];
            this.isActive = _data["isActive"];
            this.modelName = _data["modelName"];
        }
    }

    static fromJS(data: any): KindDto {
        data = typeof data === 'object' ? data : {};
        let result = new KindDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["modelId"] = this.modelId;
        data["isActive"] = this.isActive;
        data["modelName"] = this.modelName;
        return data;
    }
}

export interface IKindDto {
    id?: number;
    localizedName?: string;
    name?: string;
    modelId?: number;
    isActive?: boolean;
    modelName?: string;
}

export class AllKindDropDownDto implements IAllKindDropDownDto {
    id?: number;
    localizedName?: string;

    constructor(data?: IAllKindDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllKindDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllKindDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllKindDropDownDto {
    id?: number;
    localizedName?: string;
}

export class CreateKindCommand implements ICreateKindCommand {
    localizedName?: string;
    name?: string;
    modelId?: number;
    isActive?: boolean;

    constructor(data?: ICreateKindCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.modelId = _data["modelId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateKindCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateKindCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["modelId"] = this.modelId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateKindCommand {
    localizedName?: string;
    name?: string;
    modelId?: number;
    isActive?: boolean;
}

export class UpdateKindCommand implements IUpdateKindCommand {
    id?: number;
    localizedName?: string;
    name?: string;
    modelId?: number;
    isActive?: boolean;

    constructor(data?: IUpdateKindCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.modelId = _data["modelId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateKindCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateKindCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["modelId"] = this.modelId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateKindCommand {
    id?: number;
    localizedName?: string;
    name?: string;
    modelId?: number;
    isActive?: boolean;
}

export class PaginatedListOfModelDto implements IPaginatedListOfModelDto {
    items?: ModelDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModelDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfModelDto {
    items?: ModelDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ModelDto implements IModelDto {
    id?: number;
    localizedName?: string;
    name?: string;
    familyId?: number;
    familyName?: string;
    isActive?: boolean;

    constructor(data?: IModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.familyId = _data["familyId"];
            this.familyName = _data["familyName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["familyId"] = this.familyId;
        data["familyName"] = this.familyName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IModelDto {
    id?: number;
    localizedName?: string;
    name?: string;
    familyId?: number;
    familyName?: string;
    isActive?: boolean;
}

export class CreateModelCommand implements ICreateModelCommand {
    localizedName?: string;
    name?: string;
    familyId?: number;
    isActive?: boolean;

    constructor(data?: ICreateModelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.familyId = _data["familyId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateModelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["familyId"] = this.familyId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateModelCommand {
    localizedName?: string;
    name?: string;
    familyId?: number;
    isActive?: boolean;
}

export class UpdateModelCommand implements IUpdateModelCommand {
    id?: number;
    localizedName?: string;
    name?: string;
    familyId?: number;
    isActive?: boolean;

    constructor(data?: IUpdateModelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.familyId = _data["familyId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateModelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["familyId"] = this.familyId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateModelCommand {
    id?: number;
    localizedName?: string;
    name?: string;
    familyId?: number;
    isActive?: boolean;
}

export class ProductBrandDto implements IProductBrandDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    code?: number;
    slug?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    isActive?: boolean;

    constructor(data?: IProductBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.slug = _data["slug"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductBrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["code"] = this.code;
        data["slug"] = this.slug;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductBrandDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    code?: number;
    slug?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    isActive?: boolean;
}

export class AllProductBrandDropDownDto implements IAllProductBrandDropDownDto {
    id?: number;
    localizedName?: string;

    constructor(data?: IAllProductBrandDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllProductBrandDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductBrandDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllProductBrandDropDownDto {
    id?: number;
    localizedName?: string;
}

export class CreateProductBrandCommand implements ICreateProductBrandCommand {
    brandLogo?: string | undefined;
    localizedName?: string;
    name?: string;
    code?: number;
    countryId?: number | undefined;
    isActive?: boolean;

    constructor(data?: ICreateProductBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateProductBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateProductBrandCommand {
    brandLogo?: string | undefined;
    localizedName?: string;
    name?: string;
    code?: number;
    countryId?: number | undefined;
    isActive?: boolean;
}

export class UpdateProductBrandCommand implements IUpdateProductBrandCommand {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string;
    name?: string;
    code?: number;
    countryId?: number | undefined;
    isActive?: boolean;

    constructor(data?: IUpdateProductBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateProductBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateProductBrandCommand {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string;
    name?: string;
    code?: number;
    countryId?: number | undefined;
    isActive?: boolean;
}

export class VehicleBrandDto implements IVehicleBrandDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    code?: number;
    slug?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    isActive?: boolean;

    constructor(data?: IVehicleBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.slug = _data["slug"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): VehicleBrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleBrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["code"] = this.code;
        data["slug"] = this.slug;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IVehicleBrandDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    code?: number;
    slug?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    isActive?: boolean;
}

export class AllVehicleBrandDropDownDto implements IAllVehicleBrandDropDownDto {
    id?: number;
    localizedName?: string;

    constructor(data?: IAllVehicleBrandDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllVehicleBrandDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllVehicleBrandDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllVehicleBrandDropDownDto {
    id?: number;
    localizedName?: string;
}

export class CreateVehicleBrandCommand implements ICreateVehicleBrandCommand {
    brandLogo?: string | undefined;
    localizedName?: string;
    name?: string;
    code?: number;
    countryId?: number | undefined;
    isActive?: boolean;

    constructor(data?: ICreateVehicleBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateVehicleBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVehicleBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateVehicleBrandCommand {
    brandLogo?: string | undefined;
    localizedName?: string;
    name?: string;
    code?: number;
    countryId?: number | undefined;
    isActive?: boolean;
}

export class UpdateVehicleBrandCommand implements IUpdateVehicleBrandCommand {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string;
    name?: string;
    code?: number;
    countryId?: number | undefined;
    isActive?: boolean;

    constructor(data?: IUpdateVehicleBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateVehicleBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateVehicleBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateVehicleBrandCommand {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string;
    name?: string;
    code?: number;
    countryId?: number | undefined;
    isActive?: boolean;
}

export class PaginatedListOfVehicleByIdDto implements IPaginatedListOfVehicleByIdDto {
    items?: VehicleByIdDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfVehicleByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VehicleByIdDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfVehicleByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfVehicleByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfVehicleByIdDto {
    items?: VehicleByIdDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class VehicleByIdDto implements IVehicleByIdDto {
    id?: number;
    vinNumber?: string;
    kind?: KindForVehicleDto;
    customers?: CustomerForVehicleDto[];

    constructor(data?: IVehicleByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.kind = _data["kind"] ? KindForVehicleDto.fromJS(_data["kind"]) : <any>undefined;
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(CustomerForVehicleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["kind"] = this.kind ? this.kind.toJSON() : <any>undefined;
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVehicleByIdDto {
    id?: number;
    vinNumber?: string;
    kind?: KindForVehicleDto;
    customers?: CustomerForVehicleDto[];
}

export class KindForVehicleDto implements IKindForVehicleDto {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;

    constructor(data?: IKindForVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.brandLocalizedName = _data["brandLocalizedName"];
            this.familyName = _data["familyName"];
            this.familyLocalizedName = _data["familyLocalizedName"];
            this.modelName = _data["modelName"];
            this.modelLocalizedName = _data["modelLocalizedName"];
        }
    }

    static fromJS(data: any): KindForVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new KindForVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["brandLocalizedName"] = this.brandLocalizedName;
        data["familyName"] = this.familyName;
        data["familyLocalizedName"] = this.familyLocalizedName;
        data["modelName"] = this.modelName;
        data["modelLocalizedName"] = this.modelLocalizedName;
        return data;
    }
}

export interface IKindForVehicleDto {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;
}

export class CustomerForVehicleDto implements ICustomerForVehicleDto {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerForVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerForVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerForVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerForVehicleDto {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class VehicleDto implements IVehicleDto {
    id?: number;
    vinNumber?: string;
    kindId?: number;
    kindName?: string;
    customerId?: string;
    customerName?: string;

    constructor(data?: IVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.kindId = _data["kindId"];
            this.kindName = _data["kindName"];
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
        }
    }

    static fromJS(data: any): VehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["kindId"] = this.kindId;
        data["kindName"] = this.kindName;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        return data;
    }
}

export interface IVehicleDto {
    id?: number;
    vinNumber?: string;
    kindId?: number;
    kindName?: string;
    customerId?: string;
    customerName?: string;
}

export class VehicleForVinDto implements IVehicleForVinDto {
    id?: number;
    vinNumber?: string;
    kind?: KindForVehicleDto;

    constructor(data?: IVehicleForVinDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.kind = _data["kind"] ? KindForVehicleDto.fromJS(_data["kind"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VehicleForVinDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleForVinDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["kind"] = this.kind ? this.kind.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVehicleForVinDto {
    id?: number;
    vinNumber?: string;
    kind?: KindForVehicleDto;
}

export class CreateVehicleCommand implements ICreateVehicleCommand {
    vinNumber?: string | undefined;
    kindId?: number;
    customerId?: string;

    constructor(data?: ICreateVehicleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vinNumber = _data["vinNumber"];
            this.kindId = _data["kindId"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): CreateVehicleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVehicleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vinNumber"] = this.vinNumber;
        data["kindId"] = this.kindId;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface ICreateVehicleCommand {
    vinNumber?: string | undefined;
    kindId?: number;
    customerId?: string;
}

export class UpdateVehicleCommand implements IUpdateVehicleCommand {
    id?: number;
    vinNumber?: string | undefined;
    kindId?: number;
    customerId?: string;

    constructor(data?: IUpdateVehicleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.kindId = _data["kindId"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): UpdateVehicleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateVehicleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["kindId"] = this.kindId;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IUpdateVehicleCommand {
    id?: number;
    vinNumber?: string | undefined;
    kindId?: number;
    customerId?: string;
}

export class CommentDto implements ICommentDto {
    id?: number;
    text?: string;
    date?: Date;
    author?: CustomerDto2;
    isActive?: boolean;

    constructor(data?: ICommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.author = _data["author"] ? CustomerDto2.fromJS(_data["author"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICommentDto {
    id?: number;
    text?: string;
    date?: Date;
    author?: CustomerDto2;
    isActive?: boolean;
}

export class CustomerDto2 implements ICustomerDto2 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerDto2 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class CreateCommentCommand implements ICreateCommentCommand {
    text?: string;
    authorId?: string;
    postId?: number;
    parentCommentId?: number | undefined;
    isActive?: boolean;

    constructor(data?: ICreateCommentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.authorId = _data["authorId"];
            this.postId = _data["postId"];
            this.parentCommentId = _data["parentCommentId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateCommentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["authorId"] = this.authorId;
        data["postId"] = this.postId;
        data["parentCommentId"] = this.parentCommentId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateCommentCommand {
    text?: string;
    authorId?: string;
    postId?: number;
    parentCommentId?: number | undefined;
    isActive?: boolean;
}

export class UpdateCommentCommand implements IUpdateCommentCommand {
    id?: number;
    text?: string;
    authorId?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpdateCommentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.authorId = _data["authorId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateCommentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["authorId"] = this.authorId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateCommentCommand {
    id?: number;
    text?: string;
    authorId?: string | undefined;
    isActive?: boolean;
}

export class PaginatedListOfPostDto implements IPaginatedListOfPostDto {
    items?: PostDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PostDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfPostDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfPostDto {
    items?: PostDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PostDto implements IPostDto {
    id?: number;
    title?: string;
    body?: string;
    image?: string | undefined;
    date?: Date;
    author?: UserDto;
    comments?: CommentDto[];
    isActive?: boolean;

    constructor(data?: IPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.body = _data["body"];
            this.image = _data["image"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.author = _data["author"] ? UserDto.fromJS(_data["author"]) : <any>undefined;
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PostDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["body"] = this.body;
        data["image"] = this.image;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IPostDto {
    id?: number;
    title?: string;
    body?: string;
    image?: string | undefined;
    date?: Date;
    author?: UserDto;
    comments?: CommentDto[];
    isActive?: boolean;
}

export class WidgetCommentDto implements IWidgetCommentDto {
    id?: number;
    postTitle?: string | undefined;
    text?: string | undefined;
    date?: Date;
    author?: CustomerDto3;
    isActive?: boolean;

    constructor(data?: IWidgetCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.postTitle = _data["postTitle"];
            this.text = _data["text"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.author = _data["author"] ? CustomerDto3.fromJS(_data["author"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): WidgetCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["postTitle"] = this.postTitle;
        data["text"] = this.text;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IWidgetCommentDto {
    id?: number;
    postTitle?: string | undefined;
    text?: string | undefined;
    date?: Date;
    author?: CustomerDto3;
    isActive?: boolean;
}

export class CustomerDto3 implements ICustomerDto3 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerDto3 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class UpdateWidgetCommentCommand implements IUpdateWidgetCommentCommand {
    id?: number;
    postTitle?: string | undefined;
    text?: string | undefined;
    authorId?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpdateWidgetCommentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.postTitle = _data["postTitle"];
            this.text = _data["text"];
            this.authorId = _data["authorId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateWidgetCommentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWidgetCommentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["postTitle"] = this.postTitle;
        data["text"] = this.text;
        data["authorId"] = this.authorId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateWidgetCommentCommand {
    id?: number;
    postTitle?: string | undefined;
    text?: string | undefined;
    authorId?: string | undefined;
    isActive?: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}