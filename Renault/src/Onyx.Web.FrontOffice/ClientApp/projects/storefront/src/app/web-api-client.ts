//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAddressesClient {
    getAddressesByCustomerId(): Observable<AddressDto[]>;
    getAddressById(id: number): Observable<AddressDto>;
    getDefaultAddress(): Observable<AddressDto>;
    create(command: CreateAddressCommand): Observable<number>;
    selfUpdate(id: number, command: UpdateAddressCommand): Observable<FileResponse>;
    selfDelete(id: number): Observable<FileResponse>;
    isUniqueAddressTitle(customerId: string | undefined, addressId: number | undefined, title: string | undefined): Observable<boolean>;
    isUniqueAddressPostcode(customerId: string | undefined, addressId: number | undefined, postcode: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class AddressesClient implements IAddressesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAddressesByCustomerId(): Observable<AddressDto[]> {
        let url_ = this.baseUrl + "/api/Addresses/selfCustomer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressesByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressesByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto[]>;
        }));
    }

    protected processGetAddressesByCustomerId(response: HttpResponseBase): Observable<AddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAddressById(id: number): Observable<AddressDto> {
        let url_ = this.baseUrl + "/api/Addresses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto>;
        }));
    }

    protected processGetAddressById(response: HttpResponseBase): Observable<AddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDefaultAddress(): Observable<AddressDto> {
        let url_ = this.baseUrl + "/api/Addresses/selfDefault";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto>;
        }));
    }

    protected processGetDefaultAddress(response: HttpResponseBase): Observable<AddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateAddressCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Addresses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfUpdate(id: number, command: UpdateAddressCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Addresses/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSelfUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfDelete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Addresses/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSelfDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueAddressTitle(customerId: string | undefined, addressId: number | undefined, title: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Addresses/isUniqueTitle?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (addressId === null)
            throw new Error("The parameter 'addressId' cannot be null.");
        else if (addressId !== undefined)
            url_ += "AddressId=" + encodeURIComponent("" + addressId) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueAddressTitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueAddressTitle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueAddressTitle(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUniqueAddressPostcode(customerId: string | undefined, addressId: number | undefined, postcode: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Addresses/isUniquePostcode?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (addressId === null)
            throw new Error("The parameter 'addressId' cannot be null.");
        else if (addressId !== undefined)
            url_ += "AddressId=" + encodeURIComponent("" + addressId) + "&";
        if (postcode === null)
            throw new Error("The parameter 'postcode' cannot be null.");
        else if (postcode !== undefined)
            url_ += "Postcode=" + encodeURIComponent("" + postcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUniqueAddressPostcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUniqueAddressPostcode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUniqueAddressPostcode(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICreditsClient {
    getCreditsByCustomerIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerId: string | undefined): Observable<PaginatedListOfCreditDto>;
    getCreditByCustomerId(customerId: string | undefined): Observable<number | null>;
}

@Injectable({
    providedIn: 'root'
})
export class CreditsClient implements ICreditsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCreditsByCustomerIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerId: string | undefined): Observable<PaginatedListOfCreditDto> {
        let url_ = this.baseUrl + "/api/Credits?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreditsByCustomerIdWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreditsByCustomerIdWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCreditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCreditDto>;
        }));
    }

    protected processGetCreditsByCustomerIdWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCreditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCreditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCreditByCustomerId(customerId: string | undefined): Observable<number | null> {
        let url_ = this.baseUrl + "/api/Credits/lastCredit?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreditByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreditByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number | null>;
        }));
    }

    protected processGetCreditByCustomerId(response: HttpResponseBase): Observable<number | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICustomersClient {
    getCustomerById(): Observable<CustomerDto>;
    create(command: CreateCustomerCommand): Observable<string>;
    update(urlId: string, command: UpdateCustomerCommand): Observable<FileResponse>;
    addVehicleToCustomer(command: AddVehicleToCustomerCommand): Observable<FileResponse>;
    removeVehicleFromCustomer(vehicleId: number | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomersClient implements ICustomersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCustomerById(): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto>;
        }));
    }

    protected processGetCustomerById(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCustomerCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(urlId: string, command: UpdateCustomerCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/{urlId}";
        if (urlId === undefined || urlId === null)
            throw new Error("The parameter 'urlId' must be defined.");
        url_ = url_.replace("{urlId}", encodeURIComponent("" + urlId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addVehicleToCustomer(command: AddVehicleToCustomerCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/addVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVehicleToCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVehicleToCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAddVehicleToCustomer(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeVehicleFromCustomer(vehicleId: number | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/removeVehicle?";
        if (vehicleId === null)
            throw new Error("The parameter 'vehicleId' cannot be null.");
        else if (vehicleId !== undefined)
            url_ += "vehicleId=" + encodeURIComponent("" + vehicleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveVehicleFromCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveVehicleFromCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveVehicleFromCustomer(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICustomerTypesClient {
    getCustomerTypeByCustomerTypeEnum(): Observable<CustomerTypeDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomerTypesClient implements ICustomerTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCustomerTypeByCustomerTypeEnum(): Observable<CustomerTypeDto> {
        let url_ = this.baseUrl + "/api/CustomerTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTypeByCustomerTypeEnum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTypeByCustomerTypeEnum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTypeDto>;
        }));
    }

    protected processGetCustomerTypeByCustomerTypeEnum(response: HttpResponseBase): Observable<CustomerTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISearchClient {
    getSearchSuggestions(productLimit: number, productCategoryLimit: number, query: string, kindId: number): Observable<SearchSuggestionDto>;
    getProductsByFilter(customerType: CustomerTypeEnum | undefined, productCategorySlug: string | null | undefined, kindId: number | null | undefined, minPrice: number | null | undefined, maxPrice: number | null | undefined, productBrandSlugs: string[] | null | undefined, vehicleBrandSlugs: string[] | null | undefined, discount: string | null | undefined, ratings: number[] | null | undefined, color: string | null | undefined, material: string | null | undefined, searchText: string | null | undefined, pageNumber: number | undefined, limit: number | undefined, sort: string | undefined): Observable<FilterViewModel>;
}

@Injectable({
    providedIn: 'root'
})
export class SearchClient implements ISearchClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getSearchSuggestions(productLimit: number, productCategoryLimit: number, query: string, kindId: number): Observable<SearchSuggestionDto> {
        let url_ = this.baseUrl + "/api/Search/getSearchSuggestions{productLimit},{productCategoryLimit},{query},{kindId}";
        if (productLimit === undefined || productLimit === null)
            throw new Error("The parameter 'productLimit' must be defined.");
        url_ = url_.replace("{productLimit}", encodeURIComponent("" + productLimit));
        if (productCategoryLimit === undefined || productCategoryLimit === null)
            throw new Error("The parameter 'productCategoryLimit' must be defined.");
        url_ = url_.replace("{productCategoryLimit}", encodeURIComponent("" + productCategoryLimit));
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query));
        if (kindId === undefined || kindId === null)
            throw new Error("The parameter 'kindId' must be defined.");
        url_ = url_.replace("{kindId}", encodeURIComponent("" + kindId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSearchSuggestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSearchSuggestions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchSuggestionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchSuggestionDto>;
        }));
    }

    protected processGetSearchSuggestions(response: HttpResponseBase): Observable<SearchSuggestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchSuggestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsByFilter(customerType: CustomerTypeEnum | undefined, productCategorySlug: string | null | undefined, kindId: number | null | undefined, minPrice: number | null | undefined, maxPrice: number | null | undefined, productBrandSlugs: string[] | null | undefined, vehicleBrandSlugs: string[] | null | undefined, discount: string | null | undefined, ratings: number[] | null | undefined, color: string | null | undefined, material: string | null | undefined, searchText: string | null | undefined, pageNumber: number | undefined, limit: number | undefined, sort: string | undefined): Observable<FilterViewModel> {
        let url_ = this.baseUrl + "/api/Search/getProductsByFilter?";
        if (customerType === null)
            throw new Error("The parameter 'customerType' cannot be null.");
        else if (customerType !== undefined)
            url_ += "CustomerType=" + encodeURIComponent("" + customerType) + "&";
        if (productCategorySlug !== undefined && productCategorySlug !== null)
            url_ += "ProductCategorySlug=" + encodeURIComponent("" + productCategorySlug) + "&";
        if (kindId !== undefined && kindId !== null)
            url_ += "KindId=" + encodeURIComponent("" + kindId) + "&";
        if (minPrice !== undefined && minPrice !== null)
            url_ += "MinPrice=" + encodeURIComponent("" + minPrice) + "&";
        if (maxPrice !== undefined && maxPrice !== null)
            url_ += "MaxPrice=" + encodeURIComponent("" + maxPrice) + "&";
        if (productBrandSlugs !== undefined && productBrandSlugs !== null)
            productBrandSlugs && productBrandSlugs.forEach(item => { url_ += "ProductBrandSlugs=" + encodeURIComponent("" + item) + "&"; });
        if (vehicleBrandSlugs !== undefined && vehicleBrandSlugs !== null)
            vehicleBrandSlugs && vehicleBrandSlugs.forEach(item => { url_ += "VehicleBrandSlugs=" + encodeURIComponent("" + item) + "&"; });
        if (discount !== undefined && discount !== null)
            url_ += "Discount=" + encodeURIComponent("" + discount) + "&";
        if (ratings !== undefined && ratings !== null)
            ratings && ratings.forEach(item => { url_ += "Ratings=" + encodeURIComponent("" + item) + "&"; });
        if (color !== undefined && color !== null)
            url_ += "Color=" + encodeURIComponent("" + color) + "&";
        if (material !== undefined && material !== null)
            url_ += "Material=" + encodeURIComponent("" + material) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilterViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilterViewModel>;
        }));
    }

    protected processGetProductsByFilter(response: HttpResponseBase): Observable<FilterViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReturnOrdersClient {
    getReturnOrdersByCustomerId(): Observable<ReturnOrderByCustomerIdDto[]>;
    getReturnOrderById(id: number): Observable<ReturnOrderByIdDto>;
    getReturnOrdersByOrderId(orderId: number): Observable<ReturnOrderByOrderIdDto[]>;
    getReturnOrderByNumber(number: string | undefined, phoneNumber: string | undefined): Observable<ReturnOrderByNumberDto>;
    getReturnOrdersByCustomerIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerId: string | undefined): Observable<PaginatedListOfReturnOrderByCustomerIdWithPaginationDto>;
    create(command: CreateReturnOrderCommand): Observable<number>;
    send(id: number, command: SendReturnOrderCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReturnOrdersClient implements IReturnOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getReturnOrdersByCustomerId(): Observable<ReturnOrderByCustomerIdDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrders/selfCustomer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrdersByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrdersByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderByCustomerIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderByCustomerIdDto[]>;
        }));
    }

    protected processGetReturnOrdersByCustomerId(response: HttpResponseBase): Observable<ReturnOrderByCustomerIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderByCustomerIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrderById(id: number): Observable<ReturnOrderByIdDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/self/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderByIdDto>;
        }));
    }

    protected processGetReturnOrderById(response: HttpResponseBase): Observable<ReturnOrderByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReturnOrderByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrdersByOrderId(orderId: number): Observable<ReturnOrderByOrderIdDto[]> {
        let url_ = this.baseUrl + "/api/ReturnOrders/selfOrderId/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrdersByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrdersByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderByOrderIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderByOrderIdDto[]>;
        }));
    }

    protected processGetReturnOrdersByOrderId(response: HttpResponseBase): Observable<ReturnOrderByOrderIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReturnOrderByOrderIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrderByNumber(number: string | undefined, phoneNumber: string | undefined): Observable<ReturnOrderByNumberDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders/ByNumber?";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrderByNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrderByNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnOrderByNumberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnOrderByNumberDto>;
        }));
    }

    protected processGetReturnOrderByNumber(response: HttpResponseBase): Observable<ReturnOrderByNumberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReturnOrderByNumberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReturnOrdersByCustomerIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerId: string | undefined): Observable<PaginatedListOfReturnOrderByCustomerIdWithPaginationDto> {
        let url_ = this.baseUrl + "/api/ReturnOrders?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReturnOrdersByCustomerIdWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReturnOrdersByCustomerIdWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfReturnOrderByCustomerIdWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfReturnOrderByCustomerIdWithPaginationDto>;
        }));
    }

    protected processGetReturnOrdersByCustomerIdWithPagination(response: HttpResponseBase): Observable<PaginatedListOfReturnOrderByCustomerIdWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfReturnOrderByCustomerIdWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateReturnOrderCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ReturnOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    send(id: number, command: SendReturnOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ReturnOrders/send/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IBadgesClient {
    getAllBadges(): Observable<AllBadgeDto[]>;
    getBadgeById(id: number): Observable<BadgeByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class BadgesClient implements IBadgesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllBadges(): Observable<AllBadgeDto[]> {
        let url_ = this.baseUrl + "/api/Badges/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBadges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBadges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllBadgeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllBadgeDto[]>;
        }));
    }

    protected processGetAllBadges(response: HttpResponseBase): Observable<AllBadgeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllBadgeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBadgeById(id: number): Observable<BadgeByIdDto> {
        let url_ = this.baseUrl + "/api/Badges/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBadgeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBadgeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BadgeByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BadgeByIdDto>;
        }));
    }

    protected processGetBadgeById(response: HttpResponseBase): Observable<BadgeByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BadgeByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICountingUnitsClient {
    getCountingUnitsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountingUnitWithPaginationDto>;
    getAllCountingUnits(): Observable<AllCountingUnitDto[]>;
    getCountingUnitById(id: number): Observable<CountingUnitByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CountingUnitsClient implements ICountingUnitsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCountingUnitsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountingUnitWithPaginationDto> {
        let url_ = this.baseUrl + "/api/CountingUnits?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountingUnitsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountingUnitsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCountingUnitWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCountingUnitWithPaginationDto>;
        }));
    }

    protected processGetCountingUnitsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCountingUnitWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCountingUnitWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCountingUnits(): Observable<AllCountingUnitDto[]> {
        let url_ = this.baseUrl + "/api/CountingUnits/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountingUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountingUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllCountingUnitDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllCountingUnitDto[]>;
        }));
    }

    protected processGetAllCountingUnits(response: HttpResponseBase): Observable<AllCountingUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllCountingUnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCountingUnitById(id: number): Observable<CountingUnitByIdDto> {
        let url_ = this.baseUrl + "/api/CountingUnits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountingUnitById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountingUnitById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountingUnitByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountingUnitByIdDto>;
        }));
    }

    protected processGetCountingUnitById(response: HttpResponseBase): Observable<CountingUnitByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountingUnitByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICountingUnitTypesClient {
    getCountingUnitTypesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountingUnitTypeWithPaginationDto>;
    getAllCountingUnitTypes(): Observable<AllCountingUnitTypeDto[]>;
    getCountingUnitTypeById(id: number): Observable<CountingUnitTypeByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CountingUnitTypesClient implements ICountingUnitTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCountingUnitTypesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountingUnitTypeWithPaginationDto> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountingUnitTypesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountingUnitTypesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCountingUnitTypeWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCountingUnitTypeWithPaginationDto>;
        }));
    }

    protected processGetCountingUnitTypesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCountingUnitTypeWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCountingUnitTypeWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCountingUnitTypes(): Observable<AllCountingUnitTypeDto[]> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountingUnitTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountingUnitTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllCountingUnitTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllCountingUnitTypeDto[]>;
        }));
    }

    protected processGetAllCountingUnitTypes(response: HttpResponseBase): Observable<AllCountingUnitTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllCountingUnitTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCountingUnitTypeById(id: number): Observable<CountingUnitTypeByIdDto> {
        let url_ = this.baseUrl + "/api/CountingUnitTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountingUnitTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountingUnitTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountingUnitTypeByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountingUnitTypeByIdDto>;
        }));
    }

    protected processGetCountingUnitTypeById(response: HttpResponseBase): Observable<CountingUnitTypeByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountingUnitTypeByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductsClient {
    getAllProducts(customerTypeEnum: CustomerTypeEnum | undefined): Observable<AllProductDto[]>;
    getProductsByProductCategoryIdWithPagination(productParentCategoryId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfProductByProductCategoryIdWithPaginationDto>;
    getFeaturedProductsByProductCategoryIdWithPagination(productParentCategoryId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto>;
    getProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfProductWithPaginationDto>;
    getProductsByKindId(kindId: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductByKindIdDto[]>;
    getProductsByProductSubCategoryId(productCategoryId: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductByProductCategoryIdDto[]>;
    getProductsByProductSubCategorySlug(productCategorySlug: string | null | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductByProductCategorySlugDto[]>;
    getProductsByBrandId(brandId: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductByBrandIdDto[]>;
    getProductBySlug(slug: string | undefined, productDisplayVariantName: string | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductBySlugDto>;
    getProductById(id: number | undefined, productDisplayVariantName: string | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductByIdDto>;
    getNewProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfNewProductWithPaginationDto>;
    getPopularProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfPopularProductWithPaginationDto>;
    getSalesProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfSalesProductWithPaginationDto>;
    getTopRatedProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfTopRatedProductWithPaginationDto>;
    getSpecialOffersProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfSpecialOffersProductWithPaginationDto>;
    getBestSellersProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfBestSellerProductWithPaginationDto>;
    getFeaturedProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfFeaturedProductWithPaginationDto>;
    getLatestProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfLatestProductWithPaginationDto>;
    getRelatedProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfRelatedProductWithPaginationDto>;
    getProductsByBrandIdWithPagination(brandId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfProductByBrandIdWithPaginationDto>;
    getProductsByKindIdWithPagination(kindId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfProductByKindIdWithPaginationDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductsClient implements IProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProducts(customerTypeEnum: CustomerTypeEnum | undefined): Observable<AllProductDto[]> {
        let url_ = this.baseUrl + "/api/Products/all?";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductDto[]>;
        }));
    }

    protected processGetAllProducts(response: HttpResponseBase): Observable<AllProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsByProductCategoryIdWithPagination(productParentCategoryId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfProductByProductCategoryIdWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/productCategoryId?";
        if (productParentCategoryId === null)
            throw new Error("The parameter 'productParentCategoryId' cannot be null.");
        else if (productParentCategoryId !== undefined)
            url_ += "ProductParentCategoryId=" + encodeURIComponent("" + productParentCategoryId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByProductCategoryIdWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByProductCategoryIdWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductByProductCategoryIdWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductByProductCategoryIdWithPaginationDto>;
        }));
    }

    protected processGetProductsByProductCategoryIdWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProductByProductCategoryIdWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductByProductCategoryIdWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFeaturedProductsByProductCategoryIdWithPagination(productParentCategoryId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/featuredProductCategoryId?";
        if (productParentCategoryId === null)
            throw new Error("The parameter 'productParentCategoryId' cannot be null.");
        else if (productParentCategoryId !== undefined)
            url_ += "ProductParentCategoryId=" + encodeURIComponent("" + productParentCategoryId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeaturedProductsByProductCategoryIdWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeaturedProductsByProductCategoryIdWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto>;
        }));
    }

    protected processGetFeaturedProductsByProductCategoryIdWithPagination(response: HttpResponseBase): Observable<PaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfProductWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductWithPaginationDto>;
        }));
    }

    protected processGetProductsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProductWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsByKindId(kindId: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductByKindIdDto[]> {
        let url_ = this.baseUrl + "/api/Products/kind?";
        if (kindId === null)
            throw new Error("The parameter 'kindId' cannot be null.");
        else if (kindId !== undefined)
            url_ += "KindId=" + encodeURIComponent("" + kindId) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByKindId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByKindId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductByKindIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductByKindIdDto[]>;
        }));
    }

    protected processGetProductsByKindId(response: HttpResponseBase): Observable<ProductByKindIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductByKindIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsByProductSubCategoryId(productCategoryId: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductByProductCategoryIdDto[]> {
        let url_ = this.baseUrl + "/api/Products/productSubCategoryId?";
        if (productCategoryId === null)
            throw new Error("The parameter 'productCategoryId' cannot be null.");
        else if (productCategoryId !== undefined)
            url_ += "ProductCategoryId=" + encodeURIComponent("" + productCategoryId) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByProductSubCategoryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByProductSubCategoryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductByProductCategoryIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductByProductCategoryIdDto[]>;
        }));
    }

    protected processGetProductsByProductSubCategoryId(response: HttpResponseBase): Observable<ProductByProductCategoryIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductByProductCategoryIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsByProductSubCategorySlug(productCategorySlug: string | null | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductByProductCategorySlugDto[]> {
        let url_ = this.baseUrl + "/api/Products/productSubCategorySlug?";
        if (productCategorySlug !== undefined && productCategorySlug !== null)
            url_ += "ProductCategorySlug=" + encodeURIComponent("" + productCategorySlug) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByProductSubCategorySlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByProductSubCategorySlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductByProductCategorySlugDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductByProductCategorySlugDto[]>;
        }));
    }

    protected processGetProductsByProductSubCategorySlug(response: HttpResponseBase): Observable<ProductByProductCategorySlugDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductByProductCategorySlugDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsByBrandId(brandId: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductByBrandIdDto[]> {
        let url_ = this.baseUrl + "/api/Products/brand?";
        if (brandId === null)
            throw new Error("The parameter 'brandId' cannot be null.");
        else if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByBrandId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByBrandId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductByBrandIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductByBrandIdDto[]>;
        }));
    }

    protected processGetProductsByBrandId(response: HttpResponseBase): Observable<ProductByBrandIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductByBrandIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductBySlug(slug: string | undefined, productDisplayVariantName: string | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductBySlugDto> {
        let url_ = this.baseUrl + "/api/Products/slug?";
        if (slug === null)
            throw new Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "Slug=" + encodeURIComponent("" + slug) + "&";
        if (productDisplayVariantName === null)
            throw new Error("The parameter 'productDisplayVariantName' cannot be null.");
        else if (productDisplayVariantName !== undefined)
            url_ += "ProductDisplayVariantName=" + encodeURIComponent("" + productDisplayVariantName) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductBySlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductBySlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductBySlugDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductBySlugDto>;
        }));
    }

    protected processGetProductBySlug(response: HttpResponseBase): Observable<ProductBySlugDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductBySlugDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductById(id: number | undefined, productDisplayVariantName: string | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<ProductByIdDto> {
        let url_ = this.baseUrl + "/api/Products/ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (productDisplayVariantName === null)
            throw new Error("The parameter 'productDisplayVariantName' cannot be null.");
        else if (productDisplayVariantName !== undefined)
            url_ += "ProductDisplayVariantName=" + encodeURIComponent("" + productDisplayVariantName) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductByIdDto>;
        }));
    }

    protected processGetProductById(response: HttpResponseBase): Observable<ProductByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getNewProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfNewProductWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/new?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewProductsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewProductsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfNewProductWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfNewProductWithPaginationDto>;
        }));
    }

    protected processGetNewProductsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfNewProductWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfNewProductWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPopularProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfPopularProductWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/popular?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPopularProductsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPopularProductsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfPopularProductWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfPopularProductWithPaginationDto>;
        }));
    }

    protected processGetPopularProductsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfPopularProductWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfPopularProductWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSalesProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfSalesProductWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/sales?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesProductsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesProductsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfSalesProductWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfSalesProductWithPaginationDto>;
        }));
    }

    protected processGetSalesProductsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfSalesProductWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfSalesProductWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTopRatedProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfTopRatedProductWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/topRated?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopRatedProductsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopRatedProductsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTopRatedProductWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTopRatedProductWithPaginationDto>;
        }));
    }

    protected processGetTopRatedProductsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfTopRatedProductWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTopRatedProductWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSpecialOffersProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfSpecialOffersProductWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/specialOffers?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpecialOffersProductsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpecialOffersProductsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfSpecialOffersProductWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfSpecialOffersProductWithPaginationDto>;
        }));
    }

    protected processGetSpecialOffersProductsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfSpecialOffersProductWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfSpecialOffersProductWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBestSellersProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfBestSellerProductWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/bestSellers?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBestSellersProductsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBestSellersProductsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfBestSellerProductWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfBestSellerProductWithPaginationDto>;
        }));
    }

    protected processGetBestSellersProductsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfBestSellerProductWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfBestSellerProductWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFeaturedProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfFeaturedProductWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/featured?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeaturedProductsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeaturedProductsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfFeaturedProductWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfFeaturedProductWithPaginationDto>;
        }));
    }

    protected processGetFeaturedProductsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfFeaturedProductWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfFeaturedProductWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLatestProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfLatestProductWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/latest?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestProductsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestProductsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfLatestProductWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfLatestProductWithPaginationDto>;
        }));
    }

    protected processGetLatestProductsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfLatestProductWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfLatestProductWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRelatedProductsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfRelatedProductWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/related?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedProductsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedProductsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfRelatedProductWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfRelatedProductWithPaginationDto>;
        }));
    }

    protected processGetRelatedProductsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfRelatedProductWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfRelatedProductWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsByBrandIdWithPagination(brandId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfProductByBrandIdWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/brandIdWithPagination?";
        if (brandId === null)
            throw new Error("The parameter 'brandId' cannot be null.");
        else if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByBrandIdWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByBrandIdWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductByBrandIdWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductByBrandIdWithPaginationDto>;
        }));
    }

    protected processGetProductsByBrandIdWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProductByBrandIdWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductByBrandIdWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsByKindIdWithPagination(kindId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, customerTypeEnum: CustomerTypeEnum | undefined): Observable<PaginatedListOfProductByKindIdWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Products/kindIdWithPagination?";
        if (kindId === null)
            throw new Error("The parameter 'kindId' cannot be null.");
        else if (kindId !== undefined)
            url_ += "KindId=" + encodeURIComponent("" + kindId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerTypeEnum === null)
            throw new Error("The parameter 'customerTypeEnum' cannot be null.");
        else if (customerTypeEnum !== undefined)
            url_ += "CustomerTypeEnum=" + encodeURIComponent("" + customerTypeEnum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByKindIdWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByKindIdWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductByKindIdWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductByKindIdWithPaginationDto>;
        }));
    }

    protected processGetProductsByKindIdWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProductByKindIdWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductByKindIdWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductStatusesClient {
    getProductStatusesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductStatusWithPaginationDto>;
    getAllProductStatuses(): Observable<AllProductStatusDto[]>;
    getProductStatusById(id: number): Observable<ProductStatusByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductStatusesClient implements IProductStatusesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getProductStatusesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductStatusWithPaginationDto> {
        let url_ = this.baseUrl + "/api/ProductStatuses?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductStatusesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductStatusesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductStatusWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductStatusWithPaginationDto>;
        }));
    }

    protected processGetProductStatusesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProductStatusWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductStatusWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductStatuses(): Observable<AllProductStatusDto[]> {
        let url_ = this.baseUrl + "/api/ProductStatuses/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductStatusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductStatusDto[]>;
        }));
    }

    protected processGetAllProductStatuses(response: HttpResponseBase): Observable<AllProductStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductStatusById(id: number): Observable<ProductStatusByIdDto> {
        let url_ = this.baseUrl + "/api/ProductStatuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductStatusById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductStatusById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductStatusByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductStatusByIdDto>;
        }));
    }

    protected processGetProductStatusById(response: HttpResponseBase): Observable<ProductStatusByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStatusByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductTypesClient {
    getProductTypesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductTypeWithPaginationDto>;
    getAllProductTypes(): Observable<AllProductTypeDto[]>;
    getProductTypeById(id: number): Observable<ProductTypeByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductTypesClient implements IProductTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getProductTypesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductTypeWithPaginationDto> {
        let url_ = this.baseUrl + "/api/ProductTypes?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTypesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTypesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductTypeWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductTypeWithPaginationDto>;
        }));
    }

    protected processGetProductTypesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProductTypeWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductTypeWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductTypes(): Observable<AllProductTypeDto[]> {
        let url_ = this.baseUrl + "/api/ProductTypes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductTypeDto[]>;
        }));
    }

    protected processGetAllProductTypes(response: HttpResponseBase): Observable<AllProductTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductTypeById(id: number): Observable<ProductTypeByIdDto> {
        let url_ = this.baseUrl + "/api/ProductTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTypeByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTypeByIdDto>;
        }));
    }

    protected processGetProductTypeById(response: HttpResponseBase): Observable<ProductTypeByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductTypeByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProvidersClient {
    getProvidersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProviderWithPaginationDto>;
    getAllProviders(): Observable<AllProviderDto[]>;
    getProviderById(id: number): Observable<ProviderByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ProvidersClient implements IProvidersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getProvidersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProviderWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Providers?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProvidersWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProvidersWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProviderWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProviderWithPaginationDto>;
        }));
    }

    protected processGetProvidersWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProviderWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProviderWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProviders(): Observable<AllProviderDto[]> {
        let url_ = this.baseUrl + "/api/Providers/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProviderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProviderDto[]>;
        }));
    }

    protected processGetAllProviders(response: HttpResponseBase): Observable<AllProviderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProviderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProviderById(id: number): Observable<ProviderByIdDto> {
        let url_ = this.baseUrl + "/api/Providers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProviderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProviderById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProviderByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProviderByIdDto>;
        }));
    }

    protected processGetProviderById(response: HttpResponseBase): Observable<ProviderByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProviderByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReviewsClient {
    getReviewsByProductId(productId: number): Observable<ReviewByProductIdDto[]>;
    getReviewsByProductIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, productId: number | undefined): Observable<PaginatedListOfReviewByProductIdWithPaginationDto>;
    getReviewById(id: number): Observable<ReviewByIdDto>;
    getReviewsByCustomerId(): Observable<ReviewByCustomerIdDto[]>;
    create(command: CreateReviewCommand): Observable<number>;
    selfDelete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReviewsClient implements IReviewsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getReviewsByProductId(productId: number): Observable<ReviewByProductIdDto[]> {
        let url_ = this.baseUrl + "/api/Reviews/product{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviewsByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviewsByProductId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewByProductIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewByProductIdDto[]>;
        }));
    }

    protected processGetReviewsByProductId(response: HttpResponseBase): Observable<ReviewByProductIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReviewByProductIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReviewsByProductIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, productId: number | undefined): Observable<PaginatedListOfReviewByProductIdWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Reviews/byProductIdWithPagination?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviewsByProductIdWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviewsByProductIdWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfReviewByProductIdWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfReviewByProductIdWithPaginationDto>;
        }));
    }

    protected processGetReviewsByProductIdWithPagination(response: HttpResponseBase): Observable<PaginatedListOfReviewByProductIdWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfReviewByProductIdWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReviewById(id: number): Observable<ReviewByIdDto> {
        let url_ = this.baseUrl + "/api/Reviews/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviewById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviewById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewByIdDto>;
        }));
    }

    protected processGetReviewById(response: HttpResponseBase): Observable<ReviewByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReviewsByCustomerId(): Observable<ReviewByCustomerIdDto[]> {
        let url_ = this.baseUrl + "/api/Reviews/selfCustomer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviewsByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviewsByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewByCustomerIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewByCustomerIdDto[]>;
        }));
    }

    protected processGetReviewsByCustomerId(response: HttpResponseBase): Observable<ReviewByCustomerIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReviewByCustomerIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateReviewCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Reviews";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfDelete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Reviews/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSelfDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITagsClient {
    getAllTags(): Observable<AllTagDto[]>;
    getTagById(id: number): Observable<TagByIdDto2>;
}

@Injectable({
    providedIn: 'root'
})
export class TagsClient implements ITagsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllTags(): Observable<AllTagDto[]> {
        let url_ = this.baseUrl + "/api/Tags/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllTagDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllTagDto[]>;
        }));
    }

    protected processGetAllTags(response: HttpResponseBase): Observable<AllTagDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllTagDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTagById(id: number): Observable<TagByIdDto2> {
        let url_ = this.baseUrl + "/api/Tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagByIdDto2>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagByIdDto2>;
        }));
    }

    protected processGetTagById(response: HttpResponseBase): Observable<TagByIdDto2> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagByIdDto2.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductOptionColorsClient {
    getAllProductOptionColors(): Observable<AllProductOptionColorDto[]>;
    getAllProductOptionValueColors(): Observable<AllProductOptionValueColorDto[]>;
    getProductOptionColorById(id: number): Observable<ProductOptionColorByIdDto2>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductOptionColorsClient implements IProductOptionColorsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductOptionColors(): Observable<AllProductOptionColorDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionColors/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionColors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionColors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductOptionColorDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductOptionColorDto[]>;
        }));
    }

    protected processGetAllProductOptionColors(response: HttpResponseBase): Observable<AllProductOptionColorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductOptionColorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductOptionValueColors(): Observable<AllProductOptionValueColorDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionColors/allValue";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionValueColors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionValueColors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductOptionValueColorDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductOptionValueColorDto[]>;
        }));
    }

    protected processGetAllProductOptionValueColors(response: HttpResponseBase): Observable<AllProductOptionValueColorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductOptionValueColorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductOptionColorById(id: number): Observable<ProductOptionColorByIdDto2> {
        let url_ = this.baseUrl + "/api/ProductOptionColors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductOptionColorById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductOptionColorById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductOptionColorByIdDto2>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductOptionColorByIdDto2>;
        }));
    }

    protected processGetProductOptionColorById(response: HttpResponseBase): Observable<ProductOptionColorByIdDto2> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductOptionColorByIdDto2.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductOptionMaterialsClient {
    getAllProductOptionMaterials(): Observable<AllProductOptionMaterialDto[]>;
    getAllProductOptionValueMaterials(): Observable<AllProductOptionValueMaterialDto[]>;
    getProductOptionMaterialById(id: number): Observable<ProductOptionMaterialByIdDto2>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductOptionMaterialsClient implements IProductOptionMaterialsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductOptionMaterials(): Observable<AllProductOptionMaterialDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionMaterials/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionMaterials(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductOptionMaterialDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductOptionMaterialDto[]>;
        }));
    }

    protected processGetAllProductOptionMaterials(response: HttpResponseBase): Observable<AllProductOptionMaterialDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductOptionMaterialDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductOptionValueMaterials(): Observable<AllProductOptionValueMaterialDto[]> {
        let url_ = this.baseUrl + "/api/ProductOptionMaterials/allValue";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptionValueMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptionValueMaterials(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductOptionValueMaterialDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductOptionValueMaterialDto[]>;
        }));
    }

    protected processGetAllProductOptionValueMaterials(response: HttpResponseBase): Observable<AllProductOptionValueMaterialDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductOptionValueMaterialDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductOptionMaterialById(id: number): Observable<ProductOptionMaterialByIdDto2> {
        let url_ = this.baseUrl + "/api/ProductOptionMaterials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductOptionMaterialById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductOptionMaterialById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductOptionMaterialByIdDto2>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductOptionMaterialByIdDto2>;
        }));
    }

    protected processGetProductOptionMaterialById(response: HttpResponseBase): Observable<ProductOptionMaterialByIdDto2> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductOptionMaterialByIdDto2.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductAttributesClient {
    getAllProductAttributes(): Observable<AllProductAttributeDto[]>;
    getProductAttributeById(id: number): Observable<ProductAttributeByIdDto2>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductAttributesClient implements IProductAttributesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductAttributes(): Observable<AllProductAttributeDto[]> {
        let url_ = this.baseUrl + "/api/ProductAttributes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductAttributes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductAttributes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductAttributeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductAttributeDto[]>;
        }));
    }

    protected processGetAllProductAttributes(response: HttpResponseBase): Observable<AllProductAttributeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductAttributeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductAttributeById(id: number): Observable<ProductAttributeByIdDto2> {
        let url_ = this.baseUrl + "/api/ProductAttributes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductAttributeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductAttributeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeByIdDto2>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeByIdDto2>;
        }));
    }

    protected processGetProductAttributeById(response: HttpResponseBase): Observable<ProductAttributeByIdDto2> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductAttributeByIdDto2.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductAttributeTypesClient {
    getAllProductAttributeTypes(): Observable<AllProductAttributeTypeDto[]>;
    getProductAttributeTypeById(id: number): Observable<ProductAttributeTypeByIdDto2>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductAttributeTypesClient implements IProductAttributeTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductAttributeTypes(): Observable<AllProductAttributeTypeDto[]> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductAttributeTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductAttributeTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductAttributeTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductAttributeTypeDto[]>;
        }));
    }

    protected processGetAllProductAttributeTypes(response: HttpResponseBase): Observable<AllProductAttributeTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductAttributeTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductAttributeTypeById(id: number): Observable<ProductAttributeTypeByIdDto2> {
        let url_ = this.baseUrl + "/api/ProductAttributeTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductAttributeTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductAttributeTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAttributeTypeByIdDto2>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAttributeTypeByIdDto2>;
        }));
    }

    protected processGetProductAttributeTypeById(response: HttpResponseBase): Observable<ProductAttributeTypeByIdDto2> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductAttributeTypeByIdDto2.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOrdersClient {
    getOrdersByCustomerId(): Observable<OrderByCustomerIdDto[]>;
    getOrderById(id: number): Observable<OrderByIdDto>;
    getOrderForReturnById(orderId: number): Observable<OrderForReturnByIdDto>;
    getOrderByNumber(number: string | undefined, phoneNumber: string | undefined): Observable<OrderByNumberDto>;
    getOrdersByCustomerIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerId: string | null | undefined): Observable<PaginatedListOfOrderByCustomerIdWithPaginationDto>;
    createOrder(command: CreateOrderCommand): Observable<number>;
    getInvoice(orderId: number): Observable<OrderInvoiceDto>;
    update(id: number, command: UpdateOrderPriceAndCountCommand): Observable<FileResponse>;
    delete(id: number, command: SelfDeleteOrderCommand): Observable<FileResponse>;
    createCreditOnlineOrderPay(command: CreateCreditOnlineOrderPayCommand): Observable<StartPaymentResult>;
    createOnlineOrderPay(command: CreateOnlineOrderPayCommand): Observable<StartPaymentResult>;
    createCreditOrderPay(command: CreateCreditOrderPayCommand): Observable<number>;
    callback(paymentId: number | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class OrdersClient implements IOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getOrdersByCustomerId(): Observable<OrderByCustomerIdDto[]> {
        let url_ = this.baseUrl + "/api/Orders/selfCustomer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderByCustomerIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderByCustomerIdDto[]>;
        }));
    }

    protected processGetOrdersByCustomerId(response: HttpResponseBase): Observable<OrderByCustomerIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderByCustomerIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderById(id: number): Observable<OrderByIdDto> {
        let url_ = this.baseUrl + "/api/Orders/self/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderByIdDto>;
        }));
    }

    protected processGetOrderById(response: HttpResponseBase): Observable<OrderByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderForReturnById(orderId: number): Observable<OrderForReturnByIdDto> {
        let url_ = this.baseUrl + "/api/Orders/selfForReturn/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderForReturnById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderForReturnById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderForReturnByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderForReturnByIdDto>;
        }));
    }

    protected processGetOrderForReturnById(response: HttpResponseBase): Observable<OrderForReturnByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderForReturnByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderByNumber(number: string | undefined, phoneNumber: string | undefined): Observable<OrderByNumberDto> {
        let url_ = this.baseUrl + "/api/Orders/ByNumber?";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderByNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderByNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderByNumberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderByNumberDto>;
        }));
    }

    protected processGetOrderByNumber(response: HttpResponseBase): Observable<OrderByNumberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderByNumberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrdersByCustomerIdWithPagination(pageNumber: number | undefined, pageSize: number | undefined, customerId: string | null | undefined): Observable<PaginatedListOfOrderByCustomerIdWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Orders?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (customerId !== undefined && customerId !== null)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersByCustomerIdWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersByCustomerIdWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfOrderByCustomerIdWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfOrderByCustomerIdWithPaginationDto>;
        }));
    }

    protected processGetOrdersByCustomerIdWithPagination(response: HttpResponseBase): Observable<PaginatedListOfOrderByCustomerIdWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfOrderByCustomerIdWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createOrder(command: CreateOrderCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getInvoice(orderId: number): Observable<OrderInvoiceDto> {
        let url_ = this.baseUrl + "/api/Orders/selfInvoice/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderInvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderInvoiceDto>;
        }));
    }

    protected processGetInvoice(response: HttpResponseBase): Observable<OrderInvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderInvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateOrderPriceAndCountCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number, command: SelfDeleteOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCreditOnlineOrderPay(command: CreateCreditOnlineOrderPayCommand): Observable<StartPaymentResult> {
        let url_ = this.baseUrl + "/api/Orders/creditOnlinePay";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCreditOnlineOrderPay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCreditOnlineOrderPay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StartPaymentResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StartPaymentResult>;
        }));
    }

    protected processCreateCreditOnlineOrderPay(response: HttpResponseBase): Observable<StartPaymentResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StartPaymentResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createOnlineOrderPay(command: CreateOnlineOrderPayCommand): Observable<StartPaymentResult> {
        let url_ = this.baseUrl + "/api/Orders/onlinePay";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOnlineOrderPay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOnlineOrderPay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StartPaymentResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StartPaymentResult>;
        }));
    }

    protected processCreateOnlineOrderPay(response: HttpResponseBase): Observable<StartPaymentResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StartPaymentResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCreditOrderPay(command: CreateCreditOrderPayCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Orders/creditPay";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCreditOrderPay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCreditOrderPay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateCreditOrderPay(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    callback(paymentId: number | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/callback?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCallback(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IBlockBannersClient {
    getAllBlockBanners(): Observable<BlockBannerDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class BlockBannersClient implements IBlockBannersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllBlockBanners(): Observable<BlockBannerDto[]> {
        let url_ = this.baseUrl + "/api/BlockBanners/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBlockBanners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBlockBanners(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlockBannerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlockBannerDto[]>;
        }));
    }

    protected processGetAllBlockBanners(response: HttpResponseBase): Observable<BlockBannerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlockBannerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICarouselsClient {
    getAllCarousels(): Observable<CarouselDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CarouselsClient implements ICarouselsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllCarousels(): Observable<CarouselDto[]> {
        let url_ = this.baseUrl + "/api/Carousels/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCarousels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCarousels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarouselDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarouselDto[]>;
        }));
    }

    protected processGetAllCarousels(response: HttpResponseBase): Observable<CarouselDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CarouselDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFooterLinkContainersClient {
    getFooterLinkContainersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFooterLinkContainerWithPaginationDto>;
    getAllFooterLinkContainers(): Observable<FooterLinkContainerDto[]>;
    getFooterLinkContainerById(id: number): Observable<FooterLinkContainerDto>;
}

@Injectable({
    providedIn: 'root'
})
export class FooterLinkContainersClient implements IFooterLinkContainersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getFooterLinkContainersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFooterLinkContainerWithPaginationDto> {
        let url_ = this.baseUrl + "/api/FooterLinkContainers?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFooterLinkContainersWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFooterLinkContainersWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfFooterLinkContainerWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfFooterLinkContainerWithPaginationDto>;
        }));
    }

    protected processGetFooterLinkContainersWithPagination(response: HttpResponseBase): Observable<PaginatedListOfFooterLinkContainerWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfFooterLinkContainerWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFooterLinkContainers(): Observable<FooterLinkContainerDto[]> {
        let url_ = this.baseUrl + "/api/FooterLinkContainers/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFooterLinkContainers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFooterLinkContainers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterLinkContainerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterLinkContainerDto[]>;
        }));
    }

    protected processGetAllFooterLinkContainers(response: HttpResponseBase): Observable<FooterLinkContainerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FooterLinkContainerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFooterLinkContainerById(id: number): Observable<FooterLinkContainerDto> {
        let url_ = this.baseUrl + "/api/FooterLinkContainers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFooterLinkContainerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFooterLinkContainerById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterLinkContainerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterLinkContainerDto>;
        }));
    }

    protected processGetFooterLinkContainerById(response: HttpResponseBase): Observable<FooterLinkContainerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FooterLinkContainerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFooterLinksClient {
    getFooterLinksWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFooterLinkDto>;
    getAllFooterLinks(): Observable<FooterLinkDto[]>;
    getFooterLinkById(id: number): Observable<FooterLinkDto>;
}

@Injectable({
    providedIn: 'root'
})
export class FooterLinksClient implements IFooterLinksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getFooterLinksWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFooterLinkDto> {
        let url_ = this.baseUrl + "/api/FooterLinks?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFooterLinksWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFooterLinksWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfFooterLinkDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfFooterLinkDto>;
        }));
    }

    protected processGetFooterLinksWithPagination(response: HttpResponseBase): Observable<PaginatedListOfFooterLinkDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfFooterLinkDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFooterLinks(): Observable<FooterLinkDto[]> {
        let url_ = this.baseUrl + "/api/FooterLinks/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFooterLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFooterLinks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterLinkDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterLinkDto[]>;
        }));
    }

    protected processGetAllFooterLinks(response: HttpResponseBase): Observable<FooterLinkDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FooterLinkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFooterLinkById(id: number): Observable<FooterLinkDto> {
        let url_ = this.baseUrl + "/api/FooterLinks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFooterLinkById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFooterLinkById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterLinkDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterLinkDto>;
        }));
    }

    protected processGetFooterLinkById(response: HttpResponseBase): Observable<FooterLinkDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FooterLinkDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILinksClient {
    getAllLinks(): Observable<AllLinkDto[]>;
    getFirstLayerLinks(): Observable<FirstLayerLinkDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class LinksClient implements ILinksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllLinks(): Observable<AllLinkDto[]> {
        let url_ = this.baseUrl + "/api/Links/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLinks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllLinkDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllLinkDto[]>;
        }));
    }

    protected processGetAllLinks(response: HttpResponseBase): Observable<AllLinkDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllLinkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFirstLayerLinks(): Observable<FirstLayerLinkDto[]> {
        let url_ = this.baseUrl + "/api/Links/firstLayer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFirstLayerLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFirstLayerLinks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FirstLayerLinkDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FirstLayerLinkDto[]>;
        }));
    }

    protected processGetFirstLayerLinks(response: HttpResponseBase): Observable<FirstLayerLinkDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FirstLayerLinkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISocialLinksClient {
    getAllSocialLinks(): Observable<AllSocialLinkDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class SocialLinksClient implements ISocialLinksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllSocialLinks(): Observable<AllSocialLinkDto[]> {
        let url_ = this.baseUrl + "/api/SocialLinks/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSocialLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSocialLinks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllSocialLinkDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllSocialLinkDto[]>;
        }));
    }

    protected processGetAllSocialLinks(response: HttpResponseBase): Observable<AllSocialLinkDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllSocialLinkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IThemesClient {
    getDefaultTheme(): Observable<ThemeDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ThemesClient implements IThemesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getDefaultTheme(): Observable<ThemeDto> {
        let url_ = this.baseUrl + "/api/Themes/default";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThemeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThemeDto>;
        }));
    }

    protected processGetDefaultTheme(response: HttpResponseBase): Observable<ThemeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThemeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAboutUsClient {
    getAboutUs(): Observable<AboutUsDto>;
}

@Injectable({
    providedIn: 'root'
})
export class AboutUsClient implements IAboutUsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAboutUs(): Observable<AboutUsDto> {
        let url_ = this.baseUrl + "/api/AboutUs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAboutUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAboutUs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AboutUsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AboutUsDto>;
        }));
    }

    protected processGetAboutUs(response: HttpResponseBase): Observable<AboutUsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AboutUsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICorporationInfosClient {
    getCorporationInfo(): Observable<CorporationInfoDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CorporationInfosClient implements ICorporationInfosClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCorporationInfo(): Observable<CorporationInfoDto> {
        let url_ = this.baseUrl + "/api/CorporationInfos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCorporationInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCorporationInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporationInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporationInfoDto>;
        }));
    }

    protected processGetCorporationInfo(response: HttpResponseBase): Observable<CorporationInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporationInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICountriesClient {
    getCountriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountryWithPaginationDto>;
    getAllCountries(): Observable<AllCountryDto[]>;
    getCountryById(id: number): Observable<CountryByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CountriesClient implements ICountriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCountriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCountryWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Countries?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountriesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountriesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCountryWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCountryWithPaginationDto>;
        }));
    }

    protected processGetCountriesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCountryWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCountryWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCountries(): Observable<AllCountryDto[]> {
        let url_ = this.baseUrl + "/api/Countries/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllCountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllCountryDto[]>;
        }));
    }

    protected processGetAllCountries(response: HttpResponseBase): Observable<AllCountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllCountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCountryById(id: number): Observable<CountryByIdDto> {
        let url_ = this.baseUrl + "/api/Countries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryByIdDto>;
        }));
    }

    protected processGetCountryById(response: HttpResponseBase): Observable<CountryByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuestionsClient {
    getQuestionsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfQuestionWithPaginationDto>;
    getAllQuestions(): Observable<AllQuestionDto[]>;
    getQuestionById(id: number): Observable<QuestionByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class QuestionsClient implements IQuestionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getQuestionsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfQuestionWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Questions?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfQuestionWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfQuestionWithPaginationDto>;
        }));
    }

    protected processGetQuestionsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfQuestionWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfQuestionWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllQuestions(): Observable<AllQuestionDto[]> {
        let url_ = this.baseUrl + "/api/Questions/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuestions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllQuestionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllQuestionDto[]>;
        }));
    }

    protected processGetAllQuestions(response: HttpResponseBase): Observable<AllQuestionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllQuestionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getQuestionById(id: number): Observable<QuestionByIdDto> {
        let url_ = this.baseUrl + "/api/Questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuestionByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuestionByIdDto>;
        }));
    }

    protected processGetQuestionById(response: HttpResponseBase): Observable<QuestionByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITeamMembersClient {
    getTeamMembersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTeamMemberWithPaginationDto>;
    getAllTeamMembers(): Observable<AllTeamMemberDto[]>;
    getTeamMemberById(id: number): Observable<TeamMemberByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class TeamMembersClient implements ITeamMembersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getTeamMembersWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTeamMemberWithPaginationDto> {
        let url_ = this.baseUrl + "/api/TeamMembers?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeamMembersWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamMembersWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTeamMemberWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTeamMemberWithPaginationDto>;
        }));
    }

    protected processGetTeamMembersWithPagination(response: HttpResponseBase): Observable<PaginatedListOfTeamMemberWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTeamMemberWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllTeamMembers(): Observable<AllTeamMemberDto[]> {
        let url_ = this.baseUrl + "/api/TeamMembers/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeamMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeamMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllTeamMemberDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllTeamMemberDto[]>;
        }));
    }

    protected processGetAllTeamMembers(response: HttpResponseBase): Observable<AllTeamMemberDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllTeamMemberDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTeamMemberById(id: number): Observable<TeamMemberByIdDto> {
        let url_ = this.baseUrl + "/api/TeamMembers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeamMemberById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamMemberById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamMemberByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamMemberByIdDto>;
        }));
    }

    protected processGetTeamMemberById(response: HttpResponseBase): Observable<TeamMemberByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamMemberByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITestimonialsClient {
    getTestimonialsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTestimonialWithPaginationDto>;
    getAllTestimonials(): Observable<AllTestimonialDto[]>;
    getTestimonialById(id: number): Observable<TestimonialByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class TestimonialsClient implements ITestimonialsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getTestimonialsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTestimonialWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Testimonials?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestimonialsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestimonialsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTestimonialWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTestimonialWithPaginationDto>;
        }));
    }

    protected processGetTestimonialsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfTestimonialWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTestimonialWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllTestimonials(): Observable<AllTestimonialDto[]> {
        let url_ = this.baseUrl + "/api/Testimonials/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTestimonials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTestimonials(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllTestimonialDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllTestimonialDto[]>;
        }));
    }

    protected processGetAllTestimonials(response: HttpResponseBase): Observable<AllTestimonialDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllTestimonialDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTestimonialById(id: number): Observable<TestimonialByIdDto> {
        let url_ = this.baseUrl + "/api/Testimonials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestimonialById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestimonialById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestimonialByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestimonialByIdDto>;
        }));
    }

    protected processGetTestimonialById(response: HttpResponseBase): Observable<TestimonialByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestimonialByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFilesClient {
    uploadTemp(file: FileParameter | null | undefined): Observable<FileUploadMetadataDto>;
    downloadTemp(fileId: string): Observable<FileResponse>;
    deleteTemp(fileId: string): Observable<boolean>;
    getTempInfo(fileId: string): Observable<FileUploadMetadataDto>;
    downloadPersisted(fileId: string): Observable<FileResponse>;
    deletePersisted(fileId: string): Observable<boolean>;
    getInfoPersisted(fileId: string): Observable<StoredFileDto>;
}

@Injectable({
    providedIn: 'root'
})
export class FilesClient implements IFilesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    uploadTemp(file: FileParameter | null | undefined): Observable<FileUploadMetadataDto> {
        let url_ = this.baseUrl + "/api/Files/temp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadTemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadTemp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileUploadMetadataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileUploadMetadataDto>;
        }));
    }

    protected processUploadTemp(response: HttpResponseBase): Observable<FileUploadMetadataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileUploadMetadataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadTemp(fileId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Files/temp/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTemp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadTemp(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTemp(fileId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Files/temp/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteTemp(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTempInfo(fileId: string): Observable<FileUploadMetadataDto> {
        let url_ = this.baseUrl + "/api/Files/temp/{fileId}/info";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTempInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTempInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileUploadMetadataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileUploadMetadataDto>;
        }));
    }

    protected processGetTempInfo(response: HttpResponseBase): Observable<FileUploadMetadataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileUploadMetadataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadPersisted(fileId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Files/store/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadPersisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadPersisted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadPersisted(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deletePersisted(fileId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Files/store/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePersisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePersisted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeletePersisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getInfoPersisted(fileId: string): Observable<StoredFileDto> {
        let url_ = this.baseUrl + "/api/Files/store/{fileId}/info";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfoPersisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfoPersisted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoredFileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoredFileDto>;
        }));
    }

    protected processGetInfoPersisted(response: HttpResponseBase): Observable<StoredFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoredFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICustomerTicketsClient {
    getCustomerTicketsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredCustomerTicketDto>;
    create(command: CreateCustomerTicketCommand): Observable<number>;
    deleteRangeCustomerTicket(ids: number[]): Observable<FileResponse>;
    getCustomerTicketsByCustomerId(customerId: string): Observable<CustomerTicketDto[]>;
    getCustomerTicketById(id: number): Observable<CustomerTicketDto>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomerTicketsClient implements ICustomerTicketsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCustomerTicketsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortColumn: string | null | undefined, sortDirection: string | null | undefined, searchTerm: string | null | undefined): Observable<FilteredCustomerTicketDto> {
        let url_ = this.baseUrl + "/api/CustomerTickets?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortColumn !== undefined && sortColumn !== null)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTicketsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTicketsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilteredCustomerTicketDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilteredCustomerTicketDto>;
        }));
    }

    protected processGetCustomerTicketsWithPagination(response: HttpResponseBase): Observable<FilteredCustomerTicketDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilteredCustomerTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCustomerTicketCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CustomerTickets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRangeCustomerTicket(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CustomerTickets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRangeCustomerTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRangeCustomerTicket(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteRangeCustomerTicket(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomerTicketsByCustomerId(customerId: string): Observable<CustomerTicketDto[]> {
        let url_ = this.baseUrl + "/api/CustomerTickets/customer{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTicketsByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTicketsByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTicketDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTicketDto[]>;
        }));
    }

    protected processGetCustomerTicketsByCustomerId(response: HttpResponseBase): Observable<CustomerTicketDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerTicketDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomerTicketById(id: number): Observable<CustomerTicketDto> {
        let url_ = this.baseUrl + "/api/CustomerTickets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTicketById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTicketById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerTicketDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerTicketDto>;
        }));
    }

    protected processGetCustomerTicketById(response: HttpResponseBase): Observable<CustomerTicketDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CustomerTickets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IBlogCategoriesClient {
    getAllBlogCategories(): Observable<BlogCategoryDto[]>;
    getBlogCategoriesByBlogParentCategoryId(blogParentCategoryId: number | null | undefined): Observable<BlogCategoryDto[]>;
    getBlogCategoryById(id: number): Observable<BlogCategoryDto>;
    getBlogCategoryBySlug(slug: string | undefined): Observable<BlogCategoryDto>;
}

@Injectable({
    providedIn: 'root'
})
export class BlogCategoriesClient implements IBlogCategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllBlogCategories(): Observable<BlogCategoryDto[]> {
        let url_ = this.baseUrl + "/api/BlogCategories/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBlogCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBlogCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlogCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlogCategoryDto[]>;
        }));
    }

    protected processGetAllBlogCategories(response: HttpResponseBase): Observable<BlogCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlogCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBlogCategoriesByBlogParentCategoryId(blogParentCategoryId: number | null | undefined): Observable<BlogCategoryDto[]> {
        let url_ = this.baseUrl + "/api/BlogCategories/blogParentCategory?";
        if (blogParentCategoryId !== undefined && blogParentCategoryId !== null)
            url_ += "BlogParentCategoryId=" + encodeURIComponent("" + blogParentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlogCategoriesByBlogParentCategoryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlogCategoriesByBlogParentCategoryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlogCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlogCategoryDto[]>;
        }));
    }

    protected processGetBlogCategoriesByBlogParentCategoryId(response: HttpResponseBase): Observable<BlogCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlogCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBlogCategoryById(id: number): Observable<BlogCategoryDto> {
        let url_ = this.baseUrl + "/api/BlogCategories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlogCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlogCategoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlogCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlogCategoryDto>;
        }));
    }

    protected processGetBlogCategoryById(response: HttpResponseBase): Observable<BlogCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlogCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBlogCategoryBySlug(slug: string | undefined): Observable<BlogCategoryDto> {
        let url_ = this.baseUrl + "/api/BlogCategories/slug?";
        if (slug === null)
            throw new Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "Slug=" + encodeURIComponent("" + slug) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlogCategoryBySlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlogCategoryBySlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlogCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlogCategoryDto>;
        }));
    }

    protected processGetBlogCategoryBySlug(response: HttpResponseBase): Observable<BlogCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlogCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductCategoriesClient {
    getAllProductCategories(): Observable<AllProductCategoryDto[]>;
    getAllFirstLayerProductCategories(): Observable<AllFirstLayerProductCategoryDto[]>;
    getAllProductCategoriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfAllProductCategoryWithPaginationDto>;
    getFeaturedFirstProductCategoriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFeaturedFirstProductCategoryWithPaginationDto>;
    getPopularFirstProductCategoriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfPopularFirstProductCategoryWithPaginationDto>;
    getProductCategoriesByProductParentCategoryId(productParentCategoryId: number | null | undefined): Observable<ProductCategoryByProductParentCategoryIdDto[]>;
    getProductCategoryById(id: number): Observable<ProductCategoryByIdDto>;
    getProductCategoryBySlug(slug: string | undefined): Observable<ProductCategoryBySlugDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductCategoriesClient implements IProductCategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductCategories(): Observable<AllProductCategoryDto[]> {
        let url_ = this.baseUrl + "/api/ProductCategories/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductCategoryDto[]>;
        }));
    }

    protected processGetAllProductCategories(response: HttpResponseBase): Observable<AllProductCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFirstLayerProductCategories(): Observable<AllFirstLayerProductCategoryDto[]> {
        let url_ = this.baseUrl + "/api/ProductCategories/allFirstLayer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFirstLayerProductCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFirstLayerProductCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllFirstLayerProductCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllFirstLayerProductCategoryDto[]>;
        }));
    }

    protected processGetAllFirstLayerProductCategories(response: HttpResponseBase): Observable<AllFirstLayerProductCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllFirstLayerProductCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProductCategoriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfAllProductCategoryWithPaginationDto> {
        let url_ = this.baseUrl + "/api/ProductCategories/allWithPagination?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCategoriesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCategoriesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfAllProductCategoryWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfAllProductCategoryWithPaginationDto>;
        }));
    }

    protected processGetAllProductCategoriesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfAllProductCategoryWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfAllProductCategoryWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFeaturedFirstProductCategoriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfFeaturedFirstProductCategoryWithPaginationDto> {
        let url_ = this.baseUrl + "/api/ProductCategories/featuredFirstWithPagination?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeaturedFirstProductCategoriesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeaturedFirstProductCategoriesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfFeaturedFirstProductCategoryWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfFeaturedFirstProductCategoryWithPaginationDto>;
        }));
    }

    protected processGetFeaturedFirstProductCategoriesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfFeaturedFirstProductCategoryWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfFeaturedFirstProductCategoryWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPopularFirstProductCategoriesWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfPopularFirstProductCategoryWithPaginationDto> {
        let url_ = this.baseUrl + "/api/ProductCategories/popularFirstWithPagination?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPopularFirstProductCategoriesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPopularFirstProductCategoriesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfPopularFirstProductCategoryWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfPopularFirstProductCategoryWithPaginationDto>;
        }));
    }

    protected processGetPopularFirstProductCategoriesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfPopularFirstProductCategoryWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfPopularFirstProductCategoryWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductCategoriesByProductParentCategoryId(productParentCategoryId: number | null | undefined): Observable<ProductCategoryByProductParentCategoryIdDto[]> {
        let url_ = this.baseUrl + "/api/ProductCategories/productParentCategory?";
        if (productParentCategoryId !== undefined && productParentCategoryId !== null)
            url_ += "ProductParentCategoryId=" + encodeURIComponent("" + productParentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoriesByProductParentCategoryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoriesByProductParentCategoryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryByProductParentCategoryIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryByProductParentCategoryIdDto[]>;
        }));
    }

    protected processGetProductCategoriesByProductParentCategoryId(response: HttpResponseBase): Observable<ProductCategoryByProductParentCategoryIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductCategoryByProductParentCategoryIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductCategoryById(id: number): Observable<ProductCategoryByIdDto> {
        let url_ = this.baseUrl + "/api/ProductCategories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryByIdDto>;
        }));
    }

    protected processGetProductCategoryById(response: HttpResponseBase): Observable<ProductCategoryByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductCategoryBySlug(slug: string | undefined): Observable<ProductCategoryBySlugDto> {
        let url_ = this.baseUrl + "/api/ProductCategories/slug?";
        if (slug === null)
            throw new Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "Slug=" + encodeURIComponent("" + slug) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoryBySlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoryBySlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryBySlugDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryBySlugDto>;
        }));
    }

    protected processGetProductCategoryBySlug(response: HttpResponseBase): Observable<ProductCategoryBySlugDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryBySlugDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFamiliesClient {
    getAllFamiliesWithPagination(brandId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfAllFamilyWithPaginationDto>;
    getAllFamilies(): Observable<AllFamilyDto[]>;
    getFamiliesByBrandId(brandId: number): Observable<FamilyByBrandIdDto[]>;
    getFamilyById(id: number): Observable<FamilyByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class FamiliesClient implements IFamiliesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllFamiliesWithPagination(brandId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfAllFamilyWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Families?";
        if (brandId !== undefined && brandId !== null)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFamiliesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFamiliesWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfAllFamilyWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfAllFamilyWithPaginationDto>;
        }));
    }

    protected processGetAllFamiliesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfAllFamilyWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfAllFamilyWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFamilies(): Observable<AllFamilyDto[]> {
        let url_ = this.baseUrl + "/api/Families/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFamilies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFamilies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllFamilyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllFamilyDto[]>;
        }));
    }

    protected processGetAllFamilies(response: HttpResponseBase): Observable<AllFamilyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllFamilyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFamiliesByBrandId(brandId: number): Observable<FamilyByBrandIdDto[]> {
        let url_ = this.baseUrl + "/api/Families/brand{brandId}";
        if (brandId === undefined || brandId === null)
            throw new Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFamiliesByBrandId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFamiliesByBrandId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyByBrandIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyByBrandIdDto[]>;
        }));
    }

    protected processGetFamiliesByBrandId(response: HttpResponseBase): Observable<FamilyByBrandIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FamilyByBrandIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFamilyById(id: number): Observable<FamilyByIdDto> {
        let url_ = this.baseUrl + "/api/Families/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFamilyById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFamilyById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyByIdDto>;
        }));
    }

    protected processGetFamilyById(response: HttpResponseBase): Observable<FamilyByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IKindsClient {
    getKindsWithPagination(modelId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfKindWithPaginationDto>;
    getAllKinds(): Observable<AllKindDto[]>;
    getKindById(id: number): Observable<KindByIdDto>;
    getKindsByModelId(modelId: number): Observable<KindByModelIdDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class KindsClient implements IKindsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getKindsWithPagination(modelId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfKindWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Kinds?";
        if (modelId !== undefined && modelId !== null)
            url_ += "ModelId=" + encodeURIComponent("" + modelId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKindsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKindsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfKindWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfKindWithPaginationDto>;
        }));
    }

    protected processGetKindsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfKindWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfKindWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllKinds(): Observable<AllKindDto[]> {
        let url_ = this.baseUrl + "/api/Kinds/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKinds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKinds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllKindDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllKindDto[]>;
        }));
    }

    protected processGetAllKinds(response: HttpResponseBase): Observable<AllKindDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllKindDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getKindById(id: number): Observable<KindByIdDto> {
        let url_ = this.baseUrl + "/api/Kinds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKindById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKindById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KindByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KindByIdDto>;
        }));
    }

    protected processGetKindById(response: HttpResponseBase): Observable<KindByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KindByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getKindsByModelId(modelId: number): Observable<KindByModelIdDto[]> {
        let url_ = this.baseUrl + "/api/Kinds/model{modelId}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKindsByModelId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKindsByModelId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KindByModelIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KindByModelIdDto[]>;
        }));
    }

    protected processGetKindsByModelId(response: HttpResponseBase): Observable<KindByModelIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KindByModelIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IModelsClient {
    getModelsWithPagination(familyId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfModelWithPaginationDto>;
    getAllModels(): Observable<AllModelDto[]>;
    getModelsByFamilyId(familyId: number): Observable<ModelByFamilyIdDto[]>;
    getModelById(id: number): Observable<ModelByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ModelsClient implements IModelsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getModelsWithPagination(familyId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfModelWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Models?";
        if (familyId !== undefined && familyId !== null)
            url_ += "FamilyId=" + encodeURIComponent("" + familyId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModelsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModelsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfModelWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfModelWithPaginationDto>;
        }));
    }

    protected processGetModelsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfModelWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfModelWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllModels(): Observable<AllModelDto[]> {
        let url_ = this.baseUrl + "/api/Models/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllModels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllModels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllModelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllModelDto[]>;
        }));
    }

    protected processGetAllModels(response: HttpResponseBase): Observable<AllModelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllModelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getModelsByFamilyId(familyId: number): Observable<ModelByFamilyIdDto[]> {
        let url_ = this.baseUrl + "/api/Models/family{familyId}";
        if (familyId === undefined || familyId === null)
            throw new Error("The parameter 'familyId' must be defined.");
        url_ = url_.replace("{familyId}", encodeURIComponent("" + familyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModelsByFamilyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModelsByFamilyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModelByFamilyIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModelByFamilyIdDto[]>;
        }));
    }

    protected processGetModelsByFamilyId(response: HttpResponseBase): Observable<ModelByFamilyIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModelByFamilyIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getModelById(id: number): Observable<ModelByIdDto> {
        let url_ = this.baseUrl + "/api/Models/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModelById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModelById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModelByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModelByIdDto>;
        }));
    }

    protected processGetModelById(response: HttpResponseBase): Observable<ModelByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModelByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductBrandsClient {
    getAllProductBrands(): Observable<AllProductBrandDto[]>;
    getProductBrandsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductBrandWithPaginationDto>;
    getProductBrandsForBlock(limit: number): Observable<PaginatedListOfProductBrandForBlockDto>;
    getProductBrandById(id: number): Observable<ProductBrandByIdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductBrandsClient implements IProductBrandsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllProductBrands(): Observable<AllProductBrandDto[]> {
        let url_ = this.baseUrl + "/api/ProductBrands/allProduct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllProductBrandDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllProductBrandDto[]>;
        }));
    }

    protected processGetAllProductBrands(response: HttpResponseBase): Observable<AllProductBrandDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllProductBrandDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductBrandsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfProductBrandWithPaginationDto> {
        let url_ = this.baseUrl + "/api/ProductBrands/allProductWithPagination?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductBrandsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductBrandsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductBrandWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductBrandWithPaginationDto>;
        }));
    }

    protected processGetProductBrandsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfProductBrandWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductBrandWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductBrandsForBlock(limit: number): Observable<PaginatedListOfProductBrandForBlockDto> {
        let url_ = this.baseUrl + "/api/ProductBrands/allForBlock{limit}";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined.");
        url_ = url_.replace("{limit}", encodeURIComponent("" + limit));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductBrandsForBlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductBrandsForBlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProductBrandForBlockDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProductBrandForBlockDto>;
        }));
    }

    protected processGetProductBrandsForBlock(response: HttpResponseBase): Observable<PaginatedListOfProductBrandForBlockDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProductBrandForBlockDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductBrandById(id: number): Observable<ProductBrandByIdDto> {
        let url_ = this.baseUrl + "/api/ProductBrands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductBrandById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductBrandById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductBrandByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductBrandByIdDto>;
        }));
    }

    protected processGetProductBrandById(response: HttpResponseBase): Observable<ProductBrandByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductBrandByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVehicleBrandsClient {
    getAllVehicleBrands(): Observable<AllVehicleBrandDto[]>;
    getVehicleBrandsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfVehicleBrandWithPaginationDto>;
    getVehicleBrandsForBlock(limit: number): Observable<PaginatedListOfVehicleBrandForBlockDto>;
    getVehicleBrandById(id: number): Observable<VehicleBrandByIdDto>;
    getAllVehicleBrandsForDropDown(): Observable<AllVehicleBrandForDropDownDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class VehicleBrandsClient implements IVehicleBrandsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllVehicleBrands(): Observable<AllVehicleBrandDto[]> {
        let url_ = this.baseUrl + "/api/VehicleBrands/allVehicle";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVehicleBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVehicleBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllVehicleBrandDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllVehicleBrandDto[]>;
        }));
    }

    protected processGetAllVehicleBrands(response: HttpResponseBase): Observable<AllVehicleBrandDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllVehicleBrandDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehicleBrandsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfVehicleBrandWithPaginationDto> {
        let url_ = this.baseUrl + "/api/VehicleBrands/allVehicleWithPagination?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleBrandsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleBrandsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfVehicleBrandWithPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfVehicleBrandWithPaginationDto>;
        }));
    }

    protected processGetVehicleBrandsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfVehicleBrandWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfVehicleBrandWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehicleBrandsForBlock(limit: number): Observable<PaginatedListOfVehicleBrandForBlockDto> {
        let url_ = this.baseUrl + "/api/VehicleBrands/allForBlock{limit}";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined.");
        url_ = url_.replace("{limit}", encodeURIComponent("" + limit));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleBrandsForBlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleBrandsForBlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfVehicleBrandForBlockDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfVehicleBrandForBlockDto>;
        }));
    }

    protected processGetVehicleBrandsForBlock(response: HttpResponseBase): Observable<PaginatedListOfVehicleBrandForBlockDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfVehicleBrandForBlockDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehicleBrandById(id: number): Observable<VehicleBrandByIdDto> {
        let url_ = this.baseUrl + "/api/VehicleBrands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleBrandById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleBrandById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleBrandByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleBrandByIdDto>;
        }));
    }

    protected processGetVehicleBrandById(response: HttpResponseBase): Observable<VehicleBrandByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleBrandByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllVehicleBrandsForDropDown(): Observable<AllVehicleBrandForDropDownDto[]> {
        let url_ = this.baseUrl + "/api/VehicleBrands/allVehicleForDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVehicleBrandsForDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVehicleBrandsForDropDown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllVehicleBrandForDropDownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllVehicleBrandForDropDownDto[]>;
        }));
    }

    protected processGetAllVehicleBrandsForDropDown(response: HttpResponseBase): Observable<AllVehicleBrandForDropDownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AllVehicleBrandForDropDownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVehiclesClient {
    getVehicleById(id: number): Observable<VehicleByIdDto>;
    getVehiclesByKindId(kindId: number): Observable<VehicleByKindIdDto[]>;
    getVehicleByVinNumber(vinNumber: string): Observable<VehicleByVinNumberDto>;
    getVehiclesByCustomerId(): Observable<VehicleByCustomerIdDto[]>;
    create(command: CreateVehicleCommand): Observable<number>;
    update(id: number, command: UpdateVehicleCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class VehiclesClient implements IVehiclesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getVehicleById(id: number): Observable<VehicleByIdDto> {
        let url_ = this.baseUrl + "/api/Vehicles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleByIdDto>;
        }));
    }

    protected processGetVehicleById(response: HttpResponseBase): Observable<VehicleByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehiclesByKindId(kindId: number): Observable<VehicleByKindIdDto[]> {
        let url_ = this.baseUrl + "/api/Vehicles/kind{kindId}";
        if (kindId === undefined || kindId === null)
            throw new Error("The parameter 'kindId' must be defined.");
        url_ = url_.replace("{kindId}", encodeURIComponent("" + kindId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehiclesByKindId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehiclesByKindId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleByKindIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleByKindIdDto[]>;
        }));
    }

    protected processGetVehiclesByKindId(response: HttpResponseBase): Observable<VehicleByKindIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleByKindIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehicleByVinNumber(vinNumber: string): Observable<VehicleByVinNumberDto> {
        let url_ = this.baseUrl + "/api/Vehicles/vin{vinNumber}";
        if (vinNumber === undefined || vinNumber === null)
            throw new Error("The parameter 'vinNumber' must be defined.");
        url_ = url_.replace("{vinNumber}", encodeURIComponent("" + vinNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleByVinNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleByVinNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleByVinNumberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleByVinNumberDto>;
        }));
    }

    protected processGetVehicleByVinNumber(response: HttpResponseBase): Observable<VehicleByVinNumberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleByVinNumberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehiclesByCustomerId(): Observable<VehicleByCustomerIdDto[]> {
        let url_ = this.baseUrl + "/api/Vehicles/selfCustomer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehiclesByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehiclesByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleByCustomerIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleByCustomerIdDto[]>;
        }));
    }

    protected processGetVehiclesByCustomerId(response: HttpResponseBase): Observable<VehicleByCustomerIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleByCustomerIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateVehicleCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Vehicles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateVehicleCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Vehicles/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Vehicles/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICommentsClient {
    getCommentsByParentCommentId(parentCommentId: number): Observable<CommentDto[]>;
    getCommentsByPostId(postId: number): Observable<CommentDto[]>;
    getCommentById(id: number): Observable<CommentDto>;
    selfGetCommentsByCustomerId(): Observable<CommentDto[]>;
    create(command: CreateCommentCommand): Observable<number>;
    selfUpdate(id: number, command: UpdateCommentCommand): Observable<FileResponse>;
    selfDelete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CommentsClient implements ICommentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCommentsByParentCommentId(parentCommentId: number): Observable<CommentDto[]> {
        let url_ = this.baseUrl + "/api/Comments/parentComment{parentCommentId}";
        if (parentCommentId === undefined || parentCommentId === null)
            throw new Error("The parameter 'parentCommentId' must be defined.");
        url_ = url_.replace("{parentCommentId}", encodeURIComponent("" + parentCommentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommentsByParentCommentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommentsByParentCommentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto[]>;
        }));
    }

    protected processGetCommentsByParentCommentId(response: HttpResponseBase): Observable<CommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCommentsByPostId(postId: number): Observable<CommentDto[]> {
        let url_ = this.baseUrl + "/api/Comments/post{postId}";
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommentsByPostId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommentsByPostId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto[]>;
        }));
    }

    protected processGetCommentsByPostId(response: HttpResponseBase): Observable<CommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCommentById(id: number): Observable<CommentDto> {
        let url_ = this.baseUrl + "/api/Comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommentById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto>;
        }));
    }

    protected processGetCommentById(response: HttpResponseBase): Observable<CommentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfGetCommentsByCustomerId(): Observable<CommentDto[]> {
        let url_ = this.baseUrl + "/api/Comments/selfCustomer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfGetCommentsByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfGetCommentsByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto[]>;
        }));
    }

    protected processSelfGetCommentsByCustomerId(response: HttpResponseBase): Observable<CommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCommentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Comments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfUpdate(id: number, command: UpdateCommentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Comments/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSelfUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfDelete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Comments/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSelfDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPostsClient {
    getPostsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfPostDto>;
    getAllPosts(): Observable<PostDto[]>;
    getPostsByBlogSubCategoryId(blogSubCategoryId: number): Observable<PostDto[]>;
    getPostsByUserId(userId: string): Observable<PostDto[]>;
    getPostById(id: number): Observable<PostDto>;
}

@Injectable({
    providedIn: 'root'
})
export class PostsClient implements IPostsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getPostsWithPagination(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfPostDto> {
        let url_ = this.baseUrl + "/api/Posts?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfPostDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfPostDto>;
        }));
    }

    protected processGetPostsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfPostDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfPostDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllPosts(): Observable<PostDto[]> {
        let url_ = this.baseUrl + "/api/Posts/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostDto[]>;
        }));
    }

    protected processGetAllPosts(response: HttpResponseBase): Observable<PostDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPostsByBlogSubCategoryId(blogSubCategoryId: number): Observable<PostDto[]> {
        let url_ = this.baseUrl + "/api/Posts/blogSubCategory{blogSubCategoryId}";
        if (blogSubCategoryId === undefined || blogSubCategoryId === null)
            throw new Error("The parameter 'blogSubCategoryId' must be defined.");
        url_ = url_.replace("{blogSubCategoryId}", encodeURIComponent("" + blogSubCategoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostsByBlogSubCategoryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostsByBlogSubCategoryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostDto[]>;
        }));
    }

    protected processGetPostsByBlogSubCategoryId(response: HttpResponseBase): Observable<PostDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPostsByUserId(userId: string): Observable<PostDto[]> {
        let url_ = this.baseUrl + "/api/Posts/user{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostsByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostsByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostDto[]>;
        }));
    }

    protected processGetPostsByUserId(response: HttpResponseBase): Observable<PostDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPostById(id: number): Observable<PostDto> {
        let url_ = this.baseUrl + "/api/Posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostDto>;
        }));
    }

    protected processGetPostById(response: HttpResponseBase): Observable<PostDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWidgetCommentsClient {
    getWidgetCommentById(id: number): Observable<WidgetCommentDto>;
    create(command: CreateCommentCommand): Observable<number>;
    selfGetWidgetCommentsByCustomerId(): Observable<WidgetCommentDto[]>;
    selfUpdate(id: number, command: UpdateWidgetCommentCommand): Observable<FileResponse>;
    selfDelete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class WidgetCommentsClient implements IWidgetCommentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getWidgetCommentById(id: number): Observable<WidgetCommentDto> {
        let url_ = this.baseUrl + "/api/WidgetComments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWidgetCommentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidgetCommentById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetCommentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetCommentDto>;
        }));
    }

    protected processGetWidgetCommentById(response: HttpResponseBase): Observable<WidgetCommentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WidgetCommentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCommentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/WidgetComments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfGetWidgetCommentsByCustomerId(): Observable<WidgetCommentDto[]> {
        let url_ = this.baseUrl + "/api/WidgetComments/selfCustomer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfGetWidgetCommentsByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfGetWidgetCommentsByCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetCommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetCommentDto[]>;
        }));
    }

    protected processSelfGetWidgetCommentsByCustomerId(response: HttpResponseBase): Observable<WidgetCommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetCommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfUpdate(id: number, command: UpdateWidgetCommentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WidgetComments/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSelfUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selfDelete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WidgetComments/self{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelfDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelfDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSelfDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AddressDto implements IAddressDto {
    id?: number;
    title?: string;
    company?: string | undefined;
    countryName?: string;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    customerId?: string;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.company = _data["company"];
            this.countryName = _data["countryName"];
            this.countryId = _data["countryId"];
            this.addressDetails1 = _data["addressDetails1"];
            this.addressDetails2 = _data["addressDetails2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postcode = _data["postcode"];
            this.default = _data["default"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["company"] = this.company;
        data["countryName"] = this.countryName;
        data["countryId"] = this.countryId;
        data["addressDetails1"] = this.addressDetails1;
        data["addressDetails2"] = this.addressDetails2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postcode"] = this.postcode;
        data["default"] = this.default;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IAddressDto {
    id?: number;
    title?: string;
    company?: string | undefined;
    countryName?: string;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    customerId?: string;
}

export class CreateAddressCommand implements ICreateAddressCommand {
    title?: string;
    company?: string | undefined;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    customerId?: string;

    constructor(data?: ICreateAddressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.company = _data["company"];
            this.countryId = _data["countryId"];
            this.addressDetails1 = _data["addressDetails1"];
            this.addressDetails2 = _data["addressDetails2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postcode = _data["postcode"];
            this.default = _data["default"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): CreateAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["company"] = this.company;
        data["countryId"] = this.countryId;
        data["addressDetails1"] = this.addressDetails1;
        data["addressDetails2"] = this.addressDetails2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postcode"] = this.postcode;
        data["default"] = this.default;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface ICreateAddressCommand {
    title?: string;
    company?: string | undefined;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    customerId?: string;
}

export class UpdateAddressCommand implements IUpdateAddressCommand {
    id?: number;
    title?: string;
    company?: string | undefined;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    customerId?: string;

    constructor(data?: IUpdateAddressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.company = _data["company"];
            this.countryId = _data["countryId"];
            this.addressDetails1 = _data["addressDetails1"];
            this.addressDetails2 = _data["addressDetails2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postcode = _data["postcode"];
            this.default = _data["default"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): UpdateAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["company"] = this.company;
        data["countryId"] = this.countryId;
        data["addressDetails1"] = this.addressDetails1;
        data["addressDetails2"] = this.addressDetails2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postcode"] = this.postcode;
        data["default"] = this.default;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IUpdateAddressCommand {
    id?: number;
    title?: string;
    company?: string | undefined;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
    customerId?: string;
}

export class PaginatedListOfCreditDto implements IPaginatedListOfCreditDto {
    items?: CreditDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCreditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CreditDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCreditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCreditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCreditDto {
    items?: CreditDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CreditDto implements ICreditDto {
    id?: number;
    date?: Date;
    value?: number;
    modifierUserName?: string;
    orderToken?: string | undefined;

    constructor(data?: ICreditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.modifierUserName = _data["modifierUserName"];
            this.orderToken = _data["orderToken"];
        }
    }

    static fromJS(data: any): CreditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["modifierUserName"] = this.modifierUserName;
        data["orderToken"] = this.orderToken;
        return data;
    }
}

export interface ICreditDto {
    id?: number;
    date?: Date;
    value?: number;
    modifierUserName?: string;
    orderToken?: string | undefined;
}

export class CustomerDto implements ICustomerDto {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
    credits?: CreditDto[];
    maxCredits?: MaxCreditDto[];
    addresses?: AddressForCustomerDto[];
    vehicles?: VehicleForCustomerDto[];

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
            if (Array.isArray(_data["credits"])) {
                this.credits = [] as any;
                for (let item of _data["credits"])
                    this.credits!.push(CreditDto.fromJS(item));
            }
            if (Array.isArray(_data["maxCredits"])) {
                this.maxCredits = [] as any;
                for (let item of _data["maxCredits"])
                    this.maxCredits!.push(MaxCreditDto.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(AddressForCustomerDto.fromJS(item));
            }
            if (Array.isArray(_data["vehicles"])) {
                this.vehicles = [] as any;
                for (let item of _data["vehicles"])
                    this.vehicles!.push(VehicleForCustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        if (Array.isArray(this.credits)) {
            data["credits"] = [];
            for (let item of this.credits)
                data["credits"].push(item.toJSON());
        }
        if (Array.isArray(this.maxCredits)) {
            data["maxCredits"] = [];
            for (let item of this.maxCredits)
                data["maxCredits"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.vehicles)) {
            data["vehicles"] = [];
            for (let item of this.vehicles)
                data["vehicles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomerDto {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
    credits?: CreditDto[];
    maxCredits?: MaxCreditDto[];
    addresses?: AddressForCustomerDto[];
    vehicles?: VehicleForCustomerDto[];
}

export class MaxCreditDto implements IMaxCreditDto {
    id?: number;
    date?: Date;
    value?: number;
    modifierUserName?: string;

    constructor(data?: IMaxCreditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.modifierUserName = _data["modifierUserName"];
        }
    }

    static fromJS(data: any): MaxCreditDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaxCreditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["modifierUserName"] = this.modifierUserName;
        return data;
    }
}

export interface IMaxCreditDto {
    id?: number;
    date?: Date;
    value?: number;
    modifierUserName?: string;
}

export class AddressForCustomerDto implements IAddressForCustomerDto {
    id?: number;
    title?: string;
    company?: string | undefined;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;

    constructor(data?: IAddressForCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.company = _data["company"];
            this.addressDetails1 = _data["addressDetails1"];
            this.addressDetails2 = _data["addressDetails2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postcode = _data["postcode"];
            this.default = _data["default"];
        }
    }

    static fromJS(data: any): AddressForCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressForCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["company"] = this.company;
        data["addressDetails1"] = this.addressDetails1;
        data["addressDetails2"] = this.addressDetails2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postcode"] = this.postcode;
        data["default"] = this.default;
        return data;
    }
}

export interface IAddressForCustomerDto {
    id?: number;
    title?: string;
    company?: string | undefined;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
    default?: boolean;
}

export class VehicleForCustomerDto implements IVehicleForCustomerDto {
    id?: number;
    vinNumber?: string;
    kind?: KindForVehicleDto;

    constructor(data?: IVehicleForCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.kind = _data["kind"] ? KindForVehicleDto.fromJS(_data["kind"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VehicleForCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleForCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["kind"] = this.kind ? this.kind.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVehicleForCustomerDto {
    id?: number;
    vinNumber?: string;
    kind?: KindForVehicleDto;
}

export class KindForVehicleDto implements IKindForVehicleDto {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;

    constructor(data?: IKindForVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.brandLocalizedName = _data["brandLocalizedName"];
            this.familyName = _data["familyName"];
            this.familyLocalizedName = _data["familyLocalizedName"];
            this.modelName = _data["modelName"];
            this.modelLocalizedName = _data["modelLocalizedName"];
        }
    }

    static fromJS(data: any): KindForVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new KindForVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["brandLocalizedName"] = this.brandLocalizedName;
        data["familyName"] = this.familyName;
        data["familyLocalizedName"] = this.familyLocalizedName;
        data["modelName"] = this.modelName;
        data["modelLocalizedName"] = this.modelLocalizedName;
        return data;
    }
}

export interface IKindForVehicleDto {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;
}

export class CreateCustomerCommand implements ICreateCustomerCommand {
    id?: string;
    avatar?: string | undefined;

    constructor(data?: ICreateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CreateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICreateCustomerCommand {
    id?: string;
    avatar?: string | undefined;
}

export class UpdateCustomerCommand implements IUpdateCustomerCommand {
    id?: string;
    avatar?: string | undefined;

    constructor(data?: IUpdateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): UpdateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface IUpdateCustomerCommand {
    id?: string;
    avatar?: string | undefined;
}

export class AddVehicleToCustomerCommand implements IAddVehicleToCustomerCommand {
    customerId?: string;
    vehicleId?: number;
    kindId?: number;

    constructor(data?: IAddVehicleToCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.vehicleId = _data["vehicleId"];
            this.kindId = _data["kindId"];
        }
    }

    static fromJS(data: any): AddVehicleToCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddVehicleToCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["vehicleId"] = this.vehicleId;
        data["kindId"] = this.kindId;
        return data;
    }
}

export interface IAddVehicleToCustomerCommand {
    customerId?: string;
    vehicleId?: number;
    kindId?: number;
}

export class CustomerTypeDto implements ICustomerTypeDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    customerTypeEnumName?: string;
    discountPercent?: number;

    constructor(data?: ICustomerTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.customerTypeEnumName = _data["customerTypeEnumName"];
            this.discountPercent = _data["discountPercent"];
        }
    }

    static fromJS(data: any): CustomerTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["customerTypeEnumName"] = this.customerTypeEnumName;
        data["discountPercent"] = this.discountPercent;
        return data;
    }
}

export interface ICustomerTypeDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    customerTypeEnumName?: string;
    discountPercent?: number;
}

/** نوع مشتری */
export enum CustomerTypeEnum {
    Personal = 1,
    Store = 2,
    Agency = 3,
    CentralRepairShop = 4,
}

export class SearchSuggestionDto implements ISearchSuggestionDto {
    products?: PaginatedListOfProductForSearchSuggestionDto;
    productCategories?: PaginatedListOfProductCategoryForSearchSuggestionDto;

    constructor(data?: ISearchSuggestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.products = _data["products"] ? PaginatedListOfProductForSearchSuggestionDto.fromJS(_data["products"]) : <any>undefined;
            this.productCategories = _data["productCategories"] ? PaginatedListOfProductCategoryForSearchSuggestionDto.fromJS(_data["productCategories"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchSuggestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchSuggestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["products"] = this.products ? this.products.toJSON() : <any>undefined;
        data["productCategories"] = this.productCategories ? this.productCategories.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISearchSuggestionDto {
    products?: PaginatedListOfProductForSearchSuggestionDto;
    productCategories?: PaginatedListOfProductCategoryForSearchSuggestionDto;
}

export class PaginatedListOfProductForSearchSuggestionDto implements IPaginatedListOfProductForSearchSuggestionDto {
    items?: ProductForSearchSuggestionDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductForSearchSuggestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductForSearchSuggestionDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductForSearchSuggestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductForSearchSuggestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductForSearchSuggestionDto {
    items?: ProductForSearchSuggestionDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductForSearchSuggestionDto implements IProductForSearchSuggestionDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string;
    images?: ProductImageForSearchSuggestionDto[];
    reviewsLength?: number;
    kindIds?: number[];
    compatibility?: CompatibilityEnum;
    rating?: number;
    attributeOptions?: ProductAttributeOptionForSearchSuggestionDto[];
    selectedProductAttributeOption?: ProductAttributeOptionForSearchSuggestionDto | undefined;

    constructor(data?: IProductForSearchSuggestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ProductImageForSearchSuggestionDto.fromJS(item));
            }
            this.reviewsLength = _data["reviewsLength"];
            if (Array.isArray(_data["kindIds"])) {
                this.kindIds = [] as any;
                for (let item of _data["kindIds"])
                    this.kindIds!.push(item);
            }
            this.compatibility = _data["compatibility"];
            this.rating = _data["rating"];
            if (Array.isArray(_data["attributeOptions"])) {
                this.attributeOptions = [] as any;
                for (let item of _data["attributeOptions"])
                    this.attributeOptions!.push(ProductAttributeOptionForSearchSuggestionDto.fromJS(item));
            }
            this.selectedProductAttributeOption = _data["selectedProductAttributeOption"] ? ProductAttributeOptionForSearchSuggestionDto.fromJS(_data["selectedProductAttributeOption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductForSearchSuggestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductForSearchSuggestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["reviewsLength"] = this.reviewsLength;
        if (Array.isArray(this.kindIds)) {
            data["kindIds"] = [];
            for (let item of this.kindIds)
                data["kindIds"].push(item);
        }
        data["compatibility"] = this.compatibility;
        data["rating"] = this.rating;
        if (Array.isArray(this.attributeOptions)) {
            data["attributeOptions"] = [];
            for (let item of this.attributeOptions)
                data["attributeOptions"].push(item.toJSON());
        }
        data["selectedProductAttributeOption"] = this.selectedProductAttributeOption ? this.selectedProductAttributeOption.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductForSearchSuggestionDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string;
    images?: ProductImageForSearchSuggestionDto[];
    reviewsLength?: number;
    kindIds?: number[];
    compatibility?: CompatibilityEnum;
    rating?: number;
    attributeOptions?: ProductAttributeOptionForSearchSuggestionDto[];
    selectedProductAttributeOption?: ProductAttributeOptionForSearchSuggestionDto | undefined;
}

export class ProductImageForSearchSuggestionDto implements IProductImageForSearchSuggestionDto {
    id?: number;
    image?: string;
    order?: number;

    constructor(data?: IProductImageForSearchSuggestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): ProductImageForSearchSuggestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageForSearchSuggestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["order"] = this.order;
        return data;
    }
}

export interface IProductImageForSearchSuggestionDto {
    id?: number;
    image?: string;
    order?: number;
}

export enum CompatibilityEnum {
    All = 0,
    Unknown = 1,
    Compatible = 2,
}

export class ProductAttributeOptionForSearchSuggestionDto implements IProductAttributeOptionForSearchSuggestionDto {
    id?: number;
    optionValues?: ProductAttributeOptionValueForSearchSuggestionDto[];
    productId?: number;
    productAttributeOptionRoles?: ProductAttributeOptionRoleForSearchSuggestionDto[];
    isDefault?: boolean;
    prices?: PriceDto[];
    badges?: BadgeDto[];

    constructor(data?: IProductAttributeOptionForSearchSuggestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["optionValues"])) {
                this.optionValues = [] as any;
                for (let item of _data["optionValues"])
                    this.optionValues!.push(ProductAttributeOptionValueForSearchSuggestionDto.fromJS(item));
            }
            this.productId = _data["productId"];
            if (Array.isArray(_data["productAttributeOptionRoles"])) {
                this.productAttributeOptionRoles = [] as any;
                for (let item of _data["productAttributeOptionRoles"])
                    this.productAttributeOptionRoles!.push(ProductAttributeOptionRoleForSearchSuggestionDto.fromJS(item));
            }
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(PriceDto.fromJS(item));
            }
            if (Array.isArray(_data["badges"])) {
                this.badges = [] as any;
                for (let item of _data["badges"])
                    this.badges!.push(BadgeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttributeOptionForSearchSuggestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionForSearchSuggestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.optionValues)) {
            data["optionValues"] = [];
            for (let item of this.optionValues)
                data["optionValues"].push(item.toJSON());
        }
        data["productId"] = this.productId;
        if (Array.isArray(this.productAttributeOptionRoles)) {
            data["productAttributeOptionRoles"] = [];
            for (let item of this.productAttributeOptionRoles)
                data["productAttributeOptionRoles"].push(item.toJSON());
        }
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        if (Array.isArray(this.badges)) {
            data["badges"] = [];
            for (let item of this.badges)
                data["badges"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAttributeOptionForSearchSuggestionDto {
    id?: number;
    optionValues?: ProductAttributeOptionValueForSearchSuggestionDto[];
    productId?: number;
    productAttributeOptionRoles?: ProductAttributeOptionRoleForSearchSuggestionDto[];
    isDefault?: boolean;
    prices?: PriceDto[];
    badges?: BadgeDto[];
}

export class ProductAttributeOptionValueForSearchSuggestionDto implements IProductAttributeOptionValueForSearchSuggestionDto {
    id?: number;
    name?: string;
    value?: string;

    constructor(data?: IProductAttributeOptionValueForSearchSuggestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductAttributeOptionValueForSearchSuggestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionValueForSearchSuggestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductAttributeOptionValueForSearchSuggestionDto {
    id?: number;
    name?: string;
    value?: string;
}

export class ProductAttributeOptionRoleForSearchSuggestionDto implements IProductAttributeOptionRoleForSearchSuggestionDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    discountPercent?: number;
    availability?: AvailabilityEnum;
    currentMaxOrderQty?: number;
    currentMinOrderQty?: number;

    constructor(data?: IProductAttributeOptionRoleForSearchSuggestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.discountPercent = _data["discountPercent"];
            this.availability = _data["availability"];
            this.currentMaxOrderQty = _data["currentMaxOrderQty"];
            this.currentMinOrderQty = _data["currentMinOrderQty"];
        }
    }

    static fromJS(data: any): ProductAttributeOptionRoleForSearchSuggestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionRoleForSearchSuggestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["discountPercent"] = this.discountPercent;
        data["availability"] = this.availability;
        data["currentMaxOrderQty"] = this.currentMaxOrderQty;
        data["currentMinOrderQty"] = this.currentMinOrderQty;
        return data;
    }
}

export interface IProductAttributeOptionRoleForSearchSuggestionDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    discountPercent?: number;
    availability?: AvailabilityEnum;
    currentMaxOrderQty?: number;
    currentMinOrderQty?: number;
}

export enum AvailabilityEnum {
    InStock = 0,
    OutOfStock = 1,
}

export class PriceDto implements IPriceDto {
    id?: number;
    date?: Date;
    mainPrice?: number;

    constructor(data?: IPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.mainPrice = _data["mainPrice"];
        }
    }

    static fromJS(data: any): PriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["mainPrice"] = this.mainPrice;
        return data;
    }
}

export interface IPriceDto {
    id?: number;
    date?: Date;
    mainPrice?: number;
}

export class BadgeDto implements IBadgeDto {
    id?: number;
    value?: string;
    isActive?: boolean;

    constructor(data?: IBadgeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): BadgeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BadgeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IBadgeDto {
    id?: number;
    value?: string;
    isActive?: boolean;
}

export class PaginatedListOfProductCategoryForSearchSuggestionDto implements IPaginatedListOfProductCategoryForSearchSuggestionDto {
    items?: ProductCategoryForSearchSuggestionDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductCategoryForSearchSuggestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductCategoryForSearchSuggestionDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductCategoryForSearchSuggestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductCategoryForSearchSuggestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductCategoryForSearchSuggestionDto {
    items?: ProductCategoryForSearchSuggestionDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductCategoryForSearchSuggestionDto implements IProductCategoryForSearchSuggestionDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;

    constructor(data?: IProductCategoryForSearchSuggestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): ProductCategoryForSearchSuggestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryForSearchSuggestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IProductCategoryForSearchSuggestionDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
}

export class FilterViewModel implements IFilterViewModel {
    products?: ProductForFilterResultDto[];
    productsCount?: number;

    constructor(data?: IFilterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductForFilterResultDto.fromJS(item));
            }
            this.productsCount = _data["productsCount"];
        }
    }

    static fromJS(data: any): FilterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["productsCount"] = this.productsCount;
        return data;
    }
}

export interface IFilterViewModel {
    products?: ProductForFilterResultDto[];
    productsCount?: number;
}

export class MainProductDto implements IMainProductDto {
    id?: number;
    related7SoftProductId?: string | undefined;
    localizedName?: string;
    name?: string;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    productNo?: string | undefined;
    images?: MainProductImageDto[];
    reviewsLength?: number;
    kindIds?: number[];
    compatibility?: CompatibilityEnum;
    productBrand?: MainBrandDto;
    tags?: MainTagDto[];
    productAttributeType?: MainProductAttributeTypeDto;
    productCategory?: ProductCategoryDto;
    attributes?: MainProductAttributeDto[];
    colorOption?: MainProductOptionColorDto | undefined;
    materialOption?: MainProductOptionMaterialDto | undefined;
    rating?: number;
    attributeOptions?: MainProductAttributeOptionDto[];
    productCustomFields?: ProductCustomFieldDto[];
    orderRate?: number;
    selectedProductAttributeOption?: MainProductAttributeOptionDto | undefined;
    countryName?: string;

    constructor(data?: IMainProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.related7SoftProductId = _data["related7SoftProductId"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.excerpt = _data["excerpt"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.productNo = _data["productNo"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(MainProductImageDto.fromJS(item));
            }
            this.reviewsLength = _data["reviewsLength"];
            if (Array.isArray(_data["kindIds"])) {
                this.kindIds = [] as any;
                for (let item of _data["kindIds"])
                    this.kindIds!.push(item);
            }
            this.compatibility = _data["compatibility"];
            this.productBrand = _data["productBrand"] ? MainBrandDto.fromJS(_data["productBrand"]) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(MainTagDto.fromJS(item));
            }
            this.productAttributeType = _data["productAttributeType"] ? MainProductAttributeTypeDto.fromJS(_data["productAttributeType"]) : <any>undefined;
            this.productCategory = _data["productCategory"] ? ProductCategoryDto.fromJS(_data["productCategory"]) : <any>undefined;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(MainProductAttributeDto.fromJS(item));
            }
            this.colorOption = _data["colorOption"] ? MainProductOptionColorDto.fromJS(_data["colorOption"]) : <any>undefined;
            this.materialOption = _data["materialOption"] ? MainProductOptionMaterialDto.fromJS(_data["materialOption"]) : <any>undefined;
            this.rating = _data["rating"];
            if (Array.isArray(_data["attributeOptions"])) {
                this.attributeOptions = [] as any;
                for (let item of _data["attributeOptions"])
                    this.attributeOptions!.push(MainProductAttributeOptionDto.fromJS(item));
            }
            if (Array.isArray(_data["productCustomFields"])) {
                this.productCustomFields = [] as any;
                for (let item of _data["productCustomFields"])
                    this.productCustomFields!.push(ProductCustomFieldDto.fromJS(item));
            }
            this.orderRate = _data["orderRate"];
            this.selectedProductAttributeOption = _data["selectedProductAttributeOption"] ? MainProductAttributeOptionDto.fromJS(_data["selectedProductAttributeOption"]) : <any>undefined;
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): MainProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["related7SoftProductId"] = this.related7SoftProductId;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["excerpt"] = this.excerpt;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["productNo"] = this.productNo;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["reviewsLength"] = this.reviewsLength;
        if (Array.isArray(this.kindIds)) {
            data["kindIds"] = [];
            for (let item of this.kindIds)
                data["kindIds"].push(item);
        }
        data["compatibility"] = this.compatibility;
        data["productBrand"] = this.productBrand ? this.productBrand.toJSON() : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["productAttributeType"] = this.productAttributeType ? this.productAttributeType.toJSON() : <any>undefined;
        data["productCategory"] = this.productCategory ? this.productCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        data["colorOption"] = this.colorOption ? this.colorOption.toJSON() : <any>undefined;
        data["materialOption"] = this.materialOption ? this.materialOption.toJSON() : <any>undefined;
        data["rating"] = this.rating;
        if (Array.isArray(this.attributeOptions)) {
            data["attributeOptions"] = [];
            for (let item of this.attributeOptions)
                data["attributeOptions"].push(item.toJSON());
        }
        if (Array.isArray(this.productCustomFields)) {
            data["productCustomFields"] = [];
            for (let item of this.productCustomFields)
                data["productCustomFields"].push(item.toJSON());
        }
        data["orderRate"] = this.orderRate;
        data["selectedProductAttributeOption"] = this.selectedProductAttributeOption ? this.selectedProductAttributeOption.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IMainProductDto {
    id?: number;
    related7SoftProductId?: string | undefined;
    localizedName?: string;
    name?: string;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    productNo?: string | undefined;
    images?: MainProductImageDto[];
    reviewsLength?: number;
    kindIds?: number[];
    compatibility?: CompatibilityEnum;
    productBrand?: MainBrandDto;
    tags?: MainTagDto[];
    productAttributeType?: MainProductAttributeTypeDto;
    productCategory?: ProductCategoryDto;
    attributes?: MainProductAttributeDto[];
    colorOption?: MainProductOptionColorDto | undefined;
    materialOption?: MainProductOptionMaterialDto | undefined;
    rating?: number;
    attributeOptions?: MainProductAttributeOptionDto[];
    productCustomFields?: ProductCustomFieldDto[];
    orderRate?: number;
    selectedProductAttributeOption?: MainProductAttributeOptionDto | undefined;
    countryName?: string;
}

export class ProductForFilterResultDto extends MainProductDto implements IProductForFilterResultDto {

    constructor(data?: IProductForFilterResultDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ProductForFilterResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductForFilterResultDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductForFilterResultDto extends IMainProductDto {
}

export class MainProductImageDto implements IMainProductImageDto {
    id?: number;
    image?: string;
    order?: number;
    isActive?: boolean;

    constructor(data?: IMainProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): MainProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IMainProductImageDto {
    id?: number;
    image?: string;
    order?: number;
    isActive?: boolean;
}

export class MainBrandDto implements IMainBrandDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    countryName?: string | undefined;

    constructor(data?: IMainBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): MainBrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainBrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IMainBrandDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    countryName?: string | undefined;
}

export class MainTagDto implements IMainTagDto {
    id?: number;
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;

    constructor(data?: IMainTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.enTitle = _data["enTitle"];
            this.faTitle = _data["faTitle"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): MainTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["enTitle"] = this.enTitle;
        data["faTitle"] = this.faTitle;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IMainTagDto {
    id?: number;
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;
}

export class MainProductAttributeTypeDto implements IMainProductAttributeTypeDto {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: MainProductTypeAttributeGroupDto[];

    constructor(data?: IMainProductAttributeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["attributeGroups"])) {
                this.attributeGroups = [] as any;
                for (let item of _data["attributeGroups"])
                    this.attributeGroups!.push(MainProductTypeAttributeGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MainProductAttributeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductAttributeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.attributeGroups)) {
            data["attributeGroups"] = [];
            for (let item of this.attributeGroups)
                data["attributeGroups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMainProductAttributeTypeDto {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: MainProductTypeAttributeGroupDto[];
}

export class MainProductTypeAttributeGroupDto implements IMainProductTypeAttributeGroupDto {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto[];
    attributes?: MainProductTypeAttributeGroupAttributeDto[];

    constructor(data?: IMainProductTypeAttributeGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["productTypeAttributeGroupCustomFields"])) {
                this.productTypeAttributeGroupCustomFields = [] as any;
                for (let item of _data["productTypeAttributeGroupCustomFields"])
                    this.productTypeAttributeGroupCustomFields!.push(ProductTypeAttributeGroupCustomFieldDto.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(MainProductTypeAttributeGroupAttributeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MainProductTypeAttributeGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductTypeAttributeGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.productTypeAttributeGroupCustomFields)) {
            data["productTypeAttributeGroupCustomFields"] = [];
            for (let item of this.productTypeAttributeGroupCustomFields)
                data["productTypeAttributeGroupCustomFields"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMainProductTypeAttributeGroupDto {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto[];
    attributes?: MainProductTypeAttributeGroupAttributeDto[];
}

export class ProductTypeAttributeGroupCustomFieldDto implements IProductTypeAttributeGroupCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;

    constructor(data?: IProductTypeAttributeGroupCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductTypeAttributeGroupCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;
}

export class MainProductTypeAttributeGroupAttributeDto implements IMainProductTypeAttributeGroupAttributeDto {
    id?: number;
    value?: string;

    constructor(data?: IMainProductTypeAttributeGroupAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): MainProductTypeAttributeGroupAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductTypeAttributeGroupAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface IMainProductTypeAttributeGroupAttributeDto {
    id?: number;
    value?: string;
}

export class ProductCategoryDto implements IProductCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;

    constructor(data?: IProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): ProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IProductCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
}

export class MainProductAttributeDto implements IMainProductAttributeDto {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    valueName?: string;
    valueSlug?: string;

    constructor(data?: IMainProductAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.featured = _data["featured"];
            this.valueName = _data["valueName"];
            this.valueSlug = _data["valueSlug"];
        }
    }

    static fromJS(data: any): MainProductAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["featured"] = this.featured;
        data["valueName"] = this.valueName;
        data["valueSlug"] = this.valueSlug;
        return data;
    }
}

export interface IMainProductAttributeDto {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    valueName?: string;
    valueSlug?: string;
}

export class MainProductOptionColorDto implements IMainProductOptionColorDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: MainProductOptionValueColorDto[];
    productOptionColorCustomFields?: ProductOptionColorCustomFieldDto[];

    constructor(data?: IMainProductOptionColorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(MainProductOptionValueColorDto.fromJS(item));
            }
            if (Array.isArray(_data["productOptionColorCustomFields"])) {
                this.productOptionColorCustomFields = [] as any;
                for (let item of _data["productOptionColorCustomFields"])
                    this.productOptionColorCustomFields!.push(ProductOptionColorCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MainProductOptionColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductOptionColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.productOptionColorCustomFields)) {
            data["productOptionColorCustomFields"] = [];
            for (let item of this.productOptionColorCustomFields)
                data["productOptionColorCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMainProductOptionColorDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: MainProductOptionValueColorDto[];
    productOptionColorCustomFields?: ProductOptionColorCustomFieldDto[];
}

export enum ProductOptionTypeEnum {
    Color = 1,
    Material = 2,
    Provider = 3,
}

export class MainProductOptionValueColorDto implements IMainProductOptionValueColorDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;

    constructor(data?: IMainProductOptionValueColorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): MainProductOptionValueColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductOptionValueColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["color"] = this.color;
        return data;
    }
}

export interface IMainProductOptionValueColorDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;
}

export class ProductOptionColorCustomFieldDto implements IProductOptionColorCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;

    constructor(data?: IProductOptionColorCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductOptionColorCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionColorCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductOptionColorCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;
}

export class MainProductOptionMaterialDto implements IMainProductOptionMaterialDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: MainProductOptionValueMaterialDto[];
    productOptionMaterialCustomFields?: ProductOptionMaterialCustomFieldDto[];

    constructor(data?: IMainProductOptionMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(MainProductOptionValueMaterialDto.fromJS(item));
            }
            if (Array.isArray(_data["productOptionMaterialCustomFields"])) {
                this.productOptionMaterialCustomFields = [] as any;
                for (let item of _data["productOptionMaterialCustomFields"])
                    this.productOptionMaterialCustomFields!.push(ProductOptionMaterialCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MainProductOptionMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductOptionMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.productOptionMaterialCustomFields)) {
            data["productOptionMaterialCustomFields"] = [];
            for (let item of this.productOptionMaterialCustomFields)
                data["productOptionMaterialCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMainProductOptionMaterialDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: MainProductOptionValueMaterialDto[];
    productOptionMaterialCustomFields?: ProductOptionMaterialCustomFieldDto[];
}

export class MainProductOptionValueMaterialDto implements IMainProductOptionValueMaterialDto {
    id?: number;
    name?: string;
    slug?: string;

    constructor(data?: IMainProductOptionValueMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): MainProductOptionValueMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductOptionValueMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IMainProductOptionValueMaterialDto {
    id?: number;
    name?: string;
    slug?: string;
}

export class ProductOptionMaterialCustomFieldDto implements IProductOptionMaterialCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;

    constructor(data?: IProductOptionMaterialCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductOptionMaterialCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionMaterialCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductOptionMaterialCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;
}

export class MainProductAttributeOptionDto implements IMainProductAttributeOptionDto {
    id?: number;
    optionValues?: MainProductAttributeOptionValueDto[];
    productId?: number;
    productAttributeOptionRoles?: MainProductAttributeOptionRoleDto[];
    isDefault?: boolean;
    prices?: PriceDto[];
    badges?: BadgeDto[];

    constructor(data?: IMainProductAttributeOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["optionValues"])) {
                this.optionValues = [] as any;
                for (let item of _data["optionValues"])
                    this.optionValues!.push(MainProductAttributeOptionValueDto.fromJS(item));
            }
            this.productId = _data["productId"];
            if (Array.isArray(_data["productAttributeOptionRoles"])) {
                this.productAttributeOptionRoles = [] as any;
                for (let item of _data["productAttributeOptionRoles"])
                    this.productAttributeOptionRoles!.push(MainProductAttributeOptionRoleDto.fromJS(item));
            }
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(PriceDto.fromJS(item));
            }
            if (Array.isArray(_data["badges"])) {
                this.badges = [] as any;
                for (let item of _data["badges"])
                    this.badges!.push(BadgeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MainProductAttributeOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductAttributeOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.optionValues)) {
            data["optionValues"] = [];
            for (let item of this.optionValues)
                data["optionValues"].push(item.toJSON());
        }
        data["productId"] = this.productId;
        if (Array.isArray(this.productAttributeOptionRoles)) {
            data["productAttributeOptionRoles"] = [];
            for (let item of this.productAttributeOptionRoles)
                data["productAttributeOptionRoles"].push(item.toJSON());
        }
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        if (Array.isArray(this.badges)) {
            data["badges"] = [];
            for (let item of this.badges)
                data["badges"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMainProductAttributeOptionDto {
    id?: number;
    optionValues?: MainProductAttributeOptionValueDto[];
    productId?: number;
    productAttributeOptionRoles?: MainProductAttributeOptionRoleDto[];
    isDefault?: boolean;
    prices?: PriceDto[];
    badges?: BadgeDto[];
}

export class MainProductAttributeOptionValueDto implements IMainProductAttributeOptionValueDto {
    id?: number;
    name?: string;
    value?: string;

    constructor(data?: IMainProductAttributeOptionValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): MainProductAttributeOptionValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductAttributeOptionValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IMainProductAttributeOptionValueDto {
    id?: number;
    name?: string;
    value?: string;
}

export class MainProductAttributeOptionRoleDto implements IMainProductAttributeOptionRoleDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    discountPercent?: number;
    availability?: AvailabilityEnum;
    currentMaxOrderQty?: number;
    currentMinOrderQty?: number;

    constructor(data?: IMainProductAttributeOptionRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.discountPercent = _data["discountPercent"];
            this.availability = _data["availability"];
            this.currentMaxOrderQty = _data["currentMaxOrderQty"];
            this.currentMinOrderQty = _data["currentMinOrderQty"];
        }
    }

    static fromJS(data: any): MainProductAttributeOptionRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductAttributeOptionRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["discountPercent"] = this.discountPercent;
        data["availability"] = this.availability;
        data["currentMaxOrderQty"] = this.currentMaxOrderQty;
        data["currentMinOrderQty"] = this.currentMinOrderQty;
        return data;
    }
}

export interface IMainProductAttributeOptionRoleDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    discountPercent?: number;
    availability?: AvailabilityEnum;
    currentMaxOrderQty?: number;
    currentMinOrderQty?: number;
}

export class ProductCustomFieldDto implements IProductCustomFieldDto {
    fieldName?: string;
    value?: string;

    constructor(data?: IProductCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductCustomFieldDto {
    fieldName?: string;
    value?: string;
}

export class MainReturnOrderDto implements IMainReturnOrderDto {
    id?: number;
    token?: string | undefined;
    number?: string;
    quantity?: number;
    subtotal?: number;
    total?: number;
    createdAt?: Date;
    costRefundType?: CostRefundType;
    costRefundTypeName?: string;
    returnOrderStateHistory?: ReturnOrderStateBaseDto[];
    currentReturnOrderState?: ReturnOrderStateBaseDto;
    returnOrderTransportationType?: ReturnOrderTransportationType;
    returnOrderTransportationTypeName?: string;
    itemGroups?: ReturnOrderItemGroupDto[];
    totals?: ReturnOrderTotalDto[];
    orderNumber?: string;
    customerAccountInfo?: string | undefined;

    constructor(data?: IMainReturnOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.number = _data["number"];
            this.quantity = _data["quantity"];
            this.subtotal = _data["subtotal"];
            this.total = _data["total"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.costRefundType = _data["costRefundType"];
            this.costRefundTypeName = _data["costRefundTypeName"];
            if (Array.isArray(_data["returnOrderStateHistory"])) {
                this.returnOrderStateHistory = [] as any;
                for (let item of _data["returnOrderStateHistory"])
                    this.returnOrderStateHistory!.push(ReturnOrderStateBaseDto.fromJS(item));
            }
            this.currentReturnOrderState = _data["currentReturnOrderState"] ? ReturnOrderStateBaseDto.fromJS(_data["currentReturnOrderState"]) : <any>undefined;
            this.returnOrderTransportationType = _data["returnOrderTransportationType"];
            this.returnOrderTransportationTypeName = _data["returnOrderTransportationTypeName"];
            if (Array.isArray(_data["itemGroups"])) {
                this.itemGroups = [] as any;
                for (let item of _data["itemGroups"])
                    this.itemGroups!.push(ReturnOrderItemGroupDto.fromJS(item));
            }
            if (Array.isArray(_data["totals"])) {
                this.totals = [] as any;
                for (let item of _data["totals"])
                    this.totals!.push(ReturnOrderTotalDto.fromJS(item));
            }
            this.orderNumber = _data["orderNumber"];
            this.customerAccountInfo = _data["customerAccountInfo"];
        }
    }

    static fromJS(data: any): MainReturnOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainReturnOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["number"] = this.number;
        data["quantity"] = this.quantity;
        data["subtotal"] = this.subtotal;
        data["total"] = this.total;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["costRefundType"] = this.costRefundType;
        data["costRefundTypeName"] = this.costRefundTypeName;
        if (Array.isArray(this.returnOrderStateHistory)) {
            data["returnOrderStateHistory"] = [];
            for (let item of this.returnOrderStateHistory)
                data["returnOrderStateHistory"].push(item.toJSON());
        }
        data["currentReturnOrderState"] = this.currentReturnOrderState ? this.currentReturnOrderState.toJSON() : <any>undefined;
        data["returnOrderTransportationType"] = this.returnOrderTransportationType;
        data["returnOrderTransportationTypeName"] = this.returnOrderTransportationTypeName;
        if (Array.isArray(this.itemGroups)) {
            data["itemGroups"] = [];
            for (let item of this.itemGroups)
                data["itemGroups"].push(item.toJSON());
        }
        if (Array.isArray(this.totals)) {
            data["totals"] = [];
            for (let item of this.totals)
                data["totals"].push(item.toJSON());
        }
        data["orderNumber"] = this.orderNumber;
        data["customerAccountInfo"] = this.customerAccountInfo;
        return data;
    }
}

export interface IMainReturnOrderDto {
    id?: number;
    token?: string | undefined;
    number?: string;
    quantity?: number;
    subtotal?: number;
    total?: number;
    createdAt?: Date;
    costRefundType?: CostRefundType;
    costRefundTypeName?: string;
    returnOrderStateHistory?: ReturnOrderStateBaseDto[];
    currentReturnOrderState?: ReturnOrderStateBaseDto;
    returnOrderTransportationType?: ReturnOrderTransportationType;
    returnOrderTransportationTypeName?: string;
    itemGroups?: ReturnOrderItemGroupDto[];
    totals?: ReturnOrderTotalDto[];
    orderNumber?: string;
    customerAccountInfo?: string | undefined;
}

export class ReturnOrderByCustomerIdDto extends MainReturnOrderDto implements IReturnOrderByCustomerIdDto {

    constructor(data?: IReturnOrderByCustomerIdDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ReturnOrderByCustomerIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderByCustomerIdDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IReturnOrderByCustomerIdDto extends IMainReturnOrderDto {
}

export enum CostRefundType {
    NotDetermined = 0,
    Cash = 1,
    Credit = 2,
    Online = 3,
}

export class ReturnOrderStateBaseDto implements IReturnOrderStateBaseDto {
    id?: number;
    returnOrderStatus?: ReturnOrderStatus;
    returnOrderStatusName?: string;
    details?: string;
    created?: string;

    constructor(data?: IReturnOrderStateBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.returnOrderStatus = _data["returnOrderStatus"];
            this.returnOrderStatusName = _data["returnOrderStatusName"];
            this.details = _data["details"];
            this.created = _data["created"];
        }
    }

    static fromJS(data: any): ReturnOrderStateBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderStateBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["returnOrderStatus"] = this.returnOrderStatus;
        data["returnOrderStatusName"] = this.returnOrderStatusName;
        data["details"] = this.details;
        data["created"] = this.created;
        return data;
    }
}

export interface IReturnOrderStateBaseDto {
    id?: number;
    returnOrderStatus?: ReturnOrderStatus;
    returnOrderStatusName?: string;
    details?: string;
    created?: string;
}

export enum ReturnOrderStatus {
    PendingForRegister = 0,
    Registered = 1,
    Rejected = 2,
    Accepted = 3,
    Sent = 4,
    Received = 5,
    AllConfirmed = 6,
    CostRefunded = 7,
    SomeConfirmed = 8,
    Canceled = 9,
    Completed = 10,
}

export enum ReturnOrderTransportationType {
    NotDetermined = 0,
    CustomerReturn = 1,
    OrganizationReturn = 2,
    OnLocation = 3,
}

export class ReturnOrderItemGroupDto implements IReturnOrderItemGroupDto {
    id?: number;
    price?: number;
    totalDiscountPercent?: number;
    productLocalizedName?: string;
    productName?: string;
    productNo?: string | undefined;
    productAttributeOptionId?: number;
    totalQuantity?: number;
    optionValues?: ReturnOrderItemGroupProductAttributeOptionValueDto[];
    returnOrderItems?: ReturnOrderItemDto[];

    constructor(data?: IReturnOrderItemGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.totalDiscountPercent = _data["totalDiscountPercent"];
            this.productLocalizedName = _data["productLocalizedName"];
            this.productName = _data["productName"];
            this.productNo = _data["productNo"];
            this.productAttributeOptionId = _data["productAttributeOptionId"];
            this.totalQuantity = _data["totalQuantity"];
            if (Array.isArray(_data["optionValues"])) {
                this.optionValues = [] as any;
                for (let item of _data["optionValues"])
                    this.optionValues!.push(ReturnOrderItemGroupProductAttributeOptionValueDto.fromJS(item));
            }
            if (Array.isArray(_data["returnOrderItems"])) {
                this.returnOrderItems = [] as any;
                for (let item of _data["returnOrderItems"])
                    this.returnOrderItems!.push(ReturnOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReturnOrderItemGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderItemGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["totalDiscountPercent"] = this.totalDiscountPercent;
        data["productLocalizedName"] = this.productLocalizedName;
        data["productName"] = this.productName;
        data["productNo"] = this.productNo;
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        data["totalQuantity"] = this.totalQuantity;
        if (Array.isArray(this.optionValues)) {
            data["optionValues"] = [];
            for (let item of this.optionValues)
                data["optionValues"].push(item.toJSON());
        }
        if (Array.isArray(this.returnOrderItems)) {
            data["returnOrderItems"] = [];
            for (let item of this.returnOrderItems)
                data["returnOrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReturnOrderItemGroupDto {
    id?: number;
    price?: number;
    totalDiscountPercent?: number;
    productLocalizedName?: string;
    productName?: string;
    productNo?: string | undefined;
    productAttributeOptionId?: number;
    totalQuantity?: number;
    optionValues?: ReturnOrderItemGroupProductAttributeOptionValueDto[];
    returnOrderItems?: ReturnOrderItemDto[];
}

export class ReturnOrderItemGroupProductAttributeOptionValueDto implements IReturnOrderItemGroupProductAttributeOptionValueDto {
    id?: number;
    name?: string;
    value?: string;

    constructor(data?: IReturnOrderItemGroupProductAttributeOptionValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ReturnOrderItemGroupProductAttributeOptionValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderItemGroupProductAttributeOptionValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IReturnOrderItemGroupProductAttributeOptionValueDto {
    id?: number;
    name?: string;
    value?: string;
}

export class ReturnOrderItemDto implements IReturnOrderItemDto {
    id?: number;
    quantity?: number;
    total?: number;
    returnOrderReason?: ReturnOrderReasonDto;
    returnOrderItemDocuments?: ReturnOrderItemDocumentDto[];
    isAccepted?: boolean;

    constructor(data?: IReturnOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quantity = _data["quantity"];
            this.total = _data["total"];
            this.returnOrderReason = _data["returnOrderReason"] ? ReturnOrderReasonDto.fromJS(_data["returnOrderReason"]) : <any>undefined;
            if (Array.isArray(_data["returnOrderItemDocuments"])) {
                this.returnOrderItemDocuments = [] as any;
                for (let item of _data["returnOrderItemDocuments"])
                    this.returnOrderItemDocuments!.push(ReturnOrderItemDocumentDto.fromJS(item));
            }
            this.isAccepted = _data["isAccepted"];
        }
    }

    static fromJS(data: any): ReturnOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["total"] = this.total;
        data["returnOrderReason"] = this.returnOrderReason ? this.returnOrderReason.toJSON() : <any>undefined;
        if (Array.isArray(this.returnOrderItemDocuments)) {
            data["returnOrderItemDocuments"] = [];
            for (let item of this.returnOrderItemDocuments)
                data["returnOrderItemDocuments"].push(item.toJSON());
        }
        data["isAccepted"] = this.isAccepted;
        return data;
    }
}

export interface IReturnOrderItemDto {
    id?: number;
    quantity?: number;
    total?: number;
    returnOrderReason?: ReturnOrderReasonDto;
    returnOrderItemDocuments?: ReturnOrderItemDocumentDto[];
    isAccepted?: boolean;
}

export class ReturnOrderReasonDto implements IReturnOrderReasonDto {
    id?: number;
    details?: string;
    returnOrderReasonType?: ReturnOrderReasonType;
    returnOrderReasonTypeName?: string;
    customerType?: ReturnOrderCustomerReasonType | undefined;
    customerTypeName?: string | undefined;
    organizationType?: ReturnOrderOrganizationReasonType | undefined;
    organizationTypeName?: string | undefined;

    constructor(data?: IReturnOrderReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
            this.returnOrderReasonType = _data["returnOrderReasonType"];
            this.returnOrderReasonTypeName = _data["returnOrderReasonTypeName"];
            this.customerType = _data["customerType"];
            this.customerTypeName = _data["customerTypeName"];
            this.organizationType = _data["organizationType"];
            this.organizationTypeName = _data["organizationTypeName"];
        }
    }

    static fromJS(data: any): ReturnOrderReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        data["returnOrderReasonType"] = this.returnOrderReasonType;
        data["returnOrderReasonTypeName"] = this.returnOrderReasonTypeName;
        data["customerType"] = this.customerType;
        data["customerTypeName"] = this.customerTypeName;
        data["organizationType"] = this.organizationType;
        data["organizationTypeName"] = this.organizationTypeName;
        return data;
    }
}

export interface IReturnOrderReasonDto {
    id?: number;
    details?: string;
    returnOrderReasonType?: ReturnOrderReasonType;
    returnOrderReasonTypeName?: string;
    customerType?: ReturnOrderCustomerReasonType | undefined;
    customerTypeName?: string | undefined;
    organizationType?: ReturnOrderOrganizationReasonType | undefined;
    organizationTypeName?: string | undefined;
}

export enum ReturnOrderReasonType {
    CustomerSide = 0,
    OrganizationSide = 1,
}

export enum ReturnOrderCustomerReasonType {
    CustomerCancelation = 0,
}

export enum ReturnOrderOrganizationReasonType {
    WrongProduct = 0,
    DefectiveProduct = 1,
    IncompleteProduct = 2,
    Other = 3,
}

export class ReturnOrderItemDocumentDto implements IReturnOrderItemDocumentDto {
    id?: number;
    image?: string;
    description?: string;

    constructor(data?: IReturnOrderItemDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ReturnOrderItemDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderItemDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["description"] = this.description;
        return data;
    }
}

export interface IReturnOrderItemDocumentDto {
    id?: number;
    image?: string;
    description?: string;
}

export class ReturnOrderTotalDto implements IReturnOrderTotalDto {
    id?: number;
    title?: string;
    price?: number;
    type?: ReturnOrderTotalType;
    typeName?: string;
    returnOrderTotalApplyType?: ReturnOrderTotalApplyType;
    returnOrderTotalApplyTypeName?: string;
    returnOrderTotalDocuments?: ReturnOrderTotalDocumentDto[];

    constructor(data?: IReturnOrderTotalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.type = _data["type"];
            this.typeName = _data["typeName"];
            this.returnOrderTotalApplyType = _data["returnOrderTotalApplyType"];
            this.returnOrderTotalApplyTypeName = _data["returnOrderTotalApplyTypeName"];
            if (Array.isArray(_data["returnOrderTotalDocuments"])) {
                this.returnOrderTotalDocuments = [] as any;
                for (let item of _data["returnOrderTotalDocuments"])
                    this.returnOrderTotalDocuments!.push(ReturnOrderTotalDocumentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReturnOrderTotalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderTotalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["price"] = this.price;
        data["type"] = this.type;
        data["typeName"] = this.typeName;
        data["returnOrderTotalApplyType"] = this.returnOrderTotalApplyType;
        data["returnOrderTotalApplyTypeName"] = this.returnOrderTotalApplyTypeName;
        if (Array.isArray(this.returnOrderTotalDocuments)) {
            data["returnOrderTotalDocuments"] = [];
            for (let item of this.returnOrderTotalDocuments)
                data["returnOrderTotalDocuments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReturnOrderTotalDto {
    id?: number;
    title?: string;
    price?: number;
    type?: ReturnOrderTotalType;
    typeName?: string;
    returnOrderTotalApplyType?: ReturnOrderTotalApplyType;
    returnOrderTotalApplyTypeName?: string;
    returnOrderTotalDocuments?: ReturnOrderTotalDocumentDto[];
}

export enum ReturnOrderTotalType {
    Shipping = 0,
    ReturnShipping = 1,
    ShippingAgain = 2,
    Tax = 3,
    TotalDiscount = 4,
    Other = 5,
}

export enum ReturnOrderTotalApplyType {
    ReduceFromTotal = 0,
    AddToTotal = 1,
    DoNothing = 2,
}

export class ReturnOrderTotalDocumentDto implements IReturnOrderTotalDocumentDto {
    id?: number;
    image?: string;
    description?: string;

    constructor(data?: IReturnOrderTotalDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ReturnOrderTotalDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderTotalDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["description"] = this.description;
        return data;
    }
}

export interface IReturnOrderTotalDocumentDto {
    id?: number;
    image?: string;
    description?: string;
}

export class ReturnOrderByIdDto extends MainReturnOrderDto implements IReturnOrderByIdDto {
    customerId?: string;

    constructor(data?: IReturnOrderByIdDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
        }
    }

    static override fromJS(data: any): ReturnOrderByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderByIdDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data;
    }
}

export interface IReturnOrderByIdDto extends IMainReturnOrderDto {
    customerId?: string;
}

export class ReturnOrderByOrderIdDto extends MainReturnOrderDto implements IReturnOrderByOrderIdDto {

    constructor(data?: IReturnOrderByOrderIdDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ReturnOrderByOrderIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderByOrderIdDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IReturnOrderByOrderIdDto extends IMainReturnOrderDto {
}

export class ReturnOrderByNumberDto extends MainReturnOrderDto implements IReturnOrderByNumberDto {
    phoneNumber?: string;

    constructor(data?: IReturnOrderByNumberDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static override fromJS(data: any): ReturnOrderByNumberDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderByNumberDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IReturnOrderByNumberDto extends IMainReturnOrderDto {
    phoneNumber?: string;
}

export class PaginatedListOfReturnOrderByCustomerIdWithPaginationDto implements IPaginatedListOfReturnOrderByCustomerIdWithPaginationDto {
    items?: ReturnOrderByCustomerIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean; 
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfReturnOrderByCustomerIdWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReturnOrderByCustomerIdWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfReturnOrderByCustomerIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfReturnOrderByCustomerIdWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfReturnOrderByCustomerIdWithPaginationDto {
    items?: ReturnOrderByCustomerIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ReturnOrderByCustomerIdWithPaginationDto extends MainReturnOrderDto implements IReturnOrderByCustomerIdWithPaginationDto {

    constructor(data?: IReturnOrderByCustomerIdWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ReturnOrderByCustomerIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnOrderByCustomerIdWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IReturnOrderByCustomerIdWithPaginationDto extends IMainReturnOrderDto {
}

export class CreateReturnOrderCommand implements ICreateReturnOrderCommand {
    itemGroups?: CreateItemGroupCommandForReturnOrder[];
    orderId?: number;
    customerId?: string;
    details?: string;
    quantity?: number;
    subtotal?: number;
    total?: number;
    customerAccountInfo?: string | undefined;

    constructor(data?: ICreateReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["itemGroups"])) {
                this.itemGroups = [] as any;
                for (let item of _data["itemGroups"])
                    this.itemGroups!.push(CreateItemGroupCommandForReturnOrder.fromJS(item));
            }
            this.orderId = _data["orderId"];
            this.customerId = _data["customerId"];
            this.details = _data["details"];
            this.quantity = _data["quantity"];
            this.subtotal = _data["subtotal"];
            this.total = _data["total"];
            this.customerAccountInfo = _data["customerAccountInfo"];
        }
    }

    static fromJS(data: any): CreateReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemGroups)) {
            data["itemGroups"] = [];
            for (let item of this.itemGroups)
                data["itemGroups"].push(item.toJSON());
        }
        data["orderId"] = this.orderId;
        data["customerId"] = this.customerId;
        data["details"] = this.details;
        data["quantity"] = this.quantity;
        data["subtotal"] = this.subtotal;
        data["total"] = this.total;
        data["customerAccountInfo"] = this.customerAccountInfo;
        return data;
    }
}

export interface ICreateReturnOrderCommand {
    itemGroups?: CreateItemGroupCommandForReturnOrder[];
    orderId?: number;
    customerId?: string;
    details?: string;
    quantity?: number;
    subtotal?: number;
    total?: number;
    customerAccountInfo?: string | undefined;
}

export class CreateItemGroupCommandForReturnOrder implements ICreateItemGroupCommandForReturnOrder {
    productAttributeOptionId?: number;
    orderItems?: CreateItemCommandForItemGroup[];

    constructor(data?: ICreateItemGroupCommandForReturnOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productAttributeOptionId = _data["productAttributeOptionId"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(CreateItemCommandForItemGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateItemGroupCommandForReturnOrder {
        data = typeof data === 'object' ? data : {};
        let result = new CreateItemGroupCommandForReturnOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateItemGroupCommandForReturnOrder {
    productAttributeOptionId?: number;
    orderItems?: CreateItemCommandForItemGroup[];
}

export class CreateItemCommandForItemGroup implements ICreateItemCommandForItemGroup {
    quantity?: number;
    returnOrderReason?: CreateReasonCommandForItem;
    returnOrderItemDocuments?: DocumentCommandForItem[];

    constructor(data?: ICreateItemCommandForItemGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.returnOrderReason = _data["returnOrderReason"] ? CreateReasonCommandForItem.fromJS(_data["returnOrderReason"]) : <any>undefined;
            if (Array.isArray(_data["returnOrderItemDocuments"])) {
                this.returnOrderItemDocuments = [] as any;
                for (let item of _data["returnOrderItemDocuments"])
                    this.returnOrderItemDocuments!.push(DocumentCommandForItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateItemCommandForItemGroup {
        data = typeof data === 'object' ? data : {};
        let result = new CreateItemCommandForItemGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["returnOrderReason"] = this.returnOrderReason ? this.returnOrderReason.toJSON() : <any>undefined;
        if (Array.isArray(this.returnOrderItemDocuments)) {
            data["returnOrderItemDocuments"] = [];
            for (let item of this.returnOrderItemDocuments)
                data["returnOrderItemDocuments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateItemCommandForItemGroup {
    quantity?: number;
    returnOrderReason?: CreateReasonCommandForItem;
    returnOrderItemDocuments?: DocumentCommandForItem[];
}

export class CreateReasonCommandForItem implements ICreateReasonCommandForItem {
    details?: string;
    customerType?: number | undefined;
    organizationType?: number | undefined;

    constructor(data?: ICreateReasonCommandForItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"];
            this.customerType = _data["customerType"];
            this.organizationType = _data["organizationType"];
        }
    }

    static fromJS(data: any): CreateReasonCommandForItem {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReasonCommandForItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details;
        data["customerType"] = this.customerType;
        data["organizationType"] = this.organizationType;
        return data;
    }
}

export interface ICreateReasonCommandForItem {
    details?: string;
    customerType?: number | undefined;
    organizationType?: number | undefined;
}

export class DocumentCommandForItem implements IDocumentCommandForItem {
    image?: string;
    description?: string;

    constructor(data?: IDocumentCommandForItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["image"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DocumentCommandForItem {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentCommandForItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["description"] = this.description;
        return data;
    }
}

export interface IDocumentCommandForItem {
    image?: string;
    description?: string;
}

export class SendReturnOrderCommand implements ISendReturnOrderCommand {
    id?: number;
    details?: string;
    returnOrderTransportationType?: ReturnOrderTransportationType;
    returnShippingPrice?: number | undefined;
    documentCommandForTotals?: DocumentCommandForTotal[];

    constructor(data?: ISendReturnOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
            this.returnOrderTransportationType = _data["returnOrderTransportationType"];
            this.returnShippingPrice = _data["returnShippingPrice"];
            if (Array.isArray(_data["documentCommandForTotals"])) {
                this.documentCommandForTotals = [] as any;
                for (let item of _data["documentCommandForTotals"])
                    this.documentCommandForTotals!.push(DocumentCommandForTotal.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendReturnOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendReturnOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        data["returnOrderTransportationType"] = this.returnOrderTransportationType;
        data["returnShippingPrice"] = this.returnShippingPrice;
        if (Array.isArray(this.documentCommandForTotals)) {
            data["documentCommandForTotals"] = [];
            for (let item of this.documentCommandForTotals)
                data["documentCommandForTotals"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISendReturnOrderCommand {
    id?: number;
    details?: string;
    returnOrderTransportationType?: ReturnOrderTransportationType;
    returnShippingPrice?: number | undefined;
    documentCommandForTotals?: DocumentCommandForTotal[];
}

export class DocumentCommandForTotal implements IDocumentCommandForTotal {
    image?: string;
    description?: string;


    constructor(data?: IDocumentCommandForTotal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["image"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DocumentCommandForTotal {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentCommandForTotal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["description"] = this.description;
        return data;
    }
}

export interface IDocumentCommandForTotal {
    image?: string;
    description?: string;
}

export class AllBadgeDto implements IAllBadgeDto {
    id?: number;
    value?: string;

    constructor(data?: IAllBadgeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AllBadgeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllBadgeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface IAllBadgeDto {
    id?: number;
    value?: string;
}

export class BadgeByIdDto implements IBadgeByIdDto {
    id?: number;
    value?: string;

    constructor(data?: IBadgeByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BadgeByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new BadgeByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface IBadgeByIdDto {
    id?: number;
    value?: string;
}

export class PaginatedListOfCountingUnitWithPaginationDto implements IPaginatedListOfCountingUnitWithPaginationDto {
    items?: CountingUnitWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCountingUnitWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountingUnitWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCountingUnitWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCountingUnitWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCountingUnitWithPaginationDto {
    items?: CountingUnitWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CountingUnitWithPaginationDto implements ICountingUnitWithPaginationDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitType?: CountingUnitTypeDto | undefined;

    constructor(data?: ICountingUnitWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isDecimal = _data["isDecimal"];
            this.countingUnitType = _data["countingUnitType"] ? CountingUnitTypeDto.fromJS(_data["countingUnitType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CountingUnitWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountingUnitWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isDecimal"] = this.isDecimal;
        data["countingUnitType"] = this.countingUnitType ? this.countingUnitType.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICountingUnitWithPaginationDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitType?: CountingUnitTypeDto | undefined;
}

export class CountingUnitTypeDto implements ICountingUnitTypeDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: ICountingUnitTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): CountingUnitTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountingUnitTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface ICountingUnitTypeDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class AllCountingUnitDto implements IAllCountingUnitDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitType?: CountingUnitTypeDto | undefined;

    constructor(data?: IAllCountingUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isDecimal = _data["isDecimal"];
            this.countingUnitType = _data["countingUnitType"] ? CountingUnitTypeDto.fromJS(_data["countingUnitType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AllCountingUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllCountingUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isDecimal"] = this.isDecimal;
        data["countingUnitType"] = this.countingUnitType ? this.countingUnitType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAllCountingUnitDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitType?: CountingUnitTypeDto | undefined;
}

export class CountingUnitByIdDto implements ICountingUnitByIdDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitType?: CountingUnitTypeDto | undefined;

    constructor(data?: ICountingUnitByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isDecimal = _data["isDecimal"];
            this.countingUnitType = _data["countingUnitType"] ? CountingUnitTypeDto.fromJS(_data["countingUnitType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CountingUnitByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountingUnitByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isDecimal"] = this.isDecimal;
        data["countingUnitType"] = this.countingUnitType ? this.countingUnitType.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICountingUnitByIdDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    isDecimal?: boolean;
    countingUnitType?: CountingUnitTypeDto | undefined;
}

export class PaginatedListOfCountingUnitTypeWithPaginationDto implements IPaginatedListOfCountingUnitTypeWithPaginationDto {
    items?: CountingUnitTypeWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCountingUnitTypeWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountingUnitTypeWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCountingUnitTypeWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCountingUnitTypeWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCountingUnitTypeWithPaginationDto {
    items?: CountingUnitTypeWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CountingUnitTypeWithPaginationDto implements ICountingUnitTypeWithPaginationDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: ICountingUnitTypeWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): CountingUnitTypeWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountingUnitTypeWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface ICountingUnitTypeWithPaginationDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class AllCountingUnitTypeDto implements IAllCountingUnitTypeDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IAllCountingUnitTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllCountingUnitTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllCountingUnitTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllCountingUnitTypeDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class CountingUnitTypeByIdDto implements ICountingUnitTypeByIdDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: ICountingUnitTypeByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): CountingUnitTypeByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountingUnitTypeByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface ICountingUnitTypeByIdDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class AllProductDto extends MainProductDto implements IAllProductDto {

    constructor(data?: IAllProductDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): AllProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IAllProductDto extends IMainProductDto {
}

export class PaginatedListOfProductByProductCategoryIdWithPaginationDto implements IPaginatedListOfProductByProductCategoryIdWithPaginationDto {
    items?: ProductByProductCategoryIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductByProductCategoryIdWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductByProductCategoryIdWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductByProductCategoryIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductByProductCategoryIdWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductByProductCategoryIdWithPaginationDto {
    items?: ProductByProductCategoryIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductByProductCategoryIdWithPaginationDto extends MainProductDto implements IProductByProductCategoryIdWithPaginationDto {

    constructor(data?: IProductByProductCategoryIdWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ProductByProductCategoryIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductByProductCategoryIdWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductByProductCategoryIdWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto implements IPaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto {
    items?: FeaturedProductByProductCategoryIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FeaturedProductByProductCategoryIdWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfFeaturedProductByProductCategoryIdWithPaginationDto {
    items?: FeaturedProductByProductCategoryIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class FeaturedProductByProductCategoryIdWithPaginationDto extends MainProductDto implements IFeaturedProductByProductCategoryIdWithPaginationDto {

    constructor(data?: IFeaturedProductByProductCategoryIdWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): FeaturedProductByProductCategoryIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeaturedProductByProductCategoryIdWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IFeaturedProductByProductCategoryIdWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfProductWithPaginationDto implements IPaginatedListOfProductWithPaginationDto {
    items?: ProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductWithPaginationDto {
    items?: ProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductWithPaginationDto extends MainProductDto implements IProductWithPaginationDto {

    constructor(data?: IProductWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductWithPaginationDto extends IMainProductDto {
}

export class ProductByKindIdDto extends MainProductDto implements IProductByKindIdDto {

    constructor(data?: IProductByKindIdDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ProductByKindIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductByKindIdDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductByKindIdDto extends IMainProductDto {
}

export class ProductByProductCategoryIdDto extends MainProductDto implements IProductByProductCategoryIdDto {

    constructor(data?: IProductByProductCategoryIdDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ProductByProductCategoryIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductByProductCategoryIdDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductByProductCategoryIdDto extends IMainProductDto {
}

export class ProductByProductCategorySlugDto extends MainProductDto implements IProductByProductCategorySlugDto {

    constructor(data?: IProductByProductCategorySlugDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ProductByProductCategorySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductByProductCategorySlugDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductByProductCategorySlugDto extends IMainProductDto {
}

export class ProductByBrandIdDto extends MainProductDto implements IProductByBrandIdDto {

    constructor(data?: IProductByBrandIdDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ProductByBrandIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductByBrandIdDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductByBrandIdDto extends IMainProductDto {
}

export class ProductBySlugDto implements IProductBySlugDto {
    id?: number;
    related7SoftProductId?: string | undefined;
    localizedName?: string;
    name?: string;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    productNo?: string | undefined;
    images?: ProductImageBySlugDto[];
    reviewsLength?: number;
    kindIds?: number[];
    compatibility?: CompatibilityEnum;
    productBrand?: BrandBySlugDto;
    tags?: TagBySlugDto[];
    productAttributeType?: ProductAttributeTypeBySlugDto;
    productCategory?: ProductCategoryDto;
    attributes?: ProductAttributeBySlugDto[];
    colorOption?: ProductOptionColorBySlugDto | undefined;
    materialOption?: ProductOptionMaterialBySlugDto | undefined;
    rating?: number;
    attributeOptions?: ProductAttributeOptionBySlugDto[];
    productCustomFields?: ProductCustomFieldDto[];
    orderRate?: number;
    selectedProductAttributeOption?: ProductAttributeOptionBySlugDto | undefined;
    countryName?: string;

    constructor(data?: IProductBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.related7SoftProductId = _data["related7SoftProductId"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.excerpt = _data["excerpt"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.productNo = _data["productNo"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ProductImageBySlugDto.fromJS(item));
            }
            this.reviewsLength = _data["reviewsLength"];
            if (Array.isArray(_data["kindIds"])) {
                this.kindIds = [] as any;
                for (let item of _data["kindIds"])
                    this.kindIds!.push(item);
            }
            this.compatibility = _data["compatibility"];
            this.productBrand = _data["productBrand"] ? BrandBySlugDto.fromJS(_data["productBrand"]) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagBySlugDto.fromJS(item));
            }
            this.productAttributeType = _data["productAttributeType"] ? ProductAttributeTypeBySlugDto.fromJS(_data["productAttributeType"]) : <any>undefined;
            this.productCategory = _data["productCategory"] ? ProductCategoryDto.fromJS(_data["productCategory"]) : <any>undefined;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ProductAttributeBySlugDto.fromJS(item));
            }
            this.colorOption = _data["colorOption"] ? ProductOptionColorBySlugDto.fromJS(_data["colorOption"]) : <any>undefined;
            this.materialOption = _data["materialOption"] ? ProductOptionMaterialBySlugDto.fromJS(_data["materialOption"]) : <any>undefined;
            this.rating = _data["rating"];
            if (Array.isArray(_data["attributeOptions"])) {
                this.attributeOptions = [] as any;
                for (let item of _data["attributeOptions"])
                    this.attributeOptions!.push(ProductAttributeOptionBySlugDto.fromJS(item));
            }
            if (Array.isArray(_data["productCustomFields"])) {
                this.productCustomFields = [] as any;
                for (let item of _data["productCustomFields"])
                    this.productCustomFields!.push(ProductCustomFieldDto.fromJS(item));
            }
            this.orderRate = _data["orderRate"];
            this.selectedProductAttributeOption = _data["selectedProductAttributeOption"] ? ProductAttributeOptionBySlugDto.fromJS(_data["selectedProductAttributeOption"]) : <any>undefined;
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): ProductBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["related7SoftProductId"] = this.related7SoftProductId;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["excerpt"] = this.excerpt;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["productNo"] = this.productNo;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["reviewsLength"] = this.reviewsLength;
        if (Array.isArray(this.kindIds)) {
            data["kindIds"] = [];
            for (let item of this.kindIds)
                data["kindIds"].push(item);
        }
        data["compatibility"] = this.compatibility;
        data["productBrand"] = this.productBrand ? this.productBrand.toJSON() : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["productAttributeType"] = this.productAttributeType ? this.productAttributeType.toJSON() : <any>undefined;
        data["productCategory"] = this.productCategory ? this.productCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        data["colorOption"] = this.colorOption ? this.colorOption.toJSON() : <any>undefined;
        data["materialOption"] = this.materialOption ? this.materialOption.toJSON() : <any>undefined;
        data["rating"] = this.rating;
        if (Array.isArray(this.attributeOptions)) {
            data["attributeOptions"] = [];
            for (let item of this.attributeOptions)
                data["attributeOptions"].push(item.toJSON());
        }
        if (Array.isArray(this.productCustomFields)) {
            data["productCustomFields"] = [];
            for (let item of this.productCustomFields)
                data["productCustomFields"].push(item.toJSON());
        }
        data["orderRate"] = this.orderRate;
        data["selectedProductAttributeOption"] = this.selectedProductAttributeOption ? this.selectedProductAttributeOption.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IProductBySlugDto {
    id?: number;
    related7SoftProductId?: string | undefined;
    localizedName?: string;
    name?: string;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    productNo?: string | undefined;
    images?: ProductImageBySlugDto[];
    reviewsLength?: number;
    kindIds?: number[];
    compatibility?: CompatibilityEnum;
    productBrand?: BrandBySlugDto;
    tags?: TagBySlugDto[];
    productAttributeType?: ProductAttributeTypeBySlugDto;
    productCategory?: ProductCategoryDto;
    attributes?: ProductAttributeBySlugDto[];
    colorOption?: ProductOptionColorBySlugDto | undefined;
    materialOption?: ProductOptionMaterialBySlugDto | undefined;
    rating?: number;
    attributeOptions?: ProductAttributeOptionBySlugDto[];
    productCustomFields?: ProductCustomFieldDto[];
    orderRate?: number;
    selectedProductAttributeOption?: ProductAttributeOptionBySlugDto | undefined;
    countryName?: string;
}

export class ProductImageBySlugDto implements IProductImageBySlugDto {
    id?: number;
    image?: string;
    order?: number;
    isActive?: boolean;

    constructor(data?: IProductImageBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductImageBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductImageBySlugDto {
    id?: number;
    image?: string;
    order?: number;
    isActive?: boolean;
}

export class BrandBySlugDto implements IBrandBySlugDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    countryName?: string | undefined;

    constructor(data?: IBrandBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): BrandBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IBrandBySlugDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    countryName?: string | undefined;
}

export class TagBySlugDto implements ITagBySlugDto {
    id?: number;
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;

    constructor(data?: ITagBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.enTitle = _data["enTitle"];
            this.faTitle = _data["faTitle"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TagBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["enTitle"] = this.enTitle;
        data["faTitle"] = this.faTitle;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITagBySlugDto {
    id?: number;
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;
}

export class ProductAttributeTypeBySlugDto implements IProductAttributeTypeBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: ProductTypeAttributeGroupBySlugDto[];

    constructor(data?: IProductAttributeTypeBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["attributeGroups"])) {
                this.attributeGroups = [] as any;
                for (let item of _data["attributeGroups"])
                    this.attributeGroups!.push(ProductTypeAttributeGroupBySlugDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttributeTypeBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeTypeBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.attributeGroups)) {
            data["attributeGroups"] = [];
            for (let item of this.attributeGroups)
                data["attributeGroups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAttributeTypeBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: ProductTypeAttributeGroupBySlugDto[];
}

export class ProductTypeAttributeGroupBySlugDto implements IProductTypeAttributeGroupBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto[];
    attributes?: ProductTypeAttributeGroupAttributeBySlugDto[];

    constructor(data?: IProductTypeAttributeGroupBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["productTypeAttributeGroupCustomFields"])) {
                this.productTypeAttributeGroupCustomFields = [] as any;
                for (let item of _data["productTypeAttributeGroupCustomFields"])
                    this.productTypeAttributeGroupCustomFields!.push(ProductTypeAttributeGroupCustomFieldDto.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ProductTypeAttributeGroupAttributeBySlugDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.productTypeAttributeGroupCustomFields)) {
            data["productTypeAttributeGroupCustomFields"] = [];
            for (let item of this.productTypeAttributeGroupCustomFields)
                data["productTypeAttributeGroupCustomFields"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductTypeAttributeGroupBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto[];
    attributes?: ProductTypeAttributeGroupAttributeBySlugDto[];
}

export class ProductTypeAttributeGroupAttributeBySlugDto implements IProductTypeAttributeGroupAttributeBySlugDto {
    id?: number;
    value?: string;

    constructor(data?: IProductTypeAttributeGroupAttributeBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupAttributeBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupAttributeBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductTypeAttributeGroupAttributeBySlugDto {
    id?: number;
    value?: string;
}

export class ProductAttributeBySlugDto implements IProductAttributeBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    valueName?: string;
    valueSlug?: string;

    constructor(data?: IProductAttributeBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.featured = _data["featured"];
            this.valueName = _data["valueName"];
            this.valueSlug = _data["valueSlug"];
        }
    }

    static fromJS(data: any): ProductAttributeBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["featured"] = this.featured;
        data["valueName"] = this.valueName;
        data["valueSlug"] = this.valueSlug;
        return data;
    }
}

export interface IProductAttributeBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    valueName?: string;
    valueSlug?: string;
}

export class ProductOptionColorBySlugDto implements IProductOptionColorBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueColorBySlugDto[];
    productOptionColorCustomFields?: ProductOptionColorCustomFieldDto[];

    constructor(data?: IProductOptionColorBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProductOptionValueColorBySlugDto.fromJS(item));
            }
            if (Array.isArray(_data["productOptionColorCustomFields"])) {
                this.productOptionColorCustomFields = [] as any;
                for (let item of _data["productOptionColorCustomFields"])
                    this.productOptionColorCustomFields!.push(ProductOptionColorCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductOptionColorBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionColorBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.productOptionColorCustomFields)) {
            data["productOptionColorCustomFields"] = [];
            for (let item of this.productOptionColorCustomFields)
                data["productOptionColorCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductOptionColorBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueColorBySlugDto[];
    productOptionColorCustomFields?: ProductOptionColorCustomFieldDto[];
}

export class ProductOptionValueColorBySlugDto implements IProductOptionValueColorBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;

    constructor(data?: IProductOptionValueColorBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): ProductOptionValueColorBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionValueColorBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["color"] = this.color;
        return data;
    }
}

export interface IProductOptionValueColorBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;
}

export class ProductOptionMaterialBySlugDto implements IProductOptionMaterialBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueMaterialBySlugDto[];
    productOptionMaterialCustomFields?: ProductOptionMaterialCustomFieldDto[];

    constructor(data?: IProductOptionMaterialBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProductOptionValueMaterialBySlugDto.fromJS(item));
            }
            if (Array.isArray(_data["productOptionMaterialCustomFields"])) {
                this.productOptionMaterialCustomFields = [] as any;
                for (let item of _data["productOptionMaterialCustomFields"])
                    this.productOptionMaterialCustomFields!.push(ProductOptionMaterialCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductOptionMaterialBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionMaterialBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.productOptionMaterialCustomFields)) {
            data["productOptionMaterialCustomFields"] = [];
            for (let item of this.productOptionMaterialCustomFields)
                data["productOptionMaterialCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductOptionMaterialBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueMaterialBySlugDto[];
    productOptionMaterialCustomFields?: ProductOptionMaterialCustomFieldDto[];
}

export class ProductOptionValueMaterialBySlugDto implements IProductOptionValueMaterialBySlugDto {
    id?: number;
    name?: string;
    slug?: string;

    constructor(data?: IProductOptionValueMaterialBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): ProductOptionValueMaterialBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionValueMaterialBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IProductOptionValueMaterialBySlugDto {
    id?: number;
    name?: string;
    slug?: string;
}

export class ProductAttributeOptionBySlugDto implements IProductAttributeOptionBySlugDto {
    id?: number;
    optionValues?: ProductAttributeOptionValueBySlugDto[];
    productId?: number;
    productAttributeOptionRoles?: ProductAttributeOptionRoleBySlugDto[];
    isDefault?: boolean;
    prices?: PriceDto[];
    badges?: BadgeDto[];

    constructor(data?: IProductAttributeOptionBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["optionValues"])) {
                this.optionValues = [] as any;
                for (let item of _data["optionValues"])
                    this.optionValues!.push(ProductAttributeOptionValueBySlugDto.fromJS(item));
            }
            this.productId = _data["productId"];
            if (Array.isArray(_data["productAttributeOptionRoles"])) {
                this.productAttributeOptionRoles = [] as any;
                for (let item of _data["productAttributeOptionRoles"])
                    this.productAttributeOptionRoles!.push(ProductAttributeOptionRoleBySlugDto.fromJS(item));
            }
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(PriceDto.fromJS(item));
            }
            if (Array.isArray(_data["badges"])) {
                this.badges = [] as any;
                for (let item of _data["badges"])
                    this.badges!.push(BadgeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttributeOptionBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.optionValues)) {
            data["optionValues"] = [];
            for (let item of this.optionValues)
                data["optionValues"].push(item.toJSON());
        }
        data["productId"] = this.productId;
        if (Array.isArray(this.productAttributeOptionRoles)) {
            data["productAttributeOptionRoles"] = [];
            for (let item of this.productAttributeOptionRoles)
                data["productAttributeOptionRoles"].push(item.toJSON());
        }
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        if (Array.isArray(this.badges)) {
            data["badges"] = [];
            for (let item of this.badges)
                data["badges"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAttributeOptionBySlugDto {
    id?: number;
    optionValues?: ProductAttributeOptionValueBySlugDto[];
    productId?: number;
    productAttributeOptionRoles?: ProductAttributeOptionRoleBySlugDto[];
    isDefault?: boolean;
    prices?: PriceDto[];
    badges?: BadgeDto[];
}

export class ProductAttributeOptionValueBySlugDto implements IProductAttributeOptionValueBySlugDto {
    id?: number;
    name?: string;
    value?: string;

    constructor(data?: IProductAttributeOptionValueBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductAttributeOptionValueBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionValueBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductAttributeOptionValueBySlugDto {
    id?: number;
    name?: string;
    value?: string;
}

export class ProductAttributeOptionRoleBySlugDto implements IProductAttributeOptionRoleBySlugDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    discountPercent?: number;
    availability?: AvailabilityEnum;
    currentMaxOrderQty?: number;
    currentMinOrderQty?: number;

    constructor(data?: IProductAttributeOptionRoleBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.discountPercent = _data["discountPercent"];
            this.availability = _data["availability"];
            this.currentMaxOrderQty = _data["currentMaxOrderQty"];
            this.currentMinOrderQty = _data["currentMinOrderQty"];
        }
    }

    static fromJS(data: any): ProductAttributeOptionRoleBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionRoleBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["discountPercent"] = this.discountPercent;
        data["availability"] = this.availability;
        data["currentMaxOrderQty"] = this.currentMaxOrderQty;
        data["currentMinOrderQty"] = this.currentMinOrderQty;
        return data;
    }
}

export interface IProductAttributeOptionRoleBySlugDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    discountPercent?: number;
    availability?: AvailabilityEnum;
    currentMaxOrderQty?: number;
    currentMinOrderQty?: number;
}

export class ProductByIdDto implements IProductByIdDto {
    id?: number;
    related7SoftProductId?: string | undefined;
    localizedName?: string;
    name?: string;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    productNo?: string | undefined;
    images?: ProductImageByIdDto[];
    reviewsLength?: number;
    kindIds?: number[];
    compatibility?: CompatibilityEnum;
    productBrand?: BrandByIdDto;
    tags?: TagByIdDto[];
    productAttributeType?: ProductAttributeTypeByIdDto;
    productCategory?: ProductCategoryDto;
    attributes?: ProductAttributeByIdDto[];
    colorOption?: ProductOptionColorByIdDto | undefined;
    materialOption?: ProductOptionMaterialByIdDto | undefined;
    rating?: number;
    attributeOptions?: ProductAttributeOptionByIdDto[];
    productCustomFields?: ProductCustomFieldDto[];
    orderRate?: number;
    selectedProductAttributeOption?: ProductAttributeOptionByIdDto | undefined;
    countryName?: string;

    constructor(data?: IProductByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.related7SoftProductId = _data["related7SoftProductId"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.excerpt = _data["excerpt"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.productNo = _data["productNo"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ProductImageByIdDto.fromJS(item));
            }
            this.reviewsLength = _data["reviewsLength"];
            if (Array.isArray(_data["kindIds"])) {
                this.kindIds = [] as any;
                for (let item of _data["kindIds"])
                    this.kindIds!.push(item);
            }
            this.compatibility = _data["compatibility"];
            this.productBrand = _data["productBrand"] ? BrandByIdDto.fromJS(_data["productBrand"]) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagByIdDto.fromJS(item));
            }
            this.productAttributeType = _data["productAttributeType"] ? ProductAttributeTypeByIdDto.fromJS(_data["productAttributeType"]) : <any>undefined;
            this.productCategory = _data["productCategory"] ? ProductCategoryDto.fromJS(_data["productCategory"]) : <any>undefined;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ProductAttributeByIdDto.fromJS(item));
            }
            this.colorOption = _data["colorOption"] ? ProductOptionColorByIdDto.fromJS(_data["colorOption"]) : <any>undefined;
            this.materialOption = _data["materialOption"] ? ProductOptionMaterialByIdDto.fromJS(_data["materialOption"]) : <any>undefined;
            this.rating = _data["rating"];
            if (Array.isArray(_data["attributeOptions"])) {
                this.attributeOptions = [] as any;
                for (let item of _data["attributeOptions"])
                    this.attributeOptions!.push(ProductAttributeOptionByIdDto.fromJS(item));
            }
            if (Array.isArray(_data["productCustomFields"])) {
                this.productCustomFields = [] as any;
                for (let item of _data["productCustomFields"])
                    this.productCustomFields!.push(ProductCustomFieldDto.fromJS(item));
            }
            this.orderRate = _data["orderRate"];
            this.selectedProductAttributeOption = _data["selectedProductAttributeOption"] ? ProductAttributeOptionByIdDto.fromJS(_data["selectedProductAttributeOption"]) : <any>undefined;
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): ProductByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["related7SoftProductId"] = this.related7SoftProductId;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["excerpt"] = this.excerpt;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["productNo"] = this.productNo;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["reviewsLength"] = this.reviewsLength;
        if (Array.isArray(this.kindIds)) {
            data["kindIds"] = [];
            for (let item of this.kindIds)
                data["kindIds"].push(item);
        }
        data["compatibility"] = this.compatibility;
        data["productBrand"] = this.productBrand ? this.productBrand.toJSON() : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["productAttributeType"] = this.productAttributeType ? this.productAttributeType.toJSON() : <any>undefined;
        data["productCategory"] = this.productCategory ? this.productCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        data["colorOption"] = this.colorOption ? this.colorOption.toJSON() : <any>undefined;
        data["materialOption"] = this.materialOption ? this.materialOption.toJSON() : <any>undefined;
        data["rating"] = this.rating;
        if (Array.isArray(this.attributeOptions)) {
            data["attributeOptions"] = [];
            for (let item of this.attributeOptions)
                data["attributeOptions"].push(item.toJSON());
        }
        if (Array.isArray(this.productCustomFields)) {
            data["productCustomFields"] = [];
            for (let item of this.productCustomFields)
                data["productCustomFields"].push(item.toJSON());
        }
        data["orderRate"] = this.orderRate;
        data["selectedProductAttributeOption"] = this.selectedProductAttributeOption ? this.selectedProductAttributeOption.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IProductByIdDto {
    id?: number;
    related7SoftProductId?: string | undefined;
    localizedName?: string;
    name?: string;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    productNo?: string | undefined;
    images?: ProductImageByIdDto[];
    reviewsLength?: number;
    kindIds?: number[];
    compatibility?: CompatibilityEnum;
    productBrand?: BrandByIdDto;
    tags?: TagByIdDto[];
    productAttributeType?: ProductAttributeTypeByIdDto;
    productCategory?: ProductCategoryDto;
    attributes?: ProductAttributeByIdDto[];
    colorOption?: ProductOptionColorByIdDto | undefined;
    materialOption?: ProductOptionMaterialByIdDto | undefined;
    rating?: number;
    attributeOptions?: ProductAttributeOptionByIdDto[];
    productCustomFields?: ProductCustomFieldDto[];
    orderRate?: number;
    selectedProductAttributeOption?: ProductAttributeOptionByIdDto | undefined;
    countryName?: string;
}

export class ProductImageByIdDto implements IProductImageByIdDto {
    id?: number;
    image?: string;
    order?: number;
    isActive?: boolean;

    constructor(data?: IProductImageByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductImageByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductImageByIdDto {
    id?: number;
    image?: string;
    order?: number;
    isActive?: boolean;
}

export class BrandByIdDto implements IBrandByIdDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    countryName?: string | undefined;

    constructor(data?: IBrandByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): BrandByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IBrandByIdDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    countryName?: string | undefined;
}

export class TagByIdDto implements ITagByIdDto {
    id?: number;
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;

    constructor(data?: ITagByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.enTitle = _data["enTitle"];
            this.faTitle = _data["faTitle"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TagByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["enTitle"] = this.enTitle;
        data["faTitle"] = this.faTitle;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITagByIdDto {
    id?: number;
    enTitle?: string;
    faTitle?: string;
    isActive?: boolean;
}

export class ProductAttributeTypeByIdDto implements IProductAttributeTypeByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: ProductTypeAttributeGroupByIdDto[];

    constructor(data?: IProductAttributeTypeByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["attributeGroups"])) {
                this.attributeGroups = [] as any;
                for (let item of _data["attributeGroups"])
                    this.attributeGroups!.push(ProductTypeAttributeGroupByIdDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttributeTypeByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeTypeByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.attributeGroups)) {
            data["attributeGroups"] = [];
            for (let item of this.attributeGroups)
                data["attributeGroups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAttributeTypeByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: ProductTypeAttributeGroupByIdDto[];
}

export class ProductTypeAttributeGroupByIdDto implements IProductTypeAttributeGroupByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto[];
    attributes?: ProductTypeAttributeGroupAttributeByIdDto[];

    constructor(data?: IProductTypeAttributeGroupByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["productTypeAttributeGroupCustomFields"])) {
                this.productTypeAttributeGroupCustomFields = [] as any;
                for (let item of _data["productTypeAttributeGroupCustomFields"])
                    this.productTypeAttributeGroupCustomFields!.push(ProductTypeAttributeGroupCustomFieldDto.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ProductTypeAttributeGroupAttributeByIdDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.productTypeAttributeGroupCustomFields)) {
            data["productTypeAttributeGroupCustomFields"] = [];
            for (let item of this.productTypeAttributeGroupCustomFields)
                data["productTypeAttributeGroupCustomFields"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductTypeAttributeGroupByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto[];
    attributes?: ProductTypeAttributeGroupAttributeByIdDto[];
}

export class ProductTypeAttributeGroupAttributeByIdDto implements IProductTypeAttributeGroupAttributeByIdDto {
    id?: number;
    value?: string;

    constructor(data?: IProductTypeAttributeGroupAttributeByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupAttributeByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupAttributeByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductTypeAttributeGroupAttributeByIdDto {
    id?: number;
    value?: string;
}

export class ProductAttributeByIdDto implements IProductAttributeByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    valueName?: string;
    valueSlug?: string;

    constructor(data?: IProductAttributeByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.featured = _data["featured"];
            this.valueName = _data["valueName"];
            this.valueSlug = _data["valueSlug"];
        }
    }

    static fromJS(data: any): ProductAttributeByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["featured"] = this.featured;
        data["valueName"] = this.valueName;
        data["valueSlug"] = this.valueSlug;
        return data;
    }
}

export interface IProductAttributeByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    valueName?: string;
    valueSlug?: string;
}

export class ProductOptionColorByIdDto implements IProductOptionColorByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueColorByIdDto[];
    productOptionColorCustomFields?: ProductOptionColorCustomFieldDto[];

    constructor(data?: IProductOptionColorByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProductOptionValueColorByIdDto.fromJS(item));
            }
            if (Array.isArray(_data["productOptionColorCustomFields"])) {
                this.productOptionColorCustomFields = [] as any;
                for (let item of _data["productOptionColorCustomFields"])
                    this.productOptionColorCustomFields!.push(ProductOptionColorCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductOptionColorByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionColorByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.productOptionColorCustomFields)) {
            data["productOptionColorCustomFields"] = [];
            for (let item of this.productOptionColorCustomFields)
                data["productOptionColorCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductOptionColorByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueColorByIdDto[];
    productOptionColorCustomFields?: ProductOptionColorCustomFieldDto[];
}

export class ProductOptionValueColorByIdDto implements IProductOptionValueColorByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;

    constructor(data?: IProductOptionValueColorByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): ProductOptionValueColorByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionValueColorByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["color"] = this.color;
        return data;
    }
}

export interface IProductOptionValueColorByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;
}

export class ProductOptionMaterialByIdDto implements IProductOptionMaterialByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueMaterialByIdDto[];
    productOptionMaterialCustomFields?: ProductOptionMaterialCustomFieldDto[];

    constructor(data?: IProductOptionMaterialByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProductOptionValueMaterialByIdDto.fromJS(item));
            }
            if (Array.isArray(_data["productOptionMaterialCustomFields"])) {
                this.productOptionMaterialCustomFields = [] as any;
                for (let item of _data["productOptionMaterialCustomFields"])
                    this.productOptionMaterialCustomFields!.push(ProductOptionMaterialCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductOptionMaterialByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionMaterialByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.productOptionMaterialCustomFields)) {
            data["productOptionMaterialCustomFields"] = [];
            for (let item of this.productOptionMaterialCustomFields)
                data["productOptionMaterialCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductOptionMaterialByIdDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueMaterialByIdDto[];
    productOptionMaterialCustomFields?: ProductOptionMaterialCustomFieldDto[];
}

export class ProductOptionValueMaterialByIdDto implements IProductOptionValueMaterialByIdDto {
    id?: number;
    name?: string;
    slug?: string;

    constructor(data?: IProductOptionValueMaterialByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): ProductOptionValueMaterialByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionValueMaterialByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IProductOptionValueMaterialByIdDto {
    id?: number;
    name?: string;
    slug?: string;
}

export class ProductAttributeOptionByIdDto implements IProductAttributeOptionByIdDto {
    id?: number;
    optionValues?: ProductAttributeOptionValueByIdDto[];
    productId?: number;
    productAttributeOptionRoles?: ProductAttributeOptionRoleByIdDto[];
    isDefault?: boolean;
    prices?: PriceDto[];
    badges?: BadgeDto[];

    constructor(data?: IProductAttributeOptionByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["optionValues"])) {
                this.optionValues = [] as any;
                for (let item of _data["optionValues"])
                    this.optionValues!.push(ProductAttributeOptionValueByIdDto.fromJS(item));
            }
            this.productId = _data["productId"];
            if (Array.isArray(_data["productAttributeOptionRoles"])) {
                this.productAttributeOptionRoles = [] as any;
                for (let item of _data["productAttributeOptionRoles"])
                    this.productAttributeOptionRoles!.push(ProductAttributeOptionRoleByIdDto.fromJS(item));
            }
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(PriceDto.fromJS(item));
            }
            if (Array.isArray(_data["badges"])) {
                this.badges = [] as any;
                for (let item of _data["badges"])
                    this.badges!.push(BadgeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttributeOptionByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.optionValues)) {
            data["optionValues"] = [];
            for (let item of this.optionValues)
                data["optionValues"].push(item.toJSON());
        }
        data["productId"] = this.productId;
        if (Array.isArray(this.productAttributeOptionRoles)) {
            data["productAttributeOptionRoles"] = [];
            for (let item of this.productAttributeOptionRoles)
                data["productAttributeOptionRoles"].push(item.toJSON());
        }
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        if (Array.isArray(this.badges)) {
            data["badges"] = [];
            for (let item of this.badges)
                data["badges"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAttributeOptionByIdDto {
    id?: number;
    optionValues?: ProductAttributeOptionValueByIdDto[];
    productId?: number;
    productAttributeOptionRoles?: ProductAttributeOptionRoleByIdDto[];
    isDefault?: boolean;
    prices?: PriceDto[];
    badges?: BadgeDto[];
}

export class ProductAttributeOptionValueByIdDto implements IProductAttributeOptionValueByIdDto {
    id?: number;
    name?: string;
    value?: string;

    constructor(data?: IProductAttributeOptionValueByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductAttributeOptionValueByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionValueByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductAttributeOptionValueByIdDto {
    id?: number;
    name?: string;
    value?: string;
}

export class ProductAttributeOptionRoleByIdDto implements IProductAttributeOptionRoleByIdDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    discountPercent?: number;
    availability?: AvailabilityEnum;
    currentMaxOrderQty?: number;
    currentMinOrderQty?: number;

    constructor(data?: IProductAttributeOptionRoleByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.discountPercent = _data["discountPercent"];
            this.availability = _data["availability"];
            this.currentMaxOrderQty = _data["currentMaxOrderQty"];
            this.currentMinOrderQty = _data["currentMinOrderQty"];
        }
    }

    static fromJS(data: any): ProductAttributeOptionRoleByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionRoleByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["discountPercent"] = this.discountPercent;
        data["availability"] = this.availability;
        data["currentMaxOrderQty"] = this.currentMaxOrderQty;
        data["currentMinOrderQty"] = this.currentMinOrderQty;
        return data;
    }
}

export interface IProductAttributeOptionRoleByIdDto {
    id?: number;
    customerTypeEnum?: CustomerTypeEnum;
    discountPercent?: number;
    availability?: AvailabilityEnum;
    currentMaxOrderQty?: number;
    currentMinOrderQty?: number;
}

export class PaginatedListOfNewProductWithPaginationDto implements IPaginatedListOfNewProductWithPaginationDto {
    items?: NewProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfNewProductWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NewProductWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfNewProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfNewProductWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfNewProductWithPaginationDto {
    items?: NewProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class NewProductWithPaginationDto extends MainProductDto implements INewProductWithPaginationDto {

    constructor(data?: INewProductWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NewProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewProductWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INewProductWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfPopularProductWithPaginationDto implements IPaginatedListOfPopularProductWithPaginationDto {
    items?: PopularProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfPopularProductWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PopularProductWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfPopularProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPopularProductWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfPopularProductWithPaginationDto {
    items?: PopularProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PopularProductWithPaginationDto extends MainProductDto implements IPopularProductWithPaginationDto {

    constructor(data?: IPopularProductWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PopularProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PopularProductWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPopularProductWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfSalesProductWithPaginationDto implements IPaginatedListOfSalesProductWithPaginationDto {
    items?: SalesProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfSalesProductWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SalesProductWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfSalesProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSalesProductWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfSalesProductWithPaginationDto {
    items?: SalesProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SalesProductWithPaginationDto extends MainProductDto implements ISalesProductWithPaginationDto {

    constructor(data?: ISalesProductWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SalesProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesProductWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISalesProductWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfTopRatedProductWithPaginationDto implements IPaginatedListOfTopRatedProductWithPaginationDto {
    items?: TopRatedProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTopRatedProductWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TopRatedProductWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTopRatedProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTopRatedProductWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTopRatedProductWithPaginationDto {
    items?: TopRatedProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TopRatedProductWithPaginationDto extends MainProductDto implements ITopRatedProductWithPaginationDto {

    constructor(data?: ITopRatedProductWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): TopRatedProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopRatedProductWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ITopRatedProductWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfSpecialOffersProductWithPaginationDto implements IPaginatedListOfSpecialOffersProductWithPaginationDto {
    items?: SpecialOffersProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfSpecialOffersProductWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SpecialOffersProductWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfSpecialOffersProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSpecialOffersProductWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfSpecialOffersProductWithPaginationDto {
    items?: SpecialOffersProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SpecialOffersProductWithPaginationDto extends MainProductDto implements ISpecialOffersProductWithPaginationDto {

    constructor(data?: ISpecialOffersProductWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SpecialOffersProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialOffersProductWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISpecialOffersProductWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfBestSellerProductWithPaginationDto implements IPaginatedListOfBestSellerProductWithPaginationDto {
    items?: BestSellerProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfBestSellerProductWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BestSellerProductWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfBestSellerProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfBestSellerProductWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfBestSellerProductWithPaginationDto {
    items?: BestSellerProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class BestSellerProductWithPaginationDto extends MainProductDto implements IBestSellerProductWithPaginationDto {

    constructor(data?: IBestSellerProductWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BestSellerProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new BestSellerProductWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBestSellerProductWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfFeaturedProductWithPaginationDto implements IPaginatedListOfFeaturedProductWithPaginationDto {
    items?: FeaturedProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfFeaturedProductWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FeaturedProductWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfFeaturedProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFeaturedProductWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfFeaturedProductWithPaginationDto {
    items?: FeaturedProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class FeaturedProductWithPaginationDto extends MainProductDto implements IFeaturedProductWithPaginationDto {

    constructor(data?: IFeaturedProductWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): FeaturedProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeaturedProductWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IFeaturedProductWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfLatestProductWithPaginationDto implements IPaginatedListOfLatestProductWithPaginationDto {
    items?: LatestProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfLatestProductWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LatestProductWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfLatestProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfLatestProductWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfLatestProductWithPaginationDto {
    items?: LatestProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class LatestProductWithPaginationDto extends MainProductDto implements ILatestProductWithPaginationDto {

    constructor(data?: ILatestProductWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): LatestProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LatestProductWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ILatestProductWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfRelatedProductWithPaginationDto implements IPaginatedListOfRelatedProductWithPaginationDto {
    items?: RelatedProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfRelatedProductWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RelatedProductWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfRelatedProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfRelatedProductWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfRelatedProductWithPaginationDto {
    items?: RelatedProductWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class RelatedProductWithPaginationDto extends MainProductDto implements IRelatedProductWithPaginationDto {

    constructor(data?: IRelatedProductWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): RelatedProductWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new RelatedProductWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRelatedProductWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfProductByBrandIdWithPaginationDto implements IPaginatedListOfProductByBrandIdWithPaginationDto {
    items?: ProductByBrandIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductByBrandIdWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductByBrandIdWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductByBrandIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductByBrandIdWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductByBrandIdWithPaginationDto {
    items?: ProductByBrandIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductByBrandIdWithPaginationDto extends MainProductDto implements IProductByBrandIdWithPaginationDto {

    constructor(data?: IProductByBrandIdWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ProductByBrandIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductByBrandIdWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductByBrandIdWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfProductByKindIdWithPaginationDto implements IPaginatedListOfProductByKindIdWithPaginationDto {
    items?: ProductByKindIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductByKindIdWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductByKindIdWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductByKindIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductByKindIdWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductByKindIdWithPaginationDto {
    items?: ProductByKindIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductByKindIdWithPaginationDto extends MainProductDto implements IProductByKindIdWithPaginationDto {

    constructor(data?: IProductByKindIdWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ProductByKindIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductByKindIdWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductByKindIdWithPaginationDto extends IMainProductDto {
}

export class PaginatedListOfProductStatusWithPaginationDto implements IPaginatedListOfProductStatusWithPaginationDto {
    items?: ProductStatusWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductStatusWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductStatusWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductStatusWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductStatusWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductStatusWithPaginationDto {
    items?: ProductStatusWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductStatusWithPaginationDto implements IProductStatusWithPaginationDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IProductStatusWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): ProductStatusWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStatusWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IProductStatusWithPaginationDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class AllProductStatusDto implements IAllProductStatusDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IAllProductStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllProductStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllProductStatusDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class ProductStatusByIdDto implements IProductStatusByIdDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IProductStatusByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): ProductStatusByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStatusByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IProductStatusByIdDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class PaginatedListOfProductTypeWithPaginationDto implements IPaginatedListOfProductTypeWithPaginationDto {
    items?: ProductTypeWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductTypeWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductTypeWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductTypeWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductTypeWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductTypeWithPaginationDto {
    items?: ProductTypeWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductTypeWithPaginationDto implements IProductTypeWithPaginationDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IProductTypeWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): ProductTypeWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IProductTypeWithPaginationDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class AllProductTypeDto implements IAllProductTypeDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IAllProductTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): AllProductTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IAllProductTypeDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class ProductTypeByIdDto implements IProductTypeByIdDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;

    constructor(data?: IProductTypeByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): ProductTypeByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IProductTypeByIdDto {
    id?: number;
    code?: number;
    name?: string;
    localizedName?: string;
}

export class PaginatedListOfProviderWithPaginationDto implements IPaginatedListOfProviderWithPaginationDto {
    items?: ProviderWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProviderWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProviderWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProviderWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProviderWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProviderWithPaginationDto {
    items?: ProviderWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProviderWithPaginationDto implements IProviderWithPaginationDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;

    constructor(data?: IProviderWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.localizedCode = _data["localizedCode"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ProviderWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["localizedCode"] = this.localizedCode;
        data["description"] = this.description;
        return data;
    }
}

export interface IProviderWithPaginationDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;
}

export class AllProviderDto implements IAllProviderDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;

    constructor(data?: IAllProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.localizedCode = _data["localizedCode"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AllProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["localizedCode"] = this.localizedCode;
        data["description"] = this.description;
        return data;
    }
}

export interface IAllProviderDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;
}

export class ProviderByIdDto implements IProviderByIdDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;

    constructor(data?: IProviderByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.localizedCode = _data["localizedCode"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ProviderByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["localizedCode"] = this.localizedCode;
        data["description"] = this.description;
        return data;
    }
}

export interface IProviderByIdDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    localizedCode?: string | undefined;
    description?: string | undefined;
}

export class ReviewByProductIdDto implements IReviewByProductIdDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    authorName?: string;
    customer?: CustomerDto2;

    constructor(data?: IReviewByProductIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.rating = _data["rating"];
            this.content = _data["content"];
            this.authorName = _data["authorName"];
            this.customer = _data["customer"] ? CustomerDto2.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReviewByProductIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewByProductIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["rating"] = this.rating;
        data["content"] = this.content;
        data["authorName"] = this.authorName;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IReviewByProductIdDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    authorName?: string;
    customer?: CustomerDto2;
}

export class CustomerDto2 implements ICustomerDto2 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerDto2 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class PaginatedListOfReviewByProductIdWithPaginationDto implements IPaginatedListOfReviewByProductIdWithPaginationDto {
    items?: ReviewByProductIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfReviewByProductIdWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReviewByProductIdWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfReviewByProductIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfReviewByProductIdWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfReviewByProductIdWithPaginationDto {
    items?: ReviewByProductIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ReviewByProductIdWithPaginationDto implements IReviewByProductIdWithPaginationDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    authorName?: string;
    customer?: CustomerDto3;

    constructor(data?: IReviewByProductIdWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.rating = _data["rating"];
            this.content = _data["content"];
            this.authorName = _data["authorName"];
            this.customer = _data["customer"] ? CustomerDto3.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReviewByProductIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewByProductIdWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["rating"] = this.rating;
        data["content"] = this.content;
        data["authorName"] = this.authorName;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IReviewByProductIdWithPaginationDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    authorName?: string;
    customer?: CustomerDto3;
}

export class CustomerDto3 implements ICustomerDto3 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerDto3 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class ReviewByIdDto implements IReviewByIdDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    authorName?: string;
    customer?: CustomerDtoForReview;

    constructor(data?: IReviewByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.rating = _data["rating"];
            this.content = _data["content"];
            this.authorName = _data["authorName"];
            this.customer = _data["customer"] ? CustomerDtoForReview.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReviewByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["rating"] = this.rating;
        data["content"] = this.content;
        data["authorName"] = this.authorName;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IReviewByIdDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    authorName?: string;
    customer?: CustomerDtoForReview;
}

export class CustomerDtoForReview implements ICustomerDtoForReview {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerDtoForReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerDtoForReview {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDtoForReview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerDtoForReview {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class ReviewByCustomerIdDto implements IReviewByCustomerIdDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    authorName?: string;
    customer?: CustomerDto4;

    constructor(data?: IReviewByCustomerIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.rating = _data["rating"];
            this.content = _data["content"];
            this.authorName = _data["authorName"];
            this.customer = _data["customer"] ? CustomerDto4.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReviewByCustomerIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewByCustomerIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["rating"] = this.rating;
        data["content"] = this.content;
        data["authorName"] = this.authorName;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IReviewByCustomerIdDto {
    id?: number;
    date?: Date;
    rating?: number;
    content?: string;
    authorName?: string;
    customer?: CustomerDto4;
}

export class CustomerDto4 implements ICustomerDto4 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerDto4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerDto4 {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerDto4 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class CreateReviewCommand implements ICreateReviewCommand {
    rating?: number;
    content?: string;
    authorName?: string;
    productId?: number;
    customerId?: string;

    constructor(data?: ICreateReviewCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rating = _data["rating"];
            this.content = _data["content"];
            this.authorName = _data["authorName"];
            this.productId = _data["productId"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): CreateReviewCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReviewCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rating"] = this.rating;
        data["content"] = this.content;
        data["authorName"] = this.authorName;
        data["productId"] = this.productId;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface ICreateReviewCommand {
    rating?: number;
    content?: string;
    authorName?: string;
    productId?: number;
    customerId?: string;
}

export class AllTagDto implements IAllTagDto {
    id?: number;
    enTitle?: string;
    faTitle?: string;

    constructor(data?: IAllTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.enTitle = _data["enTitle"];
            this.faTitle = _data["faTitle"];
        }
    }

    static fromJS(data: any): AllTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["enTitle"] = this.enTitle;
        data["faTitle"] = this.faTitle;
        return data;
    }
}

export interface IAllTagDto {
    id?: number;
    enTitle?: string;
    faTitle?: string;
}

export class TagByIdDto2 implements ITagByIdDto2 {
    id?: number;
    enTitle?: string;
    faTitle?: string;

    constructor(data?: ITagByIdDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.enTitle = _data["enTitle"];
            this.faTitle = _data["faTitle"];
        }
    }

    static fromJS(data: any): TagByIdDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new TagByIdDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["enTitle"] = this.enTitle;
        data["faTitle"] = this.faTitle;
        return data;
    }
}

export interface ITagByIdDto2 {
    id?: number;
    enTitle?: string;
    faTitle?: string;
}

export class AllProductOptionColorDto implements IAllProductOptionColorDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueColorDto[];
    productOptionColorCustomFields?: ProductOptionColorCustomFieldDto2[];

    constructor(data?: IAllProductOptionColorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProductOptionValueColorDto.fromJS(item));
            }
            if (Array.isArray(_data["productOptionColorCustomFields"])) {
                this.productOptionColorCustomFields = [] as any;
                for (let item of _data["productOptionColorCustomFields"])
                    this.productOptionColorCustomFields!.push(ProductOptionColorCustomFieldDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllProductOptionColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductOptionColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.productOptionColorCustomFields)) {
            data["productOptionColorCustomFields"] = [];
            for (let item of this.productOptionColorCustomFields)
                data["productOptionColorCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllProductOptionColorDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueColorDto[];
    productOptionColorCustomFields?: ProductOptionColorCustomFieldDto2[];
}

export class ProductOptionValueColorDto implements IProductOptionValueColorDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;

    constructor(data?: IProductOptionValueColorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): ProductOptionValueColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionValueColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["color"] = this.color;
        return data;
    }
}

export interface IProductOptionValueColorDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;
}

export class ProductOptionColorCustomFieldDto2 implements IProductOptionColorCustomFieldDto2 {
    id?: number;
    fieldName?: string;
    value?: string;

    constructor(data?: IProductOptionColorCustomFieldDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductOptionColorCustomFieldDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionColorCustomFieldDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductOptionColorCustomFieldDto2 {
    id?: number;
    fieldName?: string;
    value?: string;
}

export class AllProductOptionValueColorDto implements IAllProductOptionValueColorDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;

    constructor(data?: IAllProductOptionValueColorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): AllProductOptionValueColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductOptionValueColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["color"] = this.color;
        return data;
    }
}

export interface IAllProductOptionValueColorDto {
    id?: number;
    name?: string;
    slug?: string;
    color?: string;
}

export class ProductOptionColorByIdDto2 implements IProductOptionColorByIdDto2 {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueColorDto[];
    productOptionColorCustomFields?: ProductOptionColorCustomFieldDto2[];

    constructor(data?: IProductOptionColorByIdDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProductOptionValueColorDto.fromJS(item));
            }
            if (Array.isArray(_data["productOptionColorCustomFields"])) {
                this.productOptionColorCustomFields = [] as any;
                for (let item of _data["productOptionColorCustomFields"])
                    this.productOptionColorCustomFields!.push(ProductOptionColorCustomFieldDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductOptionColorByIdDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionColorByIdDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.productOptionColorCustomFields)) {
            data["productOptionColorCustomFields"] = [];
            for (let item of this.productOptionColorCustomFields)
                data["productOptionColorCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductOptionColorByIdDto2 {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueColorDto[];
    productOptionColorCustomFields?: ProductOptionColorCustomFieldDto2[];
}

export class AllProductOptionMaterialDto implements IAllProductOptionMaterialDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueMaterialDto[];
    productOptionMaterialCustomFields?: ProductOptionMaterialCustomFieldDto2[];

    constructor(data?: IAllProductOptionMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProductOptionValueMaterialDto.fromJS(item));
            }
            if (Array.isArray(_data["productOptionMaterialCustomFields"])) {
                this.productOptionMaterialCustomFields = [] as any;
                for (let item of _data["productOptionMaterialCustomFields"])
                    this.productOptionMaterialCustomFields!.push(ProductOptionMaterialCustomFieldDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllProductOptionMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductOptionMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.productOptionMaterialCustomFields)) {
            data["productOptionMaterialCustomFields"] = [];
            for (let item of this.productOptionMaterialCustomFields)
                data["productOptionMaterialCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllProductOptionMaterialDto {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueMaterialDto[];
    productOptionMaterialCustomFields?: ProductOptionMaterialCustomFieldDto2[];
}

export class ProductOptionValueMaterialDto implements IProductOptionValueMaterialDto {
    id?: number;
    name?: string;
    slug?: string;

    constructor(data?: IProductOptionValueMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): ProductOptionValueMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionValueMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IProductOptionValueMaterialDto {
    id?: number;
    name?: string;
    slug?: string;
}

export class ProductOptionMaterialCustomFieldDto2 implements IProductOptionMaterialCustomFieldDto2 {
    id?: number;
    fieldName?: string;
    value?: string;

    constructor(data?: IProductOptionMaterialCustomFieldDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductOptionMaterialCustomFieldDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionMaterialCustomFieldDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductOptionMaterialCustomFieldDto2 {
    id?: number;
    fieldName?: string;
    value?: string;
}

export class AllProductOptionValueMaterialDto implements IAllProductOptionValueMaterialDto {
    id?: number;
    name?: string;
    slug?: string;

    constructor(data?: IAllProductOptionValueMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): AllProductOptionValueMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductOptionValueMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IAllProductOptionValueMaterialDto {
    id?: number;
    name?: string;
    slug?: string;
}

export class ProductOptionMaterialByIdDto2 implements IProductOptionMaterialByIdDto2 {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueMaterialDto[];
    productOptionMaterialCustomFields?: ProductOptionMaterialCustomFieldDto2[];

    constructor(data?: IProductOptionMaterialByIdDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProductOptionValueMaterialDto.fromJS(item));
            }
            if (Array.isArray(_data["productOptionMaterialCustomFields"])) {
                this.productOptionMaterialCustomFields = [] as any;
                for (let item of _data["productOptionMaterialCustomFields"])
                    this.productOptionMaterialCustomFields!.push(ProductOptionMaterialCustomFieldDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductOptionMaterialByIdDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionMaterialByIdDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.productOptionMaterialCustomFields)) {
            data["productOptionMaterialCustomFields"] = [];
            for (let item of this.productOptionMaterialCustomFields)
                data["productOptionMaterialCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductOptionMaterialByIdDto2 {
    id?: number;
    name?: string;
    slug?: string;
    type?: ProductOptionTypeEnum;
    values?: ProductOptionValueMaterialDto[];
    productOptionMaterialCustomFields?: ProductOptionMaterialCustomFieldDto2[];
}

export class AllProductAttributeDto implements IAllProductAttributeDto {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    productAttributeCustomFields?: ProductAttributeCustomFieldDto[];
    valueName?: string;
    valueSlug?: string;
    productAttributeValueCustomFields?: ProductAttributeValueCustomFieldDto[];

    constructor(data?: IAllProductAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.featured = _data["featured"];
            if (Array.isArray(_data["productAttributeCustomFields"])) {
                this.productAttributeCustomFields = [] as any;
                for (let item of _data["productAttributeCustomFields"])
                    this.productAttributeCustomFields!.push(ProductAttributeCustomFieldDto.fromJS(item));
            }
            this.valueName = _data["valueName"];
            this.valueSlug = _data["valueSlug"];
            if (Array.isArray(_data["productAttributeValueCustomFields"])) {
                this.productAttributeValueCustomFields = [] as any;
                for (let item of _data["productAttributeValueCustomFields"])
                    this.productAttributeValueCustomFields!.push(ProductAttributeValueCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllProductAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["featured"] = this.featured;
        if (Array.isArray(this.productAttributeCustomFields)) {
            data["productAttributeCustomFields"] = [];
            for (let item of this.productAttributeCustomFields)
                data["productAttributeCustomFields"].push(item.toJSON());
        }
        data["valueName"] = this.valueName;
        data["valueSlug"] = this.valueSlug;
        if (Array.isArray(this.productAttributeValueCustomFields)) {
            data["productAttributeValueCustomFields"] = [];
            for (let item of this.productAttributeValueCustomFields)
                data["productAttributeValueCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllProductAttributeDto {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    productAttributeCustomFields?: ProductAttributeCustomFieldDto[];
    valueName?: string;
    valueSlug?: string;
    productAttributeValueCustomFields?: ProductAttributeValueCustomFieldDto[];
}

export class ProductAttributeCustomFieldDto implements IProductAttributeCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;

    constructor(data?: IProductAttributeCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductAttributeCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductAttributeCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;
}

export class ProductAttributeValueCustomFieldDto implements IProductAttributeValueCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;

    constructor(data?: IProductAttributeValueCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductAttributeValueCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeValueCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductAttributeValueCustomFieldDto {
    id?: number;
    fieldName?: string;
    value?: string;
}

export class ProductAttributeByIdDto2 implements IProductAttributeByIdDto2 {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    productAttributeCustomFields?: ProductAttributeCustomFieldDto[];
    valueName?: string;
    valueSlug?: string;
    productAttributeValueCustomFields?: ProductAttributeValueCustomFieldDto[];

    constructor(data?: IProductAttributeByIdDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.featured = _data["featured"];
            if (Array.isArray(_data["productAttributeCustomFields"])) {
                this.productAttributeCustomFields = [] as any;
                for (let item of _data["productAttributeCustomFields"])
                    this.productAttributeCustomFields!.push(ProductAttributeCustomFieldDto.fromJS(item));
            }
            this.valueName = _data["valueName"];
            this.valueSlug = _data["valueSlug"];
            if (Array.isArray(_data["productAttributeValueCustomFields"])) {
                this.productAttributeValueCustomFields = [] as any;
                for (let item of _data["productAttributeValueCustomFields"])
                    this.productAttributeValueCustomFields!.push(ProductAttributeValueCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttributeByIdDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeByIdDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["featured"] = this.featured;
        if (Array.isArray(this.productAttributeCustomFields)) {
            data["productAttributeCustomFields"] = [];
            for (let item of this.productAttributeCustomFields)
                data["productAttributeCustomFields"].push(item.toJSON());
        }
        data["valueName"] = this.valueName;
        data["valueSlug"] = this.valueSlug;
        if (Array.isArray(this.productAttributeValueCustomFields)) {
            data["productAttributeValueCustomFields"] = [];
            for (let item of this.productAttributeValueCustomFields)
                data["productAttributeValueCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAttributeByIdDto2 {
    id?: number;
    name?: string;
    slug?: string;
    featured?: boolean;
    productAttributeCustomFields?: ProductAttributeCustomFieldDto[];
    valueName?: string;
    valueSlug?: string;
    productAttributeValueCustomFields?: ProductAttributeValueCustomFieldDto[];
}

export class AllProductAttributeTypeDto implements IAllProductAttributeTypeDto {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: ProductTypeAttributeGroupDto[];

    constructor(data?: IAllProductAttributeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["attributeGroups"])) {
                this.attributeGroups = [] as any;
                for (let item of _data["attributeGroups"])
                    this.attributeGroups!.push(ProductTypeAttributeGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllProductAttributeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductAttributeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.attributeGroups)) {
            data["attributeGroups"] = [];
            for (let item of this.attributeGroups)
                data["attributeGroups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllProductAttributeTypeDto {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: ProductTypeAttributeGroupDto[];
}

export class ProductTypeAttributeGroupDto implements IProductTypeAttributeGroupDto {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto2[];
    attributes?: ProductTypeAttributeGroupAttributeDto[];

    constructor(data?: IProductTypeAttributeGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["productTypeAttributeGroupCustomFields"])) {
                this.productTypeAttributeGroupCustomFields = [] as any;
                for (let item of _data["productTypeAttributeGroupCustomFields"])
                    this.productTypeAttributeGroupCustomFields!.push(ProductTypeAttributeGroupCustomFieldDto2.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ProductTypeAttributeGroupAttributeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.productTypeAttributeGroupCustomFields)) {
            data["productTypeAttributeGroupCustomFields"] = [];
            for (let item of this.productTypeAttributeGroupCustomFields)
                data["productTypeAttributeGroupCustomFields"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductTypeAttributeGroupDto {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto2[];
    attributes?: ProductTypeAttributeGroupAttributeDto[];
}

export class ProductTypeAttributeGroupCustomFieldDto2 implements IProductTypeAttributeGroupCustomFieldDto2 {
    id?: number;
    fieldName?: string;
    value?: string;

    constructor(data?: IProductTypeAttributeGroupCustomFieldDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupCustomFieldDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupCustomFieldDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductTypeAttributeGroupCustomFieldDto2 {
    id?: number;
    fieldName?: string;
    value?: string;
}

export class ProductTypeAttributeGroupAttributeDto implements IProductTypeAttributeGroupAttributeDto {
    id?: number;
    value?: string;

    constructor(data?: IProductTypeAttributeGroupAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductTypeAttributeGroupAttributeDto {
    id?: number;
    value?: string;
}

export class ProductAttributeTypeByIdDto2 implements IProductAttributeTypeByIdDto2 {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: ProductTypeAttributeGroupDto2[];

    constructor(data?: IProductAttributeTypeByIdDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["attributeGroups"])) {
                this.attributeGroups = [] as any;
                for (let item of _data["attributeGroups"])
                    this.attributeGroups!.push(ProductTypeAttributeGroupDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttributeTypeByIdDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeTypeByIdDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.attributeGroups)) {
            data["attributeGroups"] = [];
            for (let item of this.attributeGroups)
                data["attributeGroups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAttributeTypeByIdDto2 {
    id?: number;
    name?: string;
    slug?: string;
    attributeGroups?: ProductTypeAttributeGroupDto2[];
}

export class ProductTypeAttributeGroupDto2 implements IProductTypeAttributeGroupDto2 {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto2[];
    attributes?: ProductTypeAttributeGroupAttributeDto2[];

    constructor(data?: IProductTypeAttributeGroupDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["productTypeAttributeGroupCustomFields"])) {
                this.productTypeAttributeGroupCustomFields = [] as any;
                for (let item of _data["productTypeAttributeGroupCustomFields"])
                    this.productTypeAttributeGroupCustomFields!.push(ProductTypeAttributeGroupCustomFieldDto2.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ProductTypeAttributeGroupAttributeDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.productTypeAttributeGroupCustomFields)) {
            data["productTypeAttributeGroupCustomFields"] = [];
            for (let item of this.productTypeAttributeGroupCustomFields)
                data["productTypeAttributeGroupCustomFields"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductTypeAttributeGroupDto2 {
    id?: number;
    name?: string;
    slug?: string;
    productTypeAttributeGroupCustomFields?: ProductTypeAttributeGroupCustomFieldDto2[];
    attributes?: ProductTypeAttributeGroupAttributeDto2[];
}

export class ProductTypeAttributeGroupAttributeDto2 implements IProductTypeAttributeGroupAttributeDto2 {
    id?: number;
    value?: string;

    constructor(data?: IProductTypeAttributeGroupAttributeDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductTypeAttributeGroupAttributeDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeAttributeGroupAttributeDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductTypeAttributeGroupAttributeDto2 {
    id?: number;
    value?: string;
}

export class MainOrderDto implements IMainOrderDto {
    id?: number;
    token?: string;
    number?: string;
    quantity?: number;
    subtotal?: number;
    discountPercentForRole?: number;
    total?: number;
    createdAt?: Date;
    orderPaymentType?: OrderPaymentType;
    isPayed?: boolean;
    orderStateHistory?: OrderStateBaseDto[];
    orderAddress?: OrderAddressDto;
    items?: OrderItemDto[];
    totals?: OrderTotalDto[];
    paymentMethods?: OrderPaymentDto[];
    currentOrderStatus?: OrderStatus;
    currentOrderStatusDetails?: string;
    customerTypeEnum?: CustomerTypeEnum;
    phoneNumber?: string;
    customerId?: string;

    constructor(data?: IMainOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.number = _data["number"];
            this.quantity = _data["quantity"];
            this.subtotal = _data["subtotal"];
            this.discountPercentForRole = _data["discountPercentForRole"];
            this.total = _data["total"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.orderPaymentType = _data["orderPaymentType"];
            this.isPayed = _data["isPayed"];
            if (Array.isArray(_data["orderStateHistory"])) {
                this.orderStateHistory = [] as any;
                for (let item of _data["orderStateHistory"])
                    this.orderStateHistory!.push(OrderStateBaseDto.fromJS(item));
            }
            this.orderAddress = _data["orderAddress"] ? OrderAddressDto.fromJS(_data["orderAddress"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderItemDto.fromJS(item));
            }
            if (Array.isArray(_data["totals"])) {
                this.totals = [] as any;
                for (let item of _data["totals"])
                    this.totals!.push(OrderTotalDto.fromJS(item));
            }
            if (Array.isArray(_data["paymentMethods"])) {
                this.paymentMethods = [] as any;
                for (let item of _data["paymentMethods"])
                    this.paymentMethods!.push(OrderPaymentDto.fromJS(item));
            }
            this.currentOrderStatus = _data["currentOrderStatus"];
            this.currentOrderStatusDetails = _data["currentOrderStatusDetails"];
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.phoneNumber = _data["phoneNumber"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): MainOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["number"] = this.number;
        data["quantity"] = this.quantity;
        data["subtotal"] = this.subtotal;
        data["discountPercentForRole"] = this.discountPercentForRole;
        data["total"] = this.total;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["orderPaymentType"] = this.orderPaymentType;
        data["isPayed"] = this.isPayed;
        if (Array.isArray(this.orderStateHistory)) {
            data["orderStateHistory"] = [];
            for (let item of this.orderStateHistory)
                data["orderStateHistory"].push(item.toJSON());
        }
        data["orderAddress"] = this.orderAddress ? this.orderAddress.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.totals)) {
            data["totals"] = [];
            for (let item of this.totals)
                data["totals"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentMethods)) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item.toJSON());
        }
        data["currentOrderStatus"] = this.currentOrderStatus;
        data["currentOrderStatusDetails"] = this.currentOrderStatusDetails;
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["phoneNumber"] = this.phoneNumber;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IMainOrderDto {
    id?: number;
    token?: string;
    number?: string;
    quantity?: number;
    subtotal?: number;
    discountPercentForRole?: number;
    total?: number;
    createdAt?: Date;
    orderPaymentType?: OrderPaymentType;
    isPayed?: boolean;
    orderStateHistory?: OrderStateBaseDto[];
    orderAddress?: OrderAddressDto;
    items?: OrderItemDto[];
    totals?: OrderTotalDto[];
    paymentMethods?: OrderPaymentDto[];
    currentOrderStatus?: OrderStatus;
    currentOrderStatusDetails?: string;
    customerTypeEnum?: CustomerTypeEnum;
    phoneNumber?: string;
    customerId?: string;
}

export class OrderByCustomerIdDto extends MainOrderDto implements IOrderByCustomerIdDto {

    constructor(data?: IOrderByCustomerIdDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OrderByCustomerIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderByCustomerIdDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOrderByCustomerIdDto extends IMainOrderDto {
}

export enum OrderPaymentType {
    Unspecified = 0,
    Cash = 1,
    Credit = 2,
    Online = 3,
    CreditOnline = 4,
}

export class OrderStateBaseDto implements IOrderStateBaseDto {
    id?: number;
    orderStatus?: OrderStatus;
    details?: string;
    created?: Date;

    constructor(data?: IOrderStateBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderStatus = _data["orderStatus"];
            this.details = _data["details"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderStateBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderStateBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderStatus"] = this.orderStatus;
        data["details"] = this.details;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IOrderStateBaseDto {
    id?: number;
    orderStatus?: OrderStatus;
    details?: string;
    created?: Date;
}

export enum OrderStatus {
    PendingForRegister = 0,
    OrderRegistered = 1,
    OrderPaymentConfirmed = 2,
    OrderConfirmed = 3,
    OrderPrepared = 4,
    OrderShipped = 5,
    OrderPaymentUnconfirmed = 6,
    OrderUnconfirmed = 7,
    OrderCanceled = 8,
    OrderCostRefunded = 9,
    OrderCompleted = 10,
}

export class OrderAddressDto implements IOrderAddressDto {
    id?: number;
    title?: string;
    company?: string | undefined;
    country?: string;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;

    constructor(data?: IOrderAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.company = _data["company"];
            this.country = _data["country"];
            this.addressDetails1 = _data["addressDetails1"];
            this.addressDetails2 = _data["addressDetails2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postcode = _data["postcode"];
        }
    }

    static fromJS(data: any): OrderAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["company"] = this.company;
        data["country"] = this.country;
        data["addressDetails1"] = this.addressDetails1;
        data["addressDetails2"] = this.addressDetails2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postcode"] = this.postcode;
        return data;
    }
}

export interface IOrderAddressDto {
    id?: number;
    title?: string;
    company?: string | undefined;
    country?: string;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
}

export class OrderItemDto implements IOrderItemDto {
    id?: number;
    price?: number;
    discountPercentForProduct?: number;
    quantity?: number;
    total?: number;
    productLocalizedName?: string;
    productSlug?: string;
    productName?: string;
    productNo?: string | undefined;
    optionValues?: OrderItemProductAttributeOptionValueDto[];
    productAttributeOption?: ProductAttributeOptionForOrderDto;
    productAttributeOptionId?: number;
    options?: OrderItemOptionDto[];

    constructor(data?: IOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.discountPercentForProduct = _data["discountPercentForProduct"];
            this.quantity = _data["quantity"];
            this.total = _data["total"];
            this.productLocalizedName = _data["productLocalizedName"];
            this.productSlug = _data["productSlug"];
            this.productName = _data["productName"];
            this.productNo = _data["productNo"];
            if (Array.isArray(_data["optionValues"])) {
                this.optionValues = [] as any;
                for (let item of _data["optionValues"])
                    this.optionValues!.push(OrderItemProductAttributeOptionValueDto.fromJS(item));
            }
            this.productAttributeOption = _data["productAttributeOption"] ? ProductAttributeOptionForOrderDto.fromJS(_data["productAttributeOption"]) : <any>undefined;
            this.productAttributeOptionId = _data["productAttributeOptionId"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(OrderItemOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["discountPercentForProduct"] = this.discountPercentForProduct;
        data["quantity"] = this.quantity;
        data["total"] = this.total;
        data["productLocalizedName"] = this.productLocalizedName;
        data["productSlug"] = this.productSlug;
        data["productName"] = this.productName;
        data["productNo"] = this.productNo;
        if (Array.isArray(this.optionValues)) {
            data["optionValues"] = [];
            for (let item of this.optionValues)
                data["optionValues"].push(item.toJSON());
        }
        data["productAttributeOption"] = this.productAttributeOption ? this.productAttributeOption.toJSON() : <any>undefined;
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrderItemDto {
    id?: number;
    price?: number;
    discountPercentForProduct?: number;
    quantity?: number;
    total?: number;
    productLocalizedName?: string;
    productSlug?: string;
    productName?: string;
    productNo?: string | undefined;
    optionValues?: OrderItemProductAttributeOptionValueDto[];
    productAttributeOption?: ProductAttributeOptionForOrderDto;
    productAttributeOptionId?: number;
    options?: OrderItemOptionDto[];
}

export class OrderItemProductAttributeOptionValueDto implements IOrderItemProductAttributeOptionValueDto {
    id?: number;
    name?: string;
    value?: string;

    constructor(data?: IOrderItemProductAttributeOptionValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): OrderItemProductAttributeOptionValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemProductAttributeOptionValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IOrderItemProductAttributeOptionValueDto {
    id?: number;
    name?: string;
    value?: string;
}

export class ProductAttributeOptionForOrderDto implements IProductAttributeOptionForOrderDto {
    id?: number;
    productName?: string;

    constructor(data?: IProductAttributeOptionForOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): ProductAttributeOptionForOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionForOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IProductAttributeOptionForOrderDto {
    id?: number;
    productName?: string;
}

export class OrderItemOptionDto implements IOrderItemOptionDto {
    id?: number;
    name?: string;
    value?: string;

    constructor(data?: IOrderItemOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): OrderItemOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IOrderItemOptionDto {
    id?: number;
    name?: string;
    value?: string;
}

export class OrderTotalDto implements IOrderTotalDto {
    id?: number;
    title?: string;
    price?: number;
    type?: OrderTotalType;

    constructor(data?: IOrderTotalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): OrderTotalDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderTotalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["price"] = this.price;
        data["type"] = this.type;
        return data;
    }
}

export interface IOrderTotalDto {
    id?: number;
    title?: string;
    price?: number;
    type?: OrderTotalType;
}

export enum OrderTotalType {
    Shipping = 0,
    Tax = 1,
    DiscountOnCustomerType = 2,
    DiscountOnProduct = 3,
    Other = 4,
}

export class OrderPaymentDto implements IOrderPaymentDto {
    id?: number;
    paymentType?: PaymentType;
    paymentTypeName?: string;
    amount?: number | undefined;
    paymentServiceType?: PaymentServiceType | undefined;
    paymentServiceTypeName?: string | undefined;
    status?: OnlinePaymentStatus | undefined;
    statusName?: string | undefined;
    authority?: string | undefined;
    cardNumber?: string | undefined;
    rrn?: string | undefined;
    refId?: string | undefined;
    payGateTranId?: string | undefined;
    salesOrderId?: number | undefined;
    serviceTypeId?: number | undefined;
    error?: string | undefined;

    constructor(data?: IOrderPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentType = _data["paymentType"];
            this.paymentTypeName = _data["paymentTypeName"];
            this.amount = _data["amount"];
            this.paymentServiceType = _data["paymentServiceType"];
            this.paymentServiceTypeName = _data["paymentServiceTypeName"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.authority = _data["authority"];
            this.cardNumber = _data["cardNumber"];
            this.rrn = _data["rrn"];
            this.refId = _data["refId"];
            this.payGateTranId = _data["payGateTranId"];
            this.salesOrderId = _data["salesOrderId"];
            this.serviceTypeId = _data["serviceTypeId"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): OrderPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentType"] = this.paymentType;
        data["paymentTypeName"] = this.paymentTypeName;
        data["amount"] = this.amount;
        data["paymentServiceType"] = this.paymentServiceType;
        data["paymentServiceTypeName"] = this.paymentServiceTypeName;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["authority"] = this.authority;
        data["cardNumber"] = this.cardNumber;
        data["rrn"] = this.rrn;
        data["refId"] = this.refId;
        data["payGateTranId"] = this.payGateTranId;
        data["salesOrderId"] = this.salesOrderId;
        data["serviceTypeId"] = this.serviceTypeId;
        data["error"] = this.error;
        return data;
    }
}

export interface IOrderPaymentDto {
    id?: number;
    paymentType?: PaymentType;
    paymentTypeName?: string;
    amount?: number | undefined;
    paymentServiceType?: PaymentServiceType | undefined;
    paymentServiceTypeName?: string | undefined;
    status?: OnlinePaymentStatus | undefined;
    statusName?: string | undefined;
    authority?: string | undefined;
    cardNumber?: string | undefined;
    rrn?: string | undefined;
    refId?: string | undefined;
    payGateTranId?: string | undefined;
    salesOrderId?: number | undefined;
    serviceTypeId?: number | undefined;
    error?: string | undefined;
}

export enum PaymentType {
    Cash = 0,
    Credit = 1,
    Online = 2,
}

export enum PaymentServiceType {
    AsanPardakht = 1,
    Parsian = 2,
}

export enum OnlinePaymentStatus {
    Waiting = 0,
    Completed = 1,
    Failed = 2,
    Expired = 3,
}

export class OrderByIdDto extends MainOrderDto implements IOrderByIdDto {

    constructor(data?: IOrderByIdDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OrderByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderByIdDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOrderByIdDto extends IMainOrderDto {
}

export class OrderForReturnByIdDto extends MainOrderDto implements IOrderForReturnByIdDto {
    itemsForReturn?: OrderItemForReturnByIdDto[];

    constructor(data?: IOrderForReturnByIdDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["itemsForReturn"])) {
                this.itemsForReturn = [] as any;
                for (let item of _data["itemsForReturn"])
                    this.itemsForReturn!.push(OrderItemForReturnByIdDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): OrderForReturnByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderForReturnByIdDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemsForReturn)) {
            data["itemsForReturn"] = [];
            for (let item of this.itemsForReturn)
                data["itemsForReturn"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IOrderForReturnByIdDto extends IMainOrderDto {
    itemsForReturn?: OrderItemForReturnByIdDto[];
}

export class OrderItemForReturnByIdDto implements IOrderItemForReturnByIdDto {
    id?: number;
    price?: number;
    totalDiscountPercent?: number;
    taxPercent?: number;
    quantity?: number;
    total?: number;
    productLocalizedName?: string;
    productNo?: string | undefined;
    optionValues?: OrderItemProductAttributeOptionValueDto[];
    productAttributeOption?: ProductAttributeOptionForReturnByIdDto;
    productAttributeOptionId?: number;
    options?: OrderItemOptionDto[];

    constructor(data?: IOrderItemForReturnByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.totalDiscountPercent = _data["totalDiscountPercent"];
            this.taxPercent = _data["taxPercent"];
            this.quantity = _data["quantity"];
            this.total = _data["total"];
            this.productLocalizedName = _data["productLocalizedName"];
            this.productNo = _data["productNo"];
            if (Array.isArray(_data["optionValues"])) {
                this.optionValues = [] as any;
                for (let item of _data["optionValues"])
                    this.optionValues!.push(OrderItemProductAttributeOptionValueDto.fromJS(item));
            }
            this.productAttributeOption = _data["productAttributeOption"] ? ProductAttributeOptionForReturnByIdDto.fromJS(_data["productAttributeOption"]) : <any>undefined;
            this.productAttributeOptionId = _data["productAttributeOptionId"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(OrderItemOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderItemForReturnByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemForReturnByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["totalDiscountPercent"] = this.totalDiscountPercent;
        data["taxPercent"] = this.taxPercent;
        data["quantity"] = this.quantity;
        data["total"] = this.total;
        data["productLocalizedName"] = this.productLocalizedName;
        data["productNo"] = this.productNo;
        if (Array.isArray(this.optionValues)) {
            data["optionValues"] = [];
            for (let item of this.optionValues)
                data["optionValues"].push(item.toJSON());
        }
        data["productAttributeOption"] = this.productAttributeOption ? this.productAttributeOption.toJSON() : <any>undefined;
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrderItemForReturnByIdDto {
    id?: number;
    price?: number;
    totalDiscountPercent?: number;
    taxPercent?: number;
    quantity?: number;
    total?: number;
    productLocalizedName?: string;
    productNo?: string | undefined;
    optionValues?: OrderItemProductAttributeOptionValueDto[];
    productAttributeOption?: ProductAttributeOptionForReturnByIdDto;
    productAttributeOptionId?: number;
    options?: OrderItemOptionDto[];
}

export class ProductAttributeOptionForReturnByIdDto implements IProductAttributeOptionForReturnByIdDto {
    id?: number;
    productName?: string;
    productNo?: string | undefined;
    productBrandName?: string;
    productCategory?: string;
    productImage?: string;

    constructor(data?: IProductAttributeOptionForReturnByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productName = _data["productName"];
            this.productNo = _data["productNo"];
            this.productBrandName = _data["productBrandName"];
            this.productCategory = _data["productCategory"];
            this.productImage = _data["productImage"];
        }
    }

    static fromJS(data: any): ProductAttributeOptionForReturnByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeOptionForReturnByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["productNo"] = this.productNo;
        data["productBrandName"] = this.productBrandName;
        data["productCategory"] = this.productCategory;
        data["productImage"] = this.productImage;
        return data;
    }
}

export interface IProductAttributeOptionForReturnByIdDto {
    id?: number;
    productName?: string;
    productNo?: string | undefined;
    productBrandName?: string;
    productCategory?: string;
    productImage?: string;
}

export class OrderByNumberDto extends MainOrderDto implements IOrderByNumberDto {

    constructor(data?: IOrderByNumberDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OrderByNumberDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderByNumberDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOrderByNumberDto extends IMainOrderDto {
}

export class PaginatedListOfOrderByCustomerIdWithPaginationDto implements IPaginatedListOfOrderByCustomerIdWithPaginationDto {
    items?: OrderByCustomerIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfOrderByCustomerIdWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderByCustomerIdWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfOrderByCustomerIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfOrderByCustomerIdWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfOrderByCustomerIdWithPaginationDto {
    items?: OrderByCustomerIdWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class OrderByCustomerIdWithPaginationDto extends MainOrderDto implements IOrderByCustomerIdWithPaginationDto {

    constructor(data?: IOrderByCustomerIdWithPaginationDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OrderByCustomerIdWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderByCustomerIdWithPaginationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOrderByCustomerIdWithPaginationDto extends IMainOrderDto {
}

export class OrderInvoiceDto implements IOrderInvoiceDto {
    id?: number;
    customerFirstName?: string;
    customerLastName?: string;
    nationalCode?: string;
    orderAddress?: OrderAddressDto;
    phoneNumber?: string;
    personType?: PersonType;
    quantity?: number;
    subtotal?: number;
    total?: number;
    paymentType?: PaymentType;
    items?: OrderInvoiceItemDto[];
    totals?: OrderInvoiceTotalDto[];
    customerTypeEnum?: CustomerTypeEnum;
    customerId?: string;
    token?: string;
    taxPercent?: number;
    orderInvoiceNumber?: string | undefined;
    orderInvoiceSerial?: string | undefined;
    orderInvoiceDate?: string | undefined;
    orderInvoiceTime?: string | undefined;
    preOrderInvoiceNumber?: string | undefined;
    saleNumber?: string | undefined;

    constructor(data?: IOrderInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerFirstName = _data["customerFirstName"];
            this.customerLastName = _data["customerLastName"];
            this.nationalCode = _data["nationalCode"];
            this.orderAddress = _data["orderAddress"] ? OrderAddressDto.fromJS(_data["orderAddress"]) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
            this.personType = _data["personType"];
            this.quantity = _data["quantity"];
            this.subtotal = _data["subtotal"];
            this.total = _data["total"];
            this.paymentType = _data["paymentType"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderInvoiceItemDto.fromJS(item));
            }
            if (Array.isArray(_data["totals"])) {
                this.totals = [] as any;
                for (let item of _data["totals"])
                    this.totals!.push(OrderInvoiceTotalDto.fromJS(item));
            }
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.customerId = _data["customerId"];
            this.token = _data["token"];
            this.taxPercent = _data["taxPercent"];
            this.orderInvoiceNumber = _data["orderInvoiceNumber"];
            this.orderInvoiceSerial = _data["orderInvoiceSerial"];
            this.orderInvoiceDate = _data["orderInvoiceDate"];
            this.orderInvoiceTime = _data["orderInvoiceTime"];
            this.preOrderInvoiceNumber = _data["preOrderInvoiceNumber"];
            this.saleNumber = _data["saleNumber"];
        }
    }

    static fromJS(data: any): OrderInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerFirstName"] = this.customerFirstName;
        data["customerLastName"] = this.customerLastName;
        data["nationalCode"] = this.nationalCode;
        data["orderAddress"] = this.orderAddress ? this.orderAddress.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["personType"] = this.personType;
        data["quantity"] = this.quantity;
        data["subtotal"] = this.subtotal;
        data["total"] = this.total;
        data["paymentType"] = this.paymentType;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.totals)) {
            data["totals"] = [];
            for (let item of this.totals)
                data["totals"].push(item.toJSON());
        }
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["customerId"] = this.customerId;
        data["token"] = this.token;
        data["taxPercent"] = this.taxPercent;
        data["orderInvoiceNumber"] = this.orderInvoiceNumber;
        data["orderInvoiceSerial"] = this.orderInvoiceSerial;
        data["orderInvoiceDate"] = this.orderInvoiceDate;
        data["orderInvoiceTime"] = this.orderInvoiceTime;
        data["preOrderInvoiceNumber"] = this.preOrderInvoiceNumber;
        data["saleNumber"] = this.saleNumber;
        return data;
    }
}

export interface IOrderInvoiceDto {
    id?: number;
    customerFirstName?: string;
    customerLastName?: string;
    nationalCode?: string;
    orderAddress?: OrderAddressDto;
    phoneNumber?: string;
    personType?: PersonType;
    quantity?: number;
    subtotal?: number;
    total?: number;
    paymentType?: PaymentType;
    items?: OrderInvoiceItemDto[];
    totals?: OrderInvoiceTotalDto[];
    customerTypeEnum?: CustomerTypeEnum;
    customerId?: string;
    token?: string;
    taxPercent?: number;
    orderInvoiceNumber?: string | undefined;
    orderInvoiceSerial?: string | undefined;
    orderInvoiceDate?: string | undefined;
    orderInvoiceTime?: string | undefined;
    preOrderInvoiceNumber?: string | undefined;
    saleNumber?: string | undefined;
}

/** نوع هویت */
export enum PersonType {
    Natural = 1,
    Legal = 2,
}

export class OrderInvoiceItemDto implements IOrderInvoiceItemDto {
    productNo?: string | undefined;
    productLocalizedName?: string;
    quantity?: number;
    price?: number;
    total?: number;
    totalDiscountPercent?: number;
    taxPrice?: number;
    optionValues?: OrderItemProductAttributeOptionValueDto[];

    constructor(data?: IOrderInvoiceItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productNo = _data["productNo"];
            this.productLocalizedName = _data["productLocalizedName"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.total = _data["total"];
            this.totalDiscountPercent = _data["totalDiscountPercent"];
            this.taxPrice = _data["taxPrice"];
            if (Array.isArray(_data["optionValues"])) {
                this.optionValues = [] as any;
                for (let item of _data["optionValues"])
                    this.optionValues!.push(OrderItemProductAttributeOptionValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderInvoiceItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderInvoiceItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productNo"] = this.productNo;
        data["productLocalizedName"] = this.productLocalizedName;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["total"] = this.total;
        data["totalDiscountPercent"] = this.totalDiscountPercent;
        data["taxPrice"] = this.taxPrice;
        if (Array.isArray(this.optionValues)) {
            data["optionValues"] = [];
            for (let item of this.optionValues)
                data["optionValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrderInvoiceItemDto {
    productNo?: string | undefined;
    productLocalizedName?: string;
    quantity?: number;
    price?: number;
    total?: number;
    totalDiscountPercent?: number;
    taxPrice?: number;
    optionValues?: OrderItemProductAttributeOptionValueDto[];
}

export class OrderInvoiceTotalDto implements IOrderInvoiceTotalDto {
    title?: string;
    price?: number;
    type?: OrderTotalType;

    constructor(data?: IOrderInvoiceTotalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.price = _data["price"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): OrderInvoiceTotalDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderInvoiceTotalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["price"] = this.price;
        data["type"] = this.type;
        return data;
    }
}

export interface IOrderInvoiceTotalDto {
    title?: string;
    price?: number;
    type?: OrderTotalType;
}

export class UpdateOrderPriceAndCountCommand implements IUpdateOrderPriceAndCountCommand {
    orderId?: number;
    customerId?: string;

    constructor(data?: IUpdateOrderPriceAndCountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): UpdateOrderPriceAndCountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderPriceAndCountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IUpdateOrderPriceAndCountCommand {
    orderId?: number;
    customerId?: string;
}

export class SelfDeleteOrderCommand implements ISelfDeleteOrderCommand {
    id?: number;
    customerId?: string;

    constructor(data?: ISelfDeleteOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): SelfDeleteOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SelfDeleteOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface ISelfDeleteOrderCommand {
    id?: number;
    customerId?: string;
}

export class CreateOrderCommand implements ICreateOrderCommand {
    customerTypeEnum?: CustomerTypeEnum;
    personType?: PersonType;
    customerId?: string;
    quantity?: number;
    subtotal?: number;
    total?: number;
    details?: string | undefined;
    phoneNumber?: string;
    firstName?: string;
    lastName?: string;
    nationalCode?: string;
    orderItems?: CreateOrderItemCommandForOrder[];
    title?: string;
    company?: string | undefined;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;

    constructor(data?: ICreateOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerTypeEnum = _data["customerTypeEnum"];
            this.personType = _data["personType"];
            this.customerId = _data["customerId"];
            this.quantity = _data["quantity"];
            this.subtotal = _data["subtotal"];
            this.total = _data["total"];
            this.details = _data["details"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.nationalCode = _data["nationalCode"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(CreateOrderItemCommandForOrder.fromJS(item));
            }
            this.title = _data["title"];
            this.company = _data["company"];
            this.countryId = _data["countryId"];
            this.addressDetails1 = _data["addressDetails1"];
            this.addressDetails2 = _data["addressDetails2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postcode = _data["postcode"];
        }
    }

    static fromJS(data: any): CreateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerTypeEnum"] = this.customerTypeEnum;
        data["personType"] = this.personType;
        data["customerId"] = this.customerId;
        data["quantity"] = this.quantity;
        data["subtotal"] = this.subtotal;
        data["total"] = this.total;
        data["details"] = this.details;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["nationalCode"] = this.nationalCode;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["company"] = this.company;
        data["countryId"] = this.countryId;
        data["addressDetails1"] = this.addressDetails1;
        data["addressDetails2"] = this.addressDetails2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postcode"] = this.postcode;
        return data;
    }
}

export interface ICreateOrderCommand {
    customerTypeEnum?: CustomerTypeEnum;
    personType?: PersonType;
    customerId?: string;
    quantity?: number;
    subtotal?: number;
    total?: number;
    details?: string | undefined;
    phoneNumber?: string;
    firstName?: string;
    lastName?: string;
    nationalCode?: string;
    orderItems?: CreateOrderItemCommandForOrder[];
    title?: string;
    company?: string | undefined;
    countryId?: number;
    addressDetails1?: string;
    addressDetails2?: string | undefined;
    city?: string;
    state?: string;
    postcode?: string;
}

export class CreateOrderItemCommandForOrder implements ICreateOrderItemCommandForOrder {
    quantity?: number;
    productId?: number;
    productAttributeOptionId?: number;
    orderItemOptions?: CreateOrderItemOptionCommandForOrderItem[];

    constructor(data?: ICreateOrderItemCommandForOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.productId = _data["productId"];
            this.productAttributeOptionId = _data["productAttributeOptionId"];
            if (Array.isArray(_data["orderItemOptions"])) {
                this.orderItemOptions = [] as any;
                for (let item of _data["orderItemOptions"])
                    this.orderItemOptions!.push(CreateOrderItemOptionCommandForOrderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrderItemCommandForOrder {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderItemCommandForOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["productId"] = this.productId;
        data["productAttributeOptionId"] = this.productAttributeOptionId;
        if (Array.isArray(this.orderItemOptions)) {
            data["orderItemOptions"] = [];
            for (let item of this.orderItemOptions)
                data["orderItemOptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateOrderItemCommandForOrder {
    quantity?: number;
    productId?: number;
    productAttributeOptionId?: number;
    orderItemOptions?: CreateOrderItemOptionCommandForOrderItem[];
}

export class CreateOrderItemOptionCommandForOrderItem implements ICreateOrderItemOptionCommandForOrderItem {
    name?: string;
    value?: string;

    constructor(data?: ICreateOrderItemOptionCommandForOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateOrderItemOptionCommandForOrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderItemOptionCommandForOrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface ICreateOrderItemOptionCommandForOrderItem {
    name?: string;
    value?: string;
}

export class StartPaymentResult implements IStartPaymentResult {
    isSuccess?: boolean;
    token?: string | undefined;
    paymentUrl?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IStartPaymentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.token = _data["token"];
            this.paymentUrl = _data["paymentUrl"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): StartPaymentResult {
        data = typeof data === 'object' ? data : {};
        let result = new StartPaymentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["token"] = this.token;
        data["paymentUrl"] = this.paymentUrl;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IStartPaymentResult {
    isSuccess?: boolean;
    token?: string | undefined;
    paymentUrl?: string | undefined;
    errorMessage?: string | undefined;
}

export class CreateCreditOnlineOrderPayCommand implements ICreateCreditOnlineOrderPayCommand {
    orderId?: number;
    customerId?: string;
    paymentService?: PaymentServiceType;

    constructor(data?: ICreateCreditOnlineOrderPayCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.customerId = _data["customerId"];
            this.paymentService = _data["paymentService"];
        }
    }

    static fromJS(data: any): CreateCreditOnlineOrderPayCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCreditOnlineOrderPayCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["customerId"] = this.customerId;
        data["paymentService"] = this.paymentService;
        return data;
    }
}

export interface ICreateCreditOnlineOrderPayCommand {
    orderId?: number;
    customerId?: string;
    paymentService?: PaymentServiceType;
}

export class CreateOnlineOrderPayCommand implements ICreateOnlineOrderPayCommand {
    orderId?: number;
    customerId?: string;
    paymentService?: PaymentServiceType;

    constructor(data?: ICreateOnlineOrderPayCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.customerId = _data["customerId"];
            this.paymentService = _data["paymentService"];
        }
    }

    static fromJS(data: any): CreateOnlineOrderPayCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOnlineOrderPayCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["customerId"] = this.customerId;
        data["paymentService"] = this.paymentService;
        return data;
    }
}

export interface ICreateOnlineOrderPayCommand {
    orderId?: number;
    customerId?: string;
    paymentService?: PaymentServiceType;
}

export class CreateCreditOrderPayCommand implements ICreateCreditOrderPayCommand {
    orderId?: number;
    customerId?: string;

    constructor(data?: ICreateCreditOrderPayCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): CreateCreditOrderPayCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCreditOrderPayCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface ICreateCreditOrderPayCommand {
    orderId?: number;
    customerId?: string;
}

export class BlockBannerDto implements IBlockBannerDto {
    id?: number;
    title?: string;
    subtitle?: string;
    buttonText?: string;
    image?: string;
    blockBannerPosition?: BlockBannerPosition;

    constructor(data?: IBlockBannerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.subtitle = _data["subtitle"];
            this.buttonText = _data["buttonText"];
            this.image = _data["image"];
            this.blockBannerPosition = _data["blockBannerPosition"];
        }
    }

    static fromJS(data: any): BlockBannerDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlockBannerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["subtitle"] = this.subtitle;
        data["buttonText"] = this.buttonText;
        data["image"] = this.image;
        data["blockBannerPosition"] = this.blockBannerPosition;
        return data;
    }
}

export interface IBlockBannerDto {
    id?: number;
    title?: string;
    subtitle?: string;
    buttonText?: string;
    image?: string;
    blockBannerPosition?: BlockBannerPosition;
}

export enum BlockBannerPosition {
    LeftSide = 0,
    RightSide = 1,
}

export class CarouselDto implements ICarouselDto {
    id?: number;
    url?: string;
    desktopImage?: string;
    mobileImage?: string;
    offer?: string | undefined;
    title?: string;
    details?: string;
    buttonLabel?: string;

    constructor(data?: ICarouselDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.desktopImage = _data["desktopImage"];
            this.mobileImage = _data["mobileImage"];
            this.offer = _data["offer"];
            this.title = _data["title"];
            this.details = _data["details"];
            this.buttonLabel = _data["buttonLabel"];
        }
    }

    static fromJS(data: any): CarouselDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarouselDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["desktopImage"] = this.desktopImage;
        data["mobileImage"] = this.mobileImage;
        data["offer"] = this.offer;
        data["title"] = this.title;
        data["details"] = this.details;
        data["buttonLabel"] = this.buttonLabel;
        return data;
    }
}

export interface ICarouselDto {
    id?: number;
    url?: string;
    desktopImage?: string;
    mobileImage?: string;
    offer?: string | undefined;
    title?: string;
    details?: string;
    buttonLabel?: string;
}

export class PaginatedListOfFooterLinkContainerWithPaginationDto implements IPaginatedListOfFooterLinkContainerWithPaginationDto {
    items?: FooterLinkContainerWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfFooterLinkContainerWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FooterLinkContainerWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfFooterLinkContainerWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFooterLinkContainerWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfFooterLinkContainerWithPaginationDto {
    items?: FooterLinkContainerWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class FooterLinkContainerWithPaginationDto implements IFooterLinkContainerWithPaginationDto {
    id?: number;
    header?: string;
    links?: FooterLinkDto[];

    constructor(data?: IFooterLinkContainerWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.header = _data["header"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(FooterLinkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FooterLinkContainerWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new FooterLinkContainerWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["header"] = this.header;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFooterLinkContainerWithPaginationDto {
    id?: number;
    header?: string;
    links?: FooterLinkDto[];
}

export class FooterLinkDto implements IFooterLinkDto {
    id?: number;
    title?: string;
    url?: string;
    isActive?: boolean;

    constructor(data?: IFooterLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.url = _data["url"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): FooterLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new FooterLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IFooterLinkDto {
    id?: number;
    title?: string;
    url?: string;
    isActive?: boolean;
}

export class FooterLinkContainerDto implements IFooterLinkContainerDto {
    id?: number;
    header?: string;
    order?: number;
    isActive?: boolean;

    constructor(data?: IFooterLinkContainerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.header = _data["header"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): FooterLinkContainerDto {
        data = typeof data === 'object' ? data : {};
        let result = new FooterLinkContainerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["header"] = this.header;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IFooterLinkContainerDto {
    id?: number;
    header?: string;
    order?: number;
    isActive?: boolean;
}

export class PaginatedListOfFooterLinkDto implements IPaginatedListOfFooterLinkDto {
    items?: FooterLinkDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfFooterLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FooterLinkDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfFooterLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFooterLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfFooterLinkDto {
    items?: FooterLinkDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AllLinkDto implements IAllLinkDto {
    id?: number;
    title?: string;
    url?: string;
    image?: string | undefined;
    relatedProductCategoryId?: number;
    parentLink?: ParentLinkDto | undefined;
    childLinks?: ChildLinkDto[] | undefined;

    constructor(data?: IAllLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.url = _data["url"];
            this.image = _data["image"];
            this.relatedProductCategoryId = _data["relatedProductCategoryId"];
            this.parentLink = _data["parentLink"] ? ParentLinkDto.fromJS(_data["parentLink"]) : <any>undefined;
            if (Array.isArray(_data["childLinks"])) {
                this.childLinks = [] as any;
                for (let item of _data["childLinks"])
                    this.childLinks!.push(ChildLinkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["url"] = this.url;
        data["image"] = this.image;
        data["relatedProductCategoryId"] = this.relatedProductCategoryId;
        data["parentLink"] = this.parentLink ? this.parentLink.toJSON() : <any>undefined;
        if (Array.isArray(this.childLinks)) {
            data["childLinks"] = [];
            for (let item of this.childLinks)
                data["childLinks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllLinkDto {
    id?: number;
    title?: string;
    url?: string;
    image?: string | undefined;
    relatedProductCategoryId?: number;
    parentLink?: ParentLinkDto | undefined;
    childLinks?: ChildLinkDto[] | undefined;
}

export class ParentLinkDto implements IParentLinkDto {
    id?: number;
    title?: string;
    url?: string;
    image?: string | undefined;
    relatedProductCategoryId?: number;
    parentLink?: ParentLinkDto | undefined;

    constructor(data?: IParentLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.url = _data["url"];
            this.image = _data["image"];
            this.relatedProductCategoryId = _data["relatedProductCategoryId"];
            this.parentLink = _data["parentLink"] ? ParentLinkDto.fromJS(_data["parentLink"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParentLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["url"] = this.url;
        data["image"] = this.image;
        data["relatedProductCategoryId"] = this.relatedProductCategoryId;
        data["parentLink"] = this.parentLink ? this.parentLink.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParentLinkDto {
    id?: number;
    title?: string;
    url?: string;
    image?: string | undefined;
    relatedProductCategoryId?: number;
    parentLink?: ParentLinkDto | undefined;
}

export class ChildLinkDto implements IChildLinkDto {
    id?: number;
    title?: string;
    url?: string;
    image?: string | undefined;
    relatedProductCategoryId?: number;
    childLinks?: ChildLinkDto[] | undefined;

    constructor(data?: IChildLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.url = _data["url"];
            this.image = _data["image"];
            this.relatedProductCategoryId = _data["relatedProductCategoryId"];
            if (Array.isArray(_data["childLinks"])) {
                this.childLinks = [] as any;
                for (let item of _data["childLinks"])
                    this.childLinks!.push(ChildLinkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChildLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChildLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["url"] = this.url;
        data["image"] = this.image;
        data["relatedProductCategoryId"] = this.relatedProductCategoryId;
        if (Array.isArray(this.childLinks)) {
            data["childLinks"] = [];
            for (let item of this.childLinks)
                data["childLinks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChildLinkDto {
    id?: number;
    title?: string;
    url?: string;
    image?: string | undefined;
    relatedProductCategoryId?: number;
    childLinks?: ChildLinkDto[] | undefined;
}

export class FirstLayerLinkDto implements IFirstLayerLinkDto {
    id?: number;
    title?: string;
    url?: string;
    image?: string | undefined;
    relatedProductCategoryId?: number;
    childLinks?: ChildLinkDtoFirstLayer[] | undefined;

    constructor(data?: IFirstLayerLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.url = _data["url"];
            this.image = _data["image"];
            this.relatedProductCategoryId = _data["relatedProductCategoryId"];
            if (Array.isArray(_data["childLinks"])) {
                this.childLinks = [] as any;
                for (let item of _data["childLinks"])
                    this.childLinks!.push(ChildLinkDtoFirstLayer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FirstLayerLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new FirstLayerLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["url"] = this.url;
        data["image"] = this.image;
        data["relatedProductCategoryId"] = this.relatedProductCategoryId;
        if (Array.isArray(this.childLinks)) {
            data["childLinks"] = [];
            for (let item of this.childLinks)
                data["childLinks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFirstLayerLinkDto {
    id?: number;
    title?: string;
    url?: string;
    image?: string | undefined;
    relatedProductCategoryId?: number;
    childLinks?: ChildLinkDtoFirstLayer[] | undefined;
}

export class ChildLinkDtoFirstLayer implements IChildLinkDtoFirstLayer {
    id?: number;
    title?: string;
    url?: string;
    relatedProductCategoryId?: number;
    childLinks?: ChildLinkDtoSecondLayer[] | undefined;

    constructor(data?: IChildLinkDtoFirstLayer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.url = _data["url"];
            this.relatedProductCategoryId = _data["relatedProductCategoryId"];
            if (Array.isArray(_data["childLinks"])) {
                this.childLinks = [] as any;
                for (let item of _data["childLinks"])
                    this.childLinks!.push(ChildLinkDtoSecondLayer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChildLinkDtoFirstLayer {
        data = typeof data === 'object' ? data : {};
        let result = new ChildLinkDtoFirstLayer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["url"] = this.url;
        data["relatedProductCategoryId"] = this.relatedProductCategoryId;
        if (Array.isArray(this.childLinks)) {
            data["childLinks"] = [];
            for (let item of this.childLinks)
                data["childLinks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChildLinkDtoFirstLayer {
    id?: number;
    title?: string;
    url?: string;
    relatedProductCategoryId?: number;
    childLinks?: ChildLinkDtoSecondLayer[] | undefined;
}

export class ChildLinkDtoSecondLayer implements IChildLinkDtoSecondLayer {
    id?: number;
    title?: string;
    url?: string;
    relatedProductCategoryId?: number;
    childLinks?: ChildLinkDtoSecondLayer[] | undefined;

    constructor(data?: IChildLinkDtoSecondLayer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.url = _data["url"];
            this.relatedProductCategoryId = _data["relatedProductCategoryId"];
            if (Array.isArray(_data["childLinks"])) {
                this.childLinks = [] as any;
                for (let item of _data["childLinks"])
                    this.childLinks!.push(ChildLinkDtoSecondLayer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChildLinkDtoSecondLayer {
        data = typeof data === 'object' ? data : {};
        let result = new ChildLinkDtoSecondLayer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["url"] = this.url;
        data["relatedProductCategoryId"] = this.relatedProductCategoryId;
        if (Array.isArray(this.childLinks)) {
            data["childLinks"] = [];
            for (let item of this.childLinks)
                data["childLinks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChildLinkDtoSecondLayer {
    id?: number;
    title?: string;
    url?: string;
    relatedProductCategoryId?: number;
    childLinks?: ChildLinkDtoSecondLayer[] | undefined;
}

export class AllSocialLinkDto implements IAllSocialLinkDto {
    id?: number;
    url?: string;
    icon?: string;

    constructor(data?: IAllSocialLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.icon = _data["icon"];
        }
    }

    static fromJS(data: any): AllSocialLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllSocialLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["icon"] = this.icon;
        return data;
    }
}

export interface IAllSocialLinkDto {
    id?: number;
    url?: string;
    icon?: string;
}

export class ThemeDto implements IThemeDto {
    id?: number;
    title?: string;
    btnPrimaryColor?: string;
    btnPrimaryHoverColor?: string;
    btnSecondaryColor?: string;
    btnSecondaryHoverColor?: string;
    themeColor?: string;
    headerAndFooterColor?: string;
    isDefault?: boolean;

    constructor(data?: IThemeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.btnPrimaryColor = _data["btnPrimaryColor"];
            this.btnPrimaryHoverColor = _data["btnPrimaryHoverColor"];
            this.btnSecondaryColor = _data["btnSecondaryColor"];
            this.btnSecondaryHoverColor = _data["btnSecondaryHoverColor"];
            this.themeColor = _data["themeColor"];
            this.headerAndFooterColor = _data["headerAndFooterColor"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ThemeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["btnPrimaryColor"] = this.btnPrimaryColor;
        data["btnPrimaryHoverColor"] = this.btnPrimaryHoverColor;
        data["btnSecondaryColor"] = this.btnSecondaryColor;
        data["btnSecondaryHoverColor"] = this.btnSecondaryHoverColor;
        data["themeColor"] = this.themeColor;
        data["headerAndFooterColor"] = this.headerAndFooterColor;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IThemeDto {
    id?: number;
    title?: string;
    btnPrimaryColor?: string;
    btnPrimaryHoverColor?: string;
    btnSecondaryColor?: string;
    btnSecondaryHoverColor?: string;
    themeColor?: string;
    headerAndFooterColor?: string;
    isDefault?: boolean;
}

export class AboutUsDto implements IAboutUsDto {
    id?: number;
    textContent?: string;
    imageContent?: string;
    isDefault?: boolean;

    constructor(data?: IAboutUsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.textContent = _data["textContent"];
            this.imageContent = _data["imageContent"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): AboutUsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AboutUsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["textContent"] = this.textContent;
        data["imageContent"] = this.imageContent;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IAboutUsDto {
    id?: number;
    textContent?: string;
    imageContent?: string;
    isDefault?: boolean;
}

export class CorporationInfoDto implements ICorporationInfoDto {
    id?: number;
    contactUsMessage?: string;
    phoneNumbers?: string[];
    emailAddresses?: string[];
    locationAddresses?: string[];
    workingHours?: string[];
    poweredBy?: string;
    callUs?: string;
    desktopLogo?: string;
    mobileLogo?: string;
    footerLogo?: string;
    sliderBackGroundImage?: string;
    isDefault?: boolean;

    constructor(data?: ICorporationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactUsMessage = _data["contactUsMessage"];
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(item);
            }
            if (Array.isArray(_data["emailAddresses"])) {
                this.emailAddresses = [] as any;
                for (let item of _data["emailAddresses"])
                    this.emailAddresses!.push(item);
            }
            if (Array.isArray(_data["locationAddresses"])) {
                this.locationAddresses = [] as any;
                for (let item of _data["locationAddresses"])
                    this.locationAddresses!.push(item);
            }
            if (Array.isArray(_data["workingHours"])) {
                this.workingHours = [] as any;
                for (let item of _data["workingHours"])
                    this.workingHours!.push(item);
            }
            this.poweredBy = _data["poweredBy"];
            this.callUs = _data["callUs"];
            this.desktopLogo = _data["desktopLogo"];
            this.mobileLogo = _data["mobileLogo"];
            this.footerLogo = _data["footerLogo"];
            this.sliderBackGroundImage = _data["sliderBackGroundImage"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CorporationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CorporationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactUsMessage"] = this.contactUsMessage;
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item);
        }
        if (Array.isArray(this.emailAddresses)) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item);
        }
        if (Array.isArray(this.locationAddresses)) {
            data["locationAddresses"] = [];
            for (let item of this.locationAddresses)
                data["locationAddresses"].push(item);
        }
        if (Array.isArray(this.workingHours)) {
            data["workingHours"] = [];
            for (let item of this.workingHours)
                data["workingHours"].push(item);
        }
        data["poweredBy"] = this.poweredBy;
        data["callUs"] = this.callUs;
        data["desktopLogo"] = this.desktopLogo;
        data["mobileLogo"] = this.mobileLogo;
        data["footerLogo"] = this.footerLogo;
        data["sliderBackGroundImage"] = this.sliderBackGroundImage;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ICorporationInfoDto {
    id?: number;
    contactUsMessage?: string;
    phoneNumbers?: string[];
    emailAddresses?: string[];
    locationAddresses?: string[];
    workingHours?: string[];
    poweredBy?: string;
    callUs?: string;
    desktopLogo?: string;
    mobileLogo?: string;
    footerLogo?: string;
    sliderBackGroundImage?: string;
    isDefault?: boolean;
}

export class PaginatedListOfCountryWithPaginationDto implements IPaginatedListOfCountryWithPaginationDto {
    items?: CountryWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCountryWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountryWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCountryWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCountryWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCountryWithPaginationDto {
    items?: CountryWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CountryWithPaginationDto implements ICountryWithPaginationDto {
    id?: number;
    localizedName?: string;
    name?: string;
    code?: number;

    constructor(data?: ICountryWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CountryWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ICountryWithPaginationDto {
    id?: number;
    localizedName?: string;
    name?: string;
    code?: number;
}

export class AllCountryDto implements IAllCountryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    code?: number;

    constructor(data?: IAllCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): AllCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IAllCountryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    code?: number;
}

export class CountryByIdDto implements ICountryByIdDto {
    id?: number;
    localizedName?: string;
    name?: string;
    code?: number;

    constructor(data?: ICountryByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CountryByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ICountryByIdDto {
    id?: number;
    localizedName?: string;
    name?: string;
    code?: number;
}

export class PaginatedListOfQuestionWithPaginationDto implements IPaginatedListOfQuestionWithPaginationDto {
    items?: QuestionWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfQuestionWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(QuestionWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfQuestionWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfQuestionWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfQuestionWithPaginationDto {
    items?: QuestionWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class QuestionWithPaginationDto implements IQuestionWithPaginationDto {
    id?: number;
    questionText?: string;
    answerText?: string;
    questionType?: QuestionType;

    constructor(data?: IQuestionWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionText = _data["questionText"];
            this.answerText = _data["answerText"];
            this.questionType = _data["questionType"];
        }
    }

    static fromJS(data: any): QuestionWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionText"] = this.questionText;
        data["answerText"] = this.answerText;
        data["questionType"] = this.questionType;
        return data;
    }
}

export interface IQuestionWithPaginationDto {
    id?: number;
    questionText?: string;
    answerText?: string;
    questionType?: QuestionType;
}

export enum QuestionType {
    ShippingInformation = 0,
    PaymentInformation = 1,
    OrdersAndReturns = 2,
}

export class AllQuestionDto implements IAllQuestionDto {
    id?: number;
    questionText?: string;
    answerText?: string;
    questionType?: QuestionType;

    constructor(data?: IAllQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionText = _data["questionText"];
            this.answerText = _data["answerText"];
            this.questionType = _data["questionType"];
        }
    }

    static fromJS(data: any): AllQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionText"] = this.questionText;
        data["answerText"] = this.answerText;
        data["questionType"] = this.questionType;
        return data;
    }
}

export interface IAllQuestionDto {
    id?: number;
    questionText?: string;
    answerText?: string;
    questionType?: QuestionType;
}

export class QuestionByIdDto implements IQuestionByIdDto {
    id?: number;
    questionText?: string;
    answerText?: string;
    questionType?: QuestionType;

    constructor(data?: IQuestionByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionText = _data["questionText"];
            this.answerText = _data["answerText"];
            this.questionType = _data["questionType"];
        }
    }

    static fromJS(data: any): QuestionByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionText"] = this.questionText;
        data["answerText"] = this.answerText;
        data["questionType"] = this.questionType;
        return data;
    }
}

export interface IQuestionByIdDto {
    id?: number;
    questionText?: string;
    answerText?: string;
    questionType?: QuestionType;
}

export class PaginatedListOfTeamMemberWithPaginationDto implements IPaginatedListOfTeamMemberWithPaginationDto {
    items?: TeamMemberWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTeamMemberWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TeamMemberWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTeamMemberWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTeamMemberWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTeamMemberWithPaginationDto {
    items?: TeamMemberWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TeamMemberWithPaginationDto implements ITeamMemberWithPaginationDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;

    constructor(data?: ITeamMemberWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): TeamMemberWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamMemberWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ITeamMemberWithPaginationDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
}

export class AllTeamMemberDto implements IAllTeamMemberDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;

    constructor(data?: IAllTeamMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): AllTeamMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllTeamMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface IAllTeamMemberDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
}

export class TeamMemberByIdDto implements ITeamMemberByIdDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;

    constructor(data?: ITeamMemberByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): TeamMemberByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamMemberByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ITeamMemberByIdDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
}

export class PaginatedListOfTestimonialWithPaginationDto implements IPaginatedListOfTestimonialWithPaginationDto {
    items?: TestimonialWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTestimonialWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TestimonialWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTestimonialWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTestimonialWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTestimonialWithPaginationDto {
    items?: TestimonialWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TestimonialWithPaginationDto implements ITestimonialWithPaginationDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;

    constructor(data?: ITestimonialWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
            this.rating = _data["rating"];
            this.review = _data["review"];
        }
    }

    static fromJS(data: any): TestimonialWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestimonialWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        data["rating"] = this.rating;
        data["review"] = this.review;
        return data;
    }
}

export interface ITestimonialWithPaginationDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;
}

export class AllTestimonialDto implements IAllTestimonialDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;

    constructor(data?: IAllTestimonialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
            this.rating = _data["rating"];
            this.review = _data["review"];
        }
    }

    static fromJS(data: any): AllTestimonialDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllTestimonialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        data["rating"] = this.rating;
        data["review"] = this.review;
        return data;
    }
}

export interface IAllTestimonialDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;
}

export class TestimonialByIdDto implements ITestimonialByIdDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;

    constructor(data?: ITestimonialByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.position = _data["position"];
            this.avatar = _data["avatar"];
            this.rating = _data["rating"];
            this.review = _data["review"];
        }
    }

    static fromJS(data: any): TestimonialByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestimonialByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["position"] = this.position;
        data["avatar"] = this.avatar;
        data["rating"] = this.rating;
        data["review"] = this.review;
        return data;
    }
}

export interface ITestimonialByIdDto {
    id?: number;
    name?: string;
    position?: string;
    avatar?: string;
    rating?: number;
    review?: string;
}

export class FileUploadMetadataDto implements IFileUploadMetadataDto {
    fileId?: string;
    uploadName?: string;
    fileSize?: number;
    extension?: string;

    constructor(data?: IFileUploadMetadataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileId = _data["fileId"];
            this.uploadName = _data["uploadName"];
            this.fileSize = _data["fileSize"];
            this.extension = _data["extension"];
        }
    }

    static fromJS(data: any): FileUploadMetadataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadMetadataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileId"] = this.fileId;
        data["uploadName"] = this.uploadName;
        data["fileSize"] = this.fileSize;
        data["extension"] = this.extension;
        return data;
    }
}

export interface IFileUploadMetadataDto {
    fileId?: string;
    uploadName?: string;
    fileSize?: number;
    extension?: string;
}

export class StoredFileDto implements IStoredFileDto {
    id?: number;
    fileId?: string;
    extension?: string;
    fileName?: string;
    fileSize?: number;
    folder?: string;
    category?: FileCategory;
    uploadName?: string;
    uploadDate?: Date;
    owner?: string | undefined;

    constructor(data?: IStoredFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileId = _data["fileId"];
            this.extension = _data["extension"];
            this.fileName = _data["fileName"];
            this.fileSize = _data["fileSize"];
            this.folder = _data["folder"];
            this.category = _data["category"];
            this.uploadName = _data["uploadName"];
            this.uploadDate = _data["uploadDate"] ? new Date(_data["uploadDate"].toString()) : <any>undefined;
            this.owner = _data["owner"];
        }
    }

    static fromJS(data: any): StoredFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoredFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileId"] = this.fileId;
        data["extension"] = this.extension;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["folder"] = this.folder;
        data["category"] = this.category;
        data["uploadName"] = this.uploadName;
        data["uploadDate"] = this.uploadDate ? this.uploadDate.toISOString() : <any>undefined;
        data["owner"] = this.owner;
        return data;
    }
}

export interface IStoredFileDto {
    id?: number;
    fileId?: string;
    extension?: string;
    fileName?: string;
    fileSize?: number;
    folder?: string;
    category?: FileCategory;
    uploadName?: string;
    uploadDate?: Date;
    owner?: string | undefined;
}

export enum FileCategory {
    ProductBrand = 0,
    VehicleBrand = 1,
    BlogCategory = 2,
    ProductCategory = 3,
    Link = 4,
    AboutUs = 5,
    CorporationInfo = 6,
    TeamMember = 7,
    Testimonial = 8,
    BlockBanner = 9,
    Carousel = 10,
    SocialLink = 11,
    ProductImage = 12,
    Customer = 13,
    User = 14,
    ReturnOrderDocument = 15,
}

export class FilteredCustomerTicketDto implements IFilteredCustomerTicketDto {
    customerTickets?: CustomerTicketDto[];
    count?: number;

    constructor(data?: IFilteredCustomerTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["customerTickets"])) {
                this.customerTickets = [] as any;
                for (let item of _data["customerTickets"])
                    this.customerTickets!.push(CustomerTicketDto.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): FilteredCustomerTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredCustomerTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customerTickets)) {
            data["customerTickets"] = [];
            for (let item of this.customerTickets)
                data["customerTickets"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IFilteredCustomerTicketDto {
    customerTickets?: CustomerTicketDto[];
    count?: number;
}

export class CustomerTicketDto implements ICustomerTicketDto {
    id?: number;
    subject?: string;
    message?: string;
    date?: Date;
    customerPhoneNumber?: string;
    customerName?: string;
    isActive?: boolean;

    constructor(data?: ICustomerTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subject = _data["subject"];
            this.message = _data["message"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.customerPhoneNumber = _data["customerPhoneNumber"];
            this.customerName = _data["customerName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CustomerTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subject"] = this.subject;
        data["message"] = this.message;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["customerPhoneNumber"] = this.customerPhoneNumber;
        data["customerName"] = this.customerName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICustomerTicketDto {
    id?: number;
    subject?: string;
    message?: string;
    date?: Date;
    customerPhoneNumber?: string;
    customerName?: string;
    isActive?: boolean;
}

export class CreateCustomerTicketCommand implements ICreateCustomerTicketCommand {
    subject?: string;
    message?: string;
    customerId?: string;
    customerPhoneNumber?: string;
    customerName?: string;

    constructor(data?: ICreateCustomerTicketCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.message = _data["message"];
            this.customerId = _data["customerId"];
            this.customerPhoneNumber = _data["customerPhoneNumber"];
            this.customerName = _data["customerName"];
        }
    }

    static fromJS(data: any): CreateCustomerTicketCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerTicketCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["message"] = this.message;
        data["customerId"] = this.customerId;
        data["customerPhoneNumber"] = this.customerPhoneNumber;
        data["customerName"] = this.customerName;
        return data;
    }
}

export interface ICreateCustomerTicketCommand {
    subject?: string;
    message?: string;
    customerId?: string;
    customerPhoneNumber?: string;
    customerName?: string;
}

export class BlogCategoryDto implements IBlogCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    blogParentCategory?: BlogParentCategoryDto | undefined;
    blogChildrenCategories?: BlogChildCategoryDto[] | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];

    constructor(data?: IBlogCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.image = _data["image"];
            this.isActive = _data["isActive"];
            this.categoryType = _data["categoryType"];
            this.blogParentCategory = _data["blogParentCategory"] ? BlogParentCategoryDto.fromJS(_data["blogParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["blogChildrenCategories"])) {
                this.blogChildrenCategories = [] as any;
                for (let item of _data["blogChildrenCategories"])
                    this.blogChildrenCategories!.push(BlogChildCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["blogCategoryCustomFields"])) {
                this.blogCategoryCustomFields = [] as any;
                for (let item of _data["blogCategoryCustomFields"])
                    this.blogCategoryCustomFields!.push(BlogCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BlogCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["image"] = this.image;
        data["isActive"] = this.isActive;
        data["categoryType"] = this.categoryType;
        data["blogParentCategory"] = this.blogParentCategory ? this.blogParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.blogChildrenCategories)) {
            data["blogChildrenCategories"] = [];
            for (let item of this.blogChildrenCategories)
                data["blogChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.blogCategoryCustomFields)) {
            data["blogCategoryCustomFields"] = [];
            for (let item of this.blogCategoryCustomFields)
                data["blogCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlogCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    blogParentCategory?: BlogParentCategoryDto | undefined;
    blogChildrenCategories?: BlogChildCategoryDto[] | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];
}

export enum CategoryTypeEnum {
    ProductCategory = 0,
    BlogCategory = 1,
}

export class BlogParentCategoryDto implements IBlogParentCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    categoryType?: CategoryTypeEnum;
    blogParentCategory?: BlogParentCategoryDto | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];

    constructor(data?: IBlogParentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.blogParentCategory = _data["blogParentCategory"] ? BlogParentCategoryDto.fromJS(_data["blogParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["blogCategoryCustomFields"])) {
                this.blogCategoryCustomFields = [] as any;
                for (let item of _data["blogCategoryCustomFields"])
                    this.blogCategoryCustomFields!.push(BlogCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BlogParentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogParentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["blogParentCategory"] = this.blogParentCategory ? this.blogParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.blogCategoryCustomFields)) {
            data["blogCategoryCustomFields"] = [];
            for (let item of this.blogCategoryCustomFields)
                data["blogCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlogParentCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    categoryType?: CategoryTypeEnum;
    blogParentCategory?: BlogParentCategoryDto | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];
}

export class BlogCategoryCustomFieldDto implements IBlogCategoryCustomFieldDto {
    fieldName?: string;
    value?: string;

    constructor(data?: IBlogCategoryCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BlogCategoryCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogCategoryCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IBlogCategoryCustomFieldDto {
    fieldName?: string;
    value?: string;
}

export class BlogChildCategoryDto implements IBlogChildCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    categoryType?: CategoryTypeEnum;
    blogChildrenCategories?: BlogChildCategoryDto[] | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];

    constructor(data?: IBlogChildCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["blogChildrenCategories"])) {
                this.blogChildrenCategories = [] as any;
                for (let item of _data["blogChildrenCategories"])
                    this.blogChildrenCategories!.push(BlogChildCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["blogCategoryCustomFields"])) {
                this.blogCategoryCustomFields = [] as any;
                for (let item of _data["blogCategoryCustomFields"])
                    this.blogCategoryCustomFields!.push(BlogCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BlogChildCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogChildCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.blogChildrenCategories)) {
            data["blogChildrenCategories"] = [];
            for (let item of this.blogChildrenCategories)
                data["blogChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.blogCategoryCustomFields)) {
            data["blogCategoryCustomFields"] = [];
            for (let item of this.blogCategoryCustomFields)
                data["blogCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlogChildCategoryDto {
    id?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    image?: string;
    categoryType?: CategoryTypeEnum;
    blogChildrenCategories?: BlogChildCategoryDto[] | undefined;
    blogCategoryCustomFields?: BlogCategoryCustomFieldDto[];
}

export class AllProductCategoryDto implements IAllProductCategoryDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto | undefined;
    productChildrenCategories?: ProductChildCategoryDto[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IAllProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllProductCategoryDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto | undefined;
    productChildrenCategories?: ProductChildCategoryDto[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductParentCategoryDto implements IProductParentCategoryDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductParentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductParentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductParentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductParentCategoryDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductCategoryCustomFieldDto implements IProductCategoryCustomFieldDto {
    fieldName?: string;
    value?: string;

    constructor(data?: IProductCategoryCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProductCategoryCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data;
    }
}

export interface IProductCategoryCustomFieldDto {
    fieldName?: string;
    value?: string;
}

export class ProductChildCategoryDto implements IProductChildCategoryDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductChildCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.isActive = _data["isActive"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductChildCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductChildCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["isActive"] = this.isActive;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductChildCategoryDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class AllFirstLayerProductCategoryDto implements IAllFirstLayerProductCategoryDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto2[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IAllFirstLayerProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto2.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllFirstLayerProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllFirstLayerProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllFirstLayerProductCategoryDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto2[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductChildCategoryDto2 implements IProductChildCategoryDto2 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto2[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductChildCategoryDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.isActive = _data["isActive"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto2.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductChildCategoryDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductChildCategoryDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["isActive"] = this.isActive;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductChildCategoryDto2 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto2[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class PaginatedListOfAllProductCategoryWithPaginationDto implements IPaginatedListOfAllProductCategoryWithPaginationDto {
    items?: AllProductCategoryWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfAllProductCategoryWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AllProductCategoryWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfAllProductCategoryWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfAllProductCategoryWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfAllProductCategoryWithPaginationDto {
    items?: AllProductCategoryWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AllProductCategoryWithPaginationDto implements IAllProductCategoryWithPaginationDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto2 | undefined;
    productChildrenCategories?: ProductChildCategoryDto3[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IAllProductCategoryWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto2.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto3.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllProductCategoryWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductCategoryWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllProductCategoryWithPaginationDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto2 | undefined;
    productChildrenCategories?: ProductChildCategoryDto3[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductParentCategoryDto2 implements IProductParentCategoryDto2 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto2 | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductParentCategoryDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto2.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductParentCategoryDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductParentCategoryDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductParentCategoryDto2 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto2 | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductChildCategoryDto3 implements IProductChildCategoryDto3 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto3[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductChildCategoryDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.isActive = _data["isActive"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto3.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductChildCategoryDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductChildCategoryDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["isActive"] = this.isActive;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductChildCategoryDto3 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto3[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class PaginatedListOfFeaturedFirstProductCategoryWithPaginationDto implements IPaginatedListOfFeaturedFirstProductCategoryWithPaginationDto {
    items?: FeaturedFirstProductCategoryWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfFeaturedFirstProductCategoryWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FeaturedFirstProductCategoryWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfFeaturedFirstProductCategoryWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFeaturedFirstProductCategoryWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfFeaturedFirstProductCategoryWithPaginationDto {
    items?: FeaturedFirstProductCategoryWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class FeaturedFirstProductCategoryWithPaginationDto implements IFeaturedFirstProductCategoryWithPaginationDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto3 | undefined;
    productChildrenCategories?: ProductChildCategoryDto4[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IFeaturedFirstProductCategoryWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto3.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto4.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeaturedFirstProductCategoryWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeaturedFirstProductCategoryWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFeaturedFirstProductCategoryWithPaginationDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto3 | undefined;
    productChildrenCategories?: ProductChildCategoryDto4[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductParentCategoryDto3 implements IProductParentCategoryDto3 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto3 | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductParentCategoryDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto3.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductParentCategoryDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductParentCategoryDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductParentCategoryDto3 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto3 | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductChildCategoryDto4 implements IProductChildCategoryDto4 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto4[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductChildCategoryDto4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.isActive = _data["isActive"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto4.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductChildCategoryDto4 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductChildCategoryDto4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["isActive"] = this.isActive;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductChildCategoryDto4 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto4[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class PaginatedListOfPopularFirstProductCategoryWithPaginationDto implements IPaginatedListOfPopularFirstProductCategoryWithPaginationDto {
    items?: PopularFirstProductCategoryWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfPopularFirstProductCategoryWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PopularFirstProductCategoryWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfPopularFirstProductCategoryWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPopularFirstProductCategoryWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfPopularFirstProductCategoryWithPaginationDto {
    items?: PopularFirstProductCategoryWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PopularFirstProductCategoryWithPaginationDto implements IPopularFirstProductCategoryWithPaginationDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto4 | undefined;
    productChildrenCategories?: ProductChildCategoryDto5[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IPopularFirstProductCategoryWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto4.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto5.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PopularFirstProductCategoryWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PopularFirstProductCategoryWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPopularFirstProductCategoryWithPaginationDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto4 | undefined;
    productChildrenCategories?: ProductChildCategoryDto5[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductParentCategoryDto4 implements IProductParentCategoryDto4 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto4 | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductParentCategoryDto4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto4.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductParentCategoryDto4 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductParentCategoryDto4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductParentCategoryDto4 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto4 | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductChildCategoryDto5 implements IProductChildCategoryDto5 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto5[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductChildCategoryDto5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.isActive = _data["isActive"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto5.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductChildCategoryDto5 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductChildCategoryDto5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["isActive"] = this.isActive;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductChildCategoryDto5 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto5[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductCategoryByProductParentCategoryIdDto implements IProductCategoryByProductParentCategoryIdDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto6[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductCategoryByProductParentCategoryIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto6.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategoryByProductParentCategoryIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryByProductParentCategoryIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductCategoryByProductParentCategoryIdDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto6[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductChildCategoryDto6 implements IProductChildCategoryDto6 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto6[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductChildCategoryDto6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.isActive = _data["isActive"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto6.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductChildCategoryDto6 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductChildCategoryDto6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["isActive"] = this.isActive;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductChildCategoryDto6 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    isActive?: boolean;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto6[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductCategoryByIdDto implements IProductCategoryByIdDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto5 | undefined;
    productChildrenCategories?: ProductChildCategoryDto7[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductCategoryByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto5.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto7.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategoryByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductCategoryByIdDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto5 | undefined;
    productChildrenCategories?: ProductChildCategoryDto7[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductParentCategoryDto5 implements IProductParentCategoryDto5 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto5 | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductParentCategoryDto5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto5.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductParentCategoryDto5 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductParentCategoryDto5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductParentCategoryDto5 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto5 | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductChildCategoryDto7 implements IProductChildCategoryDto7 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto7[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductChildCategoryDto7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto7.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductChildCategoryDto7 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductChildCategoryDto7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductChildCategoryDto7 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto7[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductCategoryBySlugDto implements IProductCategoryBySlugDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto6 | undefined;
    productChildrenCategories?: ProductChildCategoryDto8[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductCategoryBySlugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto6.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto8.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategoryBySlugDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryBySlugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductCategoryBySlugDto {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto6 | undefined;
    productChildrenCategories?: ProductChildCategoryDto8[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductParentCategoryDto6 implements IProductParentCategoryDto6 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto6 | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductParentCategoryDto6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            this.productParentCategory = _data["productParentCategory"] ? ProductParentCategoryDto6.fromJS(_data["productParentCategory"]) : <any>undefined;
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductParentCategoryDto6 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductParentCategoryDto6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        data["productParentCategory"] = this.productParentCategory ? this.productParentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductParentCategoryDto6 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productParentCategory?: ProductParentCategoryDto6 | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class ProductChildCategoryDto8 implements IProductChildCategoryDto8 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto8[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];

    constructor(data?: IProductChildCategoryDto8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.productCategoryNo = _data["productCategoryNo"];
            this.image = _data["image"];
            this.categoryType = _data["categoryType"];
            if (Array.isArray(_data["productChildrenCategories"])) {
                this.productChildrenCategories = [] as any;
                for (let item of _data["productChildrenCategories"])
                    this.productChildrenCategories!.push(ProductChildCategoryDto8.fromJS(item));
            }
            if (Array.isArray(_data["productCategoryCustomFields"])) {
                this.productCategoryCustomFields = [] as any;
                for (let item of _data["productCategoryCustomFields"])
                    this.productCategoryCustomFields!.push(ProductCategoryCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductChildCategoryDto8 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductChildCategoryDto8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["productCategoryNo"] = this.productCategoryNo;
        data["image"] = this.image;
        data["categoryType"] = this.categoryType;
        if (Array.isArray(this.productChildrenCategories)) {
            data["productChildrenCategories"] = [];
            for (let item of this.productChildrenCategories)
                data["productChildrenCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategoryCustomFields)) {
            data["productCategoryCustomFields"] = [];
            for (let item of this.productCategoryCustomFields)
                data["productCategoryCustomFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductChildCategoryDto8 {
    id?: number;
    code?: number;
    localizedName?: string;
    name?: string;
    slug?: string | undefined;
    productCategoryNo?: string | undefined;
    image?: string | undefined;
    categoryType?: CategoryTypeEnum;
    productChildrenCategories?: ProductChildCategoryDto8[] | undefined;
    productCategoryCustomFields?: ProductCategoryCustomFieldDto[];
}

export class PaginatedListOfAllFamilyWithPaginationDto implements IPaginatedListOfAllFamilyWithPaginationDto {
    items?: AllFamilyWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfAllFamilyWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AllFamilyWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfAllFamilyWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfAllFamilyWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfAllFamilyWithPaginationDto {
    items?: AllFamilyWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AllFamilyWithPaginationDto implements IAllFamilyWithPaginationDto {
    id?: number;
    localizedName?: string;
    name?: string;
    models?: ModelDto[];

    constructor(data?: IAllFamilyWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            if (Array.isArray(_data["models"])) {
                this.models = [] as any;
                for (let item of _data["models"])
                    this.models!.push(ModelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllFamilyWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllFamilyWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        if (Array.isArray(this.models)) {
            data["models"] = [];
            for (let item of this.models)
                data["models"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllFamilyWithPaginationDto {
    id?: number;
    localizedName?: string;
    name?: string;
    models?: ModelDto[];
}

export class ModelDto implements IModelDto {
    id?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;

    constructor(data?: IModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IModelDto {
    id?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;
}

export class AllFamilyDto implements IAllFamilyDto {
    id?: number;
    localizedName?: string;
    name?: string;
    models?: ModelDto2[];

    constructor(data?: IAllFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            if (Array.isArray(_data["models"])) {
                this.models = [] as any;
                for (let item of _data["models"])
                    this.models!.push(ModelDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        if (Array.isArray(this.models)) {
            data["models"] = [];
            for (let item of this.models)
                data["models"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllFamilyDto {
    id?: number;
    localizedName?: string;
    name?: string;
    models?: ModelDto2[];
}

export class ModelDto2 implements IModelDto2 {
    id?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;

    constructor(data?: IModelDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ModelDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ModelDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IModelDto2 {
    id?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;
}

export class FamilyByBrandIdDto implements IFamilyByBrandIdDto {
    id?: number;
    localizedName?: string;
    name?: string;

    constructor(data?: IFamilyByBrandIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FamilyByBrandIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyByBrandIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        return data;
    }
}

export interface IFamilyByBrandIdDto {
    id?: number;
    localizedName?: string;
    name?: string;
}

export class FamilyByIdDto implements IFamilyByIdDto {
    id?: number;
    localizedName?: string;
    name?: string;
    models?: ModelDto3[];

    constructor(data?: IFamilyByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            if (Array.isArray(_data["models"])) {
                this.models = [] as any;
                for (let item of _data["models"])
                    this.models!.push(ModelDto3.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FamilyByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        if (Array.isArray(this.models)) {
            data["models"] = [];
            for (let item of this.models)
                data["models"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFamilyByIdDto {
    id?: number;
    localizedName?: string;
    name?: string;
    models?: ModelDto3[];
}

export class ModelDto3 implements IModelDto3 {
    id?: number;
    localizedName?: string;
    name?: string;

    constructor(data?: IModelDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ModelDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new ModelDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        return data;
    }
}

export interface IModelDto3 {
    id?: number;
    localizedName?: string;
    name?: string;
}

export class PaginatedListOfKindWithPaginationDto implements IPaginatedListOfKindWithPaginationDto {
    items?: KindWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfKindWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(KindWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfKindWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfKindWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfKindWithPaginationDto {
    items?: KindWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class KindWithPaginationDto implements IKindWithPaginationDto {
    id?: number;
    localizedName?: string;
    name?: string;
    products?: ProductDto[];
    vehicles?: VehicleDto[];

    constructor(data?: IKindWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductDto.fromJS(item));
            }
            if (Array.isArray(_data["vehicles"])) {
                this.vehicles = [] as any;
                for (let item of _data["vehicles"])
                    this.vehicles!.push(VehicleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KindWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new KindWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        if (Array.isArray(this.vehicles)) {
            data["vehicles"] = [];
            for (let item of this.vehicles)
                data["vehicles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IKindWithPaginationDto {
    id?: number;
    localizedName?: string;
    name?: string;
    products?: ProductDto[];
    vehicles?: VehicleDto[];
}

export class ProductDto implements IProductDto {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    directSalesLicense?: boolean;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    isActive?: boolean;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.productNo = _data["productNo"];
            this.oldProductNo = _data["oldProductNo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.productCatalog = _data["productCatalog"];
            this.orderRate = _data["orderRate"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.length = _data["length"];
            this.netWeight = _data["netWeight"];
            this.grossWeight = _data["grossWeight"];
            this.volumeWeight = _data["volumeWeight"];
            this.mileage = _data["mileage"];
            this.duration = _data["duration"];
            this.directSalesLicense = _data["directSalesLicense"];
            this.excerpt = _data["excerpt"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["productNo"] = this.productNo;
        data["oldProductNo"] = this.oldProductNo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["productCatalog"] = this.productCatalog;
        data["orderRate"] = this.orderRate;
        data["height"] = this.height;
        data["width"] = this.width;
        data["length"] = this.length;
        data["netWeight"] = this.netWeight;
        data["grossWeight"] = this.grossWeight;
        data["volumeWeight"] = this.volumeWeight;
        data["mileage"] = this.mileage;
        data["duration"] = this.duration;
        data["directSalesLicense"] = this.directSalesLicense;
        data["excerpt"] = this.excerpt;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductDto {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    directSalesLicense?: boolean;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    isActive?: boolean;
}

export class VehicleDto implements IVehicleDto {
    id?: number;
    vinNumber?: string;
    isActive?: boolean;

    constructor(data?: IVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): VehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IVehicleDto {
    id?: number;
    vinNumber?: string;
    isActive?: boolean;
}

export class AllKindDto implements IAllKindDto {
    id?: number;
    localizedName?: string;
    name?: string;
    products?: ProductDto2[];
    vehicles?: VehicleDto2[];

    constructor(data?: IAllKindDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductDto2.fromJS(item));
            }
            if (Array.isArray(_data["vehicles"])) {
                this.vehicles = [] as any;
                for (let item of _data["vehicles"])
                    this.vehicles!.push(VehicleDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllKindDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllKindDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        if (Array.isArray(this.vehicles)) {
            data["vehicles"] = [];
            for (let item of this.vehicles)
                data["vehicles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllKindDto {
    id?: number;
    localizedName?: string;
    name?: string;
    products?: ProductDto2[];
    vehicles?: VehicleDto2[];
}

export class ProductDto2 implements IProductDto2 {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    directSalesLicense?: boolean;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    isActive?: boolean;

    constructor(data?: IProductDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.productNo = _data["productNo"];
            this.oldProductNo = _data["oldProductNo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.productCatalog = _data["productCatalog"];
            this.orderRate = _data["orderRate"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.length = _data["length"];
            this.netWeight = _data["netWeight"];
            this.grossWeight = _data["grossWeight"];
            this.volumeWeight = _data["volumeWeight"];
            this.mileage = _data["mileage"];
            this.duration = _data["duration"];
            this.directSalesLicense = _data["directSalesLicense"];
            this.excerpt = _data["excerpt"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["productNo"] = this.productNo;
        data["oldProductNo"] = this.oldProductNo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["productCatalog"] = this.productCatalog;
        data["orderRate"] = this.orderRate;
        data["height"] = this.height;
        data["width"] = this.width;
        data["length"] = this.length;
        data["netWeight"] = this.netWeight;
        data["grossWeight"] = this.grossWeight;
        data["volumeWeight"] = this.volumeWeight;
        data["mileage"] = this.mileage;
        data["duration"] = this.duration;
        data["directSalesLicense"] = this.directSalesLicense;
        data["excerpt"] = this.excerpt;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductDto2 {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    directSalesLicense?: boolean;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    isActive?: boolean;
}

export class VehicleDto2 implements IVehicleDto2 {
    id?: number;
    vinNumber?: string;
    isActive?: boolean;

    constructor(data?: IVehicleDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): VehicleDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IVehicleDto2 {
    id?: number;
    vinNumber?: string;
    isActive?: boolean;
}

export class KindByIdDto implements IKindByIdDto {
    id?: number;
    localizedName?: string;
    name?: string;
    products?: ProductDto3[];
    vehicles?: VehicleDto3[];

    constructor(data?: IKindByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductDto3.fromJS(item));
            }
            if (Array.isArray(_data["vehicles"])) {
                this.vehicles = [] as any;
                for (let item of _data["vehicles"])
                    this.vehicles!.push(VehicleDto3.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KindByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new KindByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        if (Array.isArray(this.vehicles)) {
            data["vehicles"] = [];
            for (let item of this.vehicles)
                data["vehicles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IKindByIdDto {
    id?: number;
    localizedName?: string;
    name?: string;
    products?: ProductDto3[];
    vehicles?: VehicleDto3[];
}

export class ProductDto3 implements IProductDto3 {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    directSalesLicense?: boolean;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;

    constructor(data?: IProductDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.productNo = _data["productNo"];
            this.oldProductNo = _data["oldProductNo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.productCatalog = _data["productCatalog"];
            this.orderRate = _data["orderRate"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.length = _data["length"];
            this.netWeight = _data["netWeight"];
            this.grossWeight = _data["grossWeight"];
            this.volumeWeight = _data["volumeWeight"];
            this.mileage = _data["mileage"];
            this.duration = _data["duration"];
            this.directSalesLicense = _data["directSalesLicense"];
            this.excerpt = _data["excerpt"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
        }
    }

    static fromJS(data: any): ProductDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["productNo"] = this.productNo;
        data["oldProductNo"] = this.oldProductNo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["productCatalog"] = this.productCatalog;
        data["orderRate"] = this.orderRate;
        data["height"] = this.height;
        data["width"] = this.width;
        data["length"] = this.length;
        data["netWeight"] = this.netWeight;
        data["grossWeight"] = this.grossWeight;
        data["volumeWeight"] = this.volumeWeight;
        data["mileage"] = this.mileage;
        data["duration"] = this.duration;
        data["directSalesLicense"] = this.directSalesLicense;
        data["excerpt"] = this.excerpt;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        return data;
    }
}

export interface IProductDto3 {
    id?: number;
    code?: number;
    productNo?: string | undefined;
    oldProductNo?: string | undefined;
    localizedName?: string;
    name?: string;
    productCatalog?: string | undefined;
    orderRate?: number;
    height?: number | undefined;
    width?: number | undefined;
    length?: number | undefined;
    netWeight?: number | undefined;
    grossWeight?: number | undefined;
    volumeWeight?: number | undefined;
    mileage?: number | undefined;
    duration?: number | undefined;
    directSalesLicense?: boolean;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
}

export class VehicleDto3 implements IVehicleDto3 {
    id?: number;
    vinNumber?: string;

    constructor(data?: IVehicleDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
        }
    }

    static fromJS(data: any): VehicleDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        return data;
    }
}

export interface IVehicleDto3 {
    id?: number;
    vinNumber?: string;
}

export class KindByModelIdDto implements IKindByModelIdDto {
    id?: number;
    localizedName?: string;
    name?: string;

    constructor(data?: IKindByModelIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): KindByModelIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new KindByModelIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        return data;
    }
}

export interface IKindByModelIdDto {
    id?: number;
    localizedName?: string;
    name?: string;
}

export class PaginatedListOfModelWithPaginationDto implements IPaginatedListOfModelWithPaginationDto {
    items?: ModelWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfModelWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModelWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfModelWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfModelWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfModelWithPaginationDto {
    items?: ModelWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ModelWithPaginationDto implements IModelWithPaginationDto {
    id?: number;
    localizedName?: string;
    name?: string;
    kinds?: KindDto[];

    constructor(data?: IModelWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            if (Array.isArray(_data["kinds"])) {
                this.kinds = [] as any;
                for (let item of _data["kinds"])
                    this.kinds!.push(KindDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModelWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        if (Array.isArray(this.kinds)) {
            data["kinds"] = [];
            for (let item of this.kinds)
                data["kinds"].push(item.toJSON());
        }
        return data;
    }
}

export interface IModelWithPaginationDto {
    id?: number;
    localizedName?: string;
    name?: string;
    kinds?: KindDto[];
}

export class KindDto implements IKindDto {
    id?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;

    constructor(data?: IKindDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): KindDto {
        data = typeof data === 'object' ? data : {};
        let result = new KindDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IKindDto {
    id?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;
}

export class AllModelDto implements IAllModelDto {
    id?: number;
    localizedName?: string;
    name?: string;
    kinds?: KindDto2[];

    constructor(data?: IAllModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            if (Array.isArray(_data["kinds"])) {
                this.kinds = [] as any;
                for (let item of _data["kinds"])
                    this.kinds!.push(KindDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        if (Array.isArray(this.kinds)) {
            data["kinds"] = [];
            for (let item of this.kinds)
                data["kinds"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllModelDto {
    id?: number;
    localizedName?: string;
    name?: string;
    kinds?: KindDto2[];
}

export class KindDto2 implements IKindDto2 {
    id?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;

    constructor(data?: IKindDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): KindDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new KindDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IKindDto2 {
    id?: number;
    localizedName?: string;
    name?: string;
    isActive?: boolean;
}

export class ModelByFamilyIdDto implements IModelByFamilyIdDto {
    id?: number;
    localizedName?: string;
    name?: string;

    constructor(data?: IModelByFamilyIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ModelByFamilyIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelByFamilyIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        return data;
    }
}

export interface IModelByFamilyIdDto {
    id?: number;
    localizedName?: string;
    name?: string;
}

export class ModelByIdDto implements IModelByIdDto {
    id?: number;
    localizedName?: string;
    name?: string;
    kinds?: KindDto3[];

    constructor(data?: IModelByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            if (Array.isArray(_data["kinds"])) {
                this.kinds = [] as any;
                for (let item of _data["kinds"])
                    this.kinds!.push(KindDto3.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModelByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        if (Array.isArray(this.kinds)) {
            data["kinds"] = [];
            for (let item of this.kinds)
                data["kinds"].push(item.toJSON());
        }
        return data;
    }
}

export interface IModelByIdDto {
    id?: number;
    localizedName?: string;
    name?: string;
    kinds?: KindDto3[];
}

export class KindDto3 implements IKindDto3 {
    id?: number;
    localizedName?: string;
    name?: string;

    constructor(data?: IKindDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): KindDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new KindDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        return data;
    }
}

export interface IKindDto3 {
    id?: number;
    localizedName?: string;
    name?: string;
}

export class AllProductBrandDto implements IAllProductBrandDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto | undefined;
    products?: ProductDto4[] | undefined;

    constructor(data?: IAllProductBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.country = _data["country"] ? CountryDto.fromJS(_data["country"]) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductDto4.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllProductBrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllProductBrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllProductBrandDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto | undefined;
    products?: ProductDto4[] | undefined;
}

export class CountryDto implements ICountryDto {
    id?: number;
    localizedName?: string;
    name?: string;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryDto {
    id?: number;
    localizedName?: string;
    name?: string;
}

export class ProductDto4 implements IProductDto4 {
    id?: number;
    localizedName?: string;
    name?: string;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    isActive?: boolean;

    constructor(data?: IProductDto4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.excerpt = _data["excerpt"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductDto4 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["excerpt"] = this.excerpt;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductDto4 {
    id?: number;
    localizedName?: string;
    name?: string;
    excerpt?: string;
    description?: string;
    slug?: string;
    sku?: string | undefined;
    isActive?: boolean;
}

export class PaginatedListOfProductBrandWithPaginationDto implements IPaginatedListOfProductBrandWithPaginationDto {
    items?: ProductBrandWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductBrandWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductBrandWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductBrandWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductBrandWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductBrandWithPaginationDto {
    items?: ProductBrandWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductBrandWithPaginationDto implements IProductBrandWithPaginationDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto2 | undefined;

    constructor(data?: IProductBrandWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.country = _data["country"] ? CountryDto2.fromJS(_data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductBrandWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBrandWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductBrandWithPaginationDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto2 | undefined;
}

export class CountryDto2 implements ICountryDto2 {
    id?: number;
    localizedName?: string;
    name?: string;

    constructor(data?: ICountryDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryDto2 {
    id?: number;
    localizedName?: string;
    name?: string;
}

export class PaginatedListOfProductBrandForBlockDto implements IPaginatedListOfProductBrandForBlockDto {
    items?: ProductBrandForBlockDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProductBrandForBlockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductBrandForBlockDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProductBrandForBlockDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProductBrandForBlockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProductBrandForBlockDto {
    items?: ProductBrandForBlockDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductBrandForBlockDto implements IProductBrandForBlockDto {
    id?: number;
    name?: string;
    slug?: string;
    brandLogo?: string | undefined;
    countryName?: string;

    constructor(data?: IProductBrandForBlockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.brandLogo = _data["brandLogo"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): ProductBrandForBlockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBrandForBlockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["brandLogo"] = this.brandLogo;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IProductBrandForBlockDto {
    id?: number;
    name?: string;
    slug?: string;
    brandLogo?: string | undefined;
    countryName?: string;
}

export class ProductBrandByIdDto implements IProductBrandByIdDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto3 | undefined;

    constructor(data?: IProductBrandByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.country = _data["country"] ? CountryDto3.fromJS(_data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductBrandByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBrandByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductBrandByIdDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto3 | undefined;
}

export class CountryDto3 implements ICountryDto3 {
    id?: number;
    localizedName?: string;
    name?: string;

    constructor(data?: ICountryDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryDto3 {
    id?: number;
    localizedName?: string;
    name?: string;
}

export class AllVehicleBrandDto implements IAllVehicleBrandDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto4 | undefined;

    constructor(data?: IAllVehicleBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.country = _data["country"] ? CountryDto4.fromJS(_data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AllVehicleBrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllVehicleBrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAllVehicleBrandDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto4 | undefined;
}

export class CountryDto4 implements ICountryDto4 {
    id?: number;
    localizedName?: string;
    name?: string;

    constructor(data?: ICountryDto4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto4 {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryDto4 {
    id?: number;
    localizedName?: string;
    name?: string;
}

export class PaginatedListOfVehicleBrandWithPaginationDto implements IPaginatedListOfVehicleBrandWithPaginationDto {
    items?: VehicleBrandWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfVehicleBrandWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VehicleBrandWithPaginationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfVehicleBrandWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfVehicleBrandWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfVehicleBrandWithPaginationDto {
    items?: VehicleBrandWithPaginationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class VehicleBrandWithPaginationDto implements IVehicleBrandWithPaginationDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto5 | undefined;

    constructor(data?: IVehicleBrandWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.country = _data["country"] ? CountryDto5.fromJS(_data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VehicleBrandWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleBrandWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVehicleBrandWithPaginationDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto5 | undefined;
}

export class CountryDto5 implements ICountryDto5 {
    id?: number;
    localizedName?: string;
    name?: string;

    constructor(data?: ICountryDto5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto5 {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryDto5 {
    id?: number;
    localizedName?: string;
    name?: string;
}

export class PaginatedListOfVehicleBrandForBlockDto implements IPaginatedListOfVehicleBrandForBlockDto {
    items?: VehicleBrandForBlockDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfVehicleBrandForBlockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VehicleBrandForBlockDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfVehicleBrandForBlockDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfVehicleBrandForBlockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfVehicleBrandForBlockDto {
    items?: VehicleBrandForBlockDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class VehicleBrandForBlockDto implements IVehicleBrandForBlockDto {
    id?: number;
    name?: string;
    slug?: string;
    brandLogo?: string | undefined;
    countryName?: string;

    constructor(data?: IVehicleBrandForBlockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.brandLogo = _data["brandLogo"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): VehicleBrandForBlockDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleBrandForBlockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["brandLogo"] = this.brandLogo;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IVehicleBrandForBlockDto {
    id?: number;
    name?: string;
    slug?: string;
    brandLogo?: string | undefined;
    countryName?: string;
}

export class VehicleBrandByIdDto implements IVehicleBrandByIdDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto6 | undefined;

    constructor(data?: IVehicleBrandByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandLogo = _data["brandLogo"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.country = _data["country"] ? CountryDto6.fromJS(_data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VehicleBrandByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleBrandByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandLogo"] = this.brandLogo;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVehicleBrandByIdDto {
    id?: number;
    brandLogo?: string | undefined;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
    country?: CountryDto6 | undefined;
}

export class CountryDto6 implements ICountryDto6 {
    id?: number;
    localizedName?: string;
    name?: string;

    constructor(data?: ICountryDto6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto6 {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryDto6 {
    id?: number;
    localizedName?: string;
    name?: string;
}

export class AllVehicleBrandForDropDownDto implements IAllVehicleBrandForDropDownDto {
    id?: number;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;

    constructor(data?: IAllVehicleBrandForDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): AllVehicleBrandForDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllVehicleBrandForDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IAllVehicleBrandForDropDownDto {
    id?: number;
    localizedName?: string | undefined;
    name?: string;
    slug?: string | undefined;
}

export class VehicleByIdDto implements IVehicleByIdDto {
    id?: number;
    vinNumber?: string;
    kind?: KindDto4;
    customers?: CustomerDto5[];

    constructor(data?: IVehicleByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.kind = _data["kind"] ? KindDto4.fromJS(_data["kind"]) : <any>undefined;
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(CustomerDto5.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["kind"] = this.kind ? this.kind.toJSON() : <any>undefined;
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVehicleByIdDto {
    id?: number;
    vinNumber?: string;
    kind?: KindDto4;
    customers?: CustomerDto5[];
}

export class KindDto4 implements IKindDto4 {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;

    constructor(data?: IKindDto4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.brandLocalizedName = _data["brandLocalizedName"];
            this.familyName = _data["familyName"];
            this.familyLocalizedName = _data["familyLocalizedName"];
            this.modelName = _data["modelName"];
            this.modelLocalizedName = _data["modelLocalizedName"];
        }
    }

    static fromJS(data: any): KindDto4 {
        data = typeof data === 'object' ? data : {};
        let result = new KindDto4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["brandLocalizedName"] = this.brandLocalizedName;
        data["familyName"] = this.familyName;
        data["familyLocalizedName"] = this.familyLocalizedName;
        data["modelName"] = this.modelName;
        data["modelLocalizedName"] = this.modelLocalizedName;
        return data;
    }
}

export interface IKindDto4 {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;
}

export class CustomerDto5 implements ICustomerDto5 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerDto5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerDto5 {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerDto5 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class VehicleByKindIdDto implements IVehicleByKindIdDto {
    id?: number;
    vinNumber?: string;
    kind?: KindDto5;
    customers?: CustomerDto6[];

    constructor(data?: IVehicleByKindIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.kind = _data["kind"] ? KindDto5.fromJS(_data["kind"]) : <any>undefined;
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(CustomerDto6.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleByKindIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleByKindIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["kind"] = this.kind ? this.kind.toJSON() : <any>undefined;
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVehicleByKindIdDto {
    id?: number;
    vinNumber?: string;
    kind?: KindDto5;
    customers?: CustomerDto6[];
}

export class KindDto5 implements IKindDto5 {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;

    constructor(data?: IKindDto5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.brandLocalizedName = _data["brandLocalizedName"];
            this.familyName = _data["familyName"];
            this.familyLocalizedName = _data["familyLocalizedName"];
            this.modelName = _data["modelName"];
            this.modelLocalizedName = _data["modelLocalizedName"];
        }
    }

    static fromJS(data: any): KindDto5 {
        data = typeof data === 'object' ? data : {};
        let result = new KindDto5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["brandLocalizedName"] = this.brandLocalizedName;
        data["familyName"] = this.familyName;
        data["familyLocalizedName"] = this.familyLocalizedName;
        data["modelName"] = this.modelName;
        data["modelLocalizedName"] = this.modelLocalizedName;
        return data;
    }
}

export interface IKindDto5 {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;
}

export class CustomerDto6 implements ICustomerDto6 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerDto6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerDto6 {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerDto6 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class VehicleByVinNumberDto implements IVehicleByVinNumberDto {
    id?: number;
    vinNumber?: string;
    kind?: KindDto6;
    customers?: CustomerDto7[];

    constructor(data?: IVehicleByVinNumberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.kind = _data["kind"] ? KindDto6.fromJS(_data["kind"]) : <any>undefined;
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(CustomerDto7.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleByVinNumberDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleByVinNumberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["kind"] = this.kind ? this.kind.toJSON() : <any>undefined;
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVehicleByVinNumberDto {
    id?: number;
    vinNumber?: string;
    kind?: KindDto6;
    customers?: CustomerDto7[];
}

export class KindDto6 implements IKindDto6 {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;

    constructor(data?: IKindDto6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.brandLocalizedName = _data["brandLocalizedName"];
            this.familyName = _data["familyName"];
            this.familyLocalizedName = _data["familyLocalizedName"];
            this.modelName = _data["modelName"];
            this.modelLocalizedName = _data["modelLocalizedName"];
        }
    }

    static fromJS(data: any): KindDto6 {
        data = typeof data === 'object' ? data : {};
        let result = new KindDto6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["brandLocalizedName"] = this.brandLocalizedName;
        data["familyName"] = this.familyName;
        data["familyLocalizedName"] = this.familyLocalizedName;
        data["modelName"] = this.modelName;
        data["modelLocalizedName"] = this.modelLocalizedName;
        return data;
    }
}

export interface IKindDto6 {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;
}

export class CustomerDto7 implements ICustomerDto7 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerDto7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerDto7 {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerDto7 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class VehicleByCustomerIdDto implements IVehicleByCustomerIdDto {
    id?: number;
    vinNumber?: string;
    kind?: KindDto7;

    constructor(data?: IVehicleByCustomerIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.kind = _data["kind"] ? KindDto7.fromJS(_data["kind"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VehicleByCustomerIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleByCustomerIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["kind"] = this.kind ? this.kind.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVehicleByCustomerIdDto {
    id?: number;
    vinNumber?: string;
    kind?: KindDto7;
}

export class KindDto7 implements IKindDto7 {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;

    constructor(data?: IKindDto7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.brandLocalizedName = _data["brandLocalizedName"];
            this.familyName = _data["familyName"];
            this.familyLocalizedName = _data["familyLocalizedName"];
            this.modelName = _data["modelName"];
            this.modelLocalizedName = _data["modelLocalizedName"];
        }
    }

    static fromJS(data: any): KindDto7 {
        data = typeof data === 'object' ? data : {};
        let result = new KindDto7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["brandLocalizedName"] = this.brandLocalizedName;
        data["familyName"] = this.familyName;
        data["familyLocalizedName"] = this.familyLocalizedName;
        data["modelName"] = this.modelName;
        data["modelLocalizedName"] = this.modelLocalizedName;
        return data;
    }
}

export interface IKindDto7 {
    id?: number;
    localizedName?: string;
    name?: string;
    brandName?: string;
    brandLocalizedName?: string;
    familyName?: string;
    familyLocalizedName?: string;
    modelName?: string;
    modelLocalizedName?: string;
}

export class CreateVehicleCommand implements ICreateVehicleCommand {
    vinNumber?: string | undefined;
    kindId?: number;
    customerId?: string;

    constructor(data?: ICreateVehicleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vinNumber = _data["vinNumber"];
            this.kindId = _data["kindId"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): CreateVehicleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVehicleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vinNumber"] = this.vinNumber;
        data["kindId"] = this.kindId;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface ICreateVehicleCommand {
    vinNumber?: string | undefined;
    kindId?: number;
    customerId?: string;
}

export class UpdateVehicleCommand implements IUpdateVehicleCommand {
    id?: number;
    vinNumber?: string | undefined;
    kindId?: number;
    customerId?: string;

    constructor(data?: IUpdateVehicleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vinNumber = _data["vinNumber"];
            this.kindId = _data["kindId"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): UpdateVehicleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateVehicleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vinNumber"] = this.vinNumber;
        data["kindId"] = this.kindId;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IUpdateVehicleCommand {
    id?: number;
    vinNumber?: string | undefined;
    kindId?: number;
    customerId?: string;
}

export class CommentDto implements ICommentDto {
    id?: number;
    text?: string;
    date?: Date;
    author?: CustomerDto8;
    isActive?: boolean;

    constructor(data?: ICommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.author = _data["author"] ? CustomerDto8.fromJS(_data["author"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICommentDto {
    id?: number;
    text?: string;
    date?: Date;
    author?: CustomerDto8;
    isActive?: boolean;
}

export class CustomerDto8 implements ICustomerDto8 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerDto8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerDto8 {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerDto8 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class CreateCommentCommand implements ICreateCommentCommand {
    text?: string;
    authorId?: string;
    postId?: number;
    parentCommentId?: number | undefined;
    isActive?: boolean;

    constructor(data?: ICreateCommentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.authorId = _data["authorId"];
            this.postId = _data["postId"];
            this.parentCommentId = _data["parentCommentId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateCommentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["authorId"] = this.authorId;
        data["postId"] = this.postId;
        data["parentCommentId"] = this.parentCommentId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateCommentCommand {
    text?: string;
    authorId?: string;
    postId?: number;
    parentCommentId?: number | undefined;
    isActive?: boolean;
}

export class UpdateCommentCommand implements IUpdateCommentCommand {
    id?: number;
    text?: string;
    authorId?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpdateCommentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.authorId = _data["authorId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateCommentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["authorId"] = this.authorId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateCommentCommand {
    id?: number;
    text?: string;
    authorId?: string | undefined;
    isActive?: boolean;
}

export class PaginatedListOfPostDto implements IPaginatedListOfPostDto {
    items?: PostDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PostDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfPostDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfPostDto {
    items?: PostDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PostDto implements IPostDto {
    id?: number;
    title?: string;
    body?: string;
    image?: string | undefined;
    date?: Date;
    author?: UserDto;
    comments?: CommentDto[];
    isActive?: boolean;

    constructor(data?: IPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.body = _data["body"];
            this.image = _data["image"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.author = _data["author"] ? UserDto.fromJS(_data["author"]) : <any>undefined;
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PostDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["body"] = this.body;
        data["image"] = this.image;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IPostDto {
    id?: number;
    title?: string;
    body?: string;
    image?: string | undefined;
    date?: Date;
    author?: UserDto;
    comments?: CommentDto[];
    isActive?: boolean;
}

export class UserDto implements IUserDto {
    id?: string;
    avatar?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface IUserDto {
    id?: string;
    avatar?: string | undefined;
}

export class WidgetCommentDto implements IWidgetCommentDto {
    id?: number;
    postTitle?: string | undefined;
    text?: string | undefined;
    date?: Date;
    author?: CustomerDto9;
    isActive?: boolean;

    constructor(data?: IWidgetCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.postTitle = _data["postTitle"];
            this.text = _data["text"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.author = _data["author"] ? CustomerDto9.fromJS(_data["author"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): WidgetCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["postTitle"] = this.postTitle;
        data["text"] = this.text;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IWidgetCommentDto {
    id?: number;
    postTitle?: string | undefined;
    text?: string | undefined;
    date?: Date;
    author?: CustomerDto9;
    isActive?: boolean;
}

export class CustomerDto9 implements ICustomerDto9 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICustomerDto9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CustomerDto9 {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICustomerDto9 {
    id?: string;
    company?: string | undefined;
    avatar?: string | undefined;
}

export class UpdateWidgetCommentCommand implements IUpdateWidgetCommentCommand {
    id?: number;
    postTitle?: string | undefined;
    text?: string | undefined;
    authorId?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpdateWidgetCommentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.postTitle = _data["postTitle"];
            this.text = _data["text"];
            this.authorId = _data["authorId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateWidgetCommentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWidgetCommentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["postTitle"] = this.postTitle;
        data["text"] = this.text;
        data["authorId"] = this.authorId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateWidgetCommentCommand {
    id?: number;
    postTitle?: string | undefined;
    text?: string | undefined;
    authorId?: string | undefined;
    isActive?: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}